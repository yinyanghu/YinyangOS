
kernel:     file format elf32-i386


Disassembly of section .text:

c0100000 <init_service>:
		idle_cpu();
	}
}

void init_service(void) {
	init_mm();
c0100000:	e9 7b 27 00 00       	jmp    c0102780 <init_mm>
c0100005:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0100009:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0100010 <welcome>:
}

void
welcome(void) {
c0100010:	53                   	push   %ebx
c0100011:	83 ec 18             	sub    $0x18,%esp
	static char prompt[] = "Hello, OS World!\n";
	const char *str;
	for (str = prompt; *str; str ++)
c0100014:	0f b6 05 d4 4b 10 c0 	movzbl 0xc0104bd4,%eax
c010001b:	84 c0                	test   %al,%al
c010001d:	74 1e                	je     c010003d <welcome+0x2d>
c010001f:	bb d4 4b 10 c0       	mov    $0xc0104bd4,%ebx
c0100024:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		console_printc(*str);
c0100028:	0f be c0             	movsbl %al,%eax

void
welcome(void) {
	static char prompt[] = "Hello, OS World!\n";
	const char *str;
	for (str = prompt; *str; str ++)
c010002b:	83 c3 01             	add    $0x1,%ebx
		console_printc(*str);
c010002e:	89 04 24             	mov    %eax,(%esp)
c0100031:	e8 2a 03 00 00       	call   c0100360 <console_printc>

void
welcome(void) {
	static char prompt[] = "Hello, OS World!\n";
	const char *str;
	for (str = prompt; *str; str ++)
c0100036:	0f b6 03             	movzbl (%ebx),%eax
c0100039:	84 c0                	test   %al,%al
c010003b:	75 eb                	jne    c0100028 <welcome+0x18>
		console_printc(*str);
	printk("Hello Yinyanghu!\n");
c010003d:	c7 04 24 c0 34 10 c0 	movl   $0xc01034c0,(%esp)
c0100044:	e8 47 03 00 00       	call   c0100390 <printk>
}
c0100049:	83 c4 18             	add    $0x18,%esp
c010004c:	5b                   	pop    %ebx
c010004d:	c3                   	ret    
c010004e:	66 90                	xchg   %ax,%ax

c0100050 <os_init>:

void welcome(void);
void init_service(void);

void
os_init(void) {
c0100050:	83 ec 0c             	sub    $0xc,%esp
	/* Notice that when we are here, IF is always 0 (see bootloader) */

	/* We must set up kernel virtual memory first because our kernel
	   thinks it is located in 0xC0000000.
	   Before setting up correct paging, no global variable can be used. */
	init_page();
c0100053:	e8 b8 05 00 00       	call   c0100610 <init_page>

	/* Reset the GDT. Although user processes in Nanos run in Ring 0,
	   they have their own virtual address space. Therefore, the
	   old GDT located in physical address 0x7C00 cannot be used again. */
	init_segment();
c0100058:	e8 63 06 00 00       	call   c01006c0 <init_segment>

	/* Flush the screen, move cursor to (0, 0). */
	init_screen();
c010005d:	e8 3e 00 00 00       	call   c01000a0 <init_screen>

	/* Initialize interrupt handlers */
	init_handle();
c0100062:	e8 d9 0c 00 00       	call   c0100d40 <init_handle>

	/* Set up interrupt and exception handlers,
	   just as we did in the game. */
	init_idt();
c0100067:	e8 24 08 00 00       	call   c0100890 <init_idt>
c010006c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	/* Initialize the intel 8259 PIC. */
	init_intr();
c0100070:	e8 4b 07 00 00       	call   c01007c0 <init_intr>

	/* Initialize the drivers. */
	init_drivers();
c0100075:	e8 f6 25 00 00       	call   c0102670 <init_drivers>
		idle_cpu();
	}
}

void init_service(void) {
	init_mm();
c010007a:	e8 01 27 00 00       	call   c0102780 <init_mm>
c010007f:	90                   	nop
	
	/* Initialize the services. */
	init_service();

	/* Initialize process table. You should fill this. */
	init_proc();
c0100080:	e8 4b 11 00 00       	call   c01011d0 <init_proc>

	welcome();
c0100085:	e8 86 ff ff ff       	call   c0100010 <welcome>
	//asm volatile("movl %%esp, %0" : "=r"(stack_ptr));
	//printk("%d\n", stack_ptr);
	//printk("%d\n", *(uint_32 *)(stack_ptr + 4));
	//panic("sss");
	//current_pcb -> esp = (void *)(stack_ptr + 4);
	asm volatile("addl $0xC0000000, %esp");
c010008a:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	asm volatile("lidt (%0)" : : "r"(data));
}

static inline void
enable_interrupt(void) {
	asm volatile("sti");
c0100090:	fb                   	sti    
c0100091:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
};

/* put the CPU into idle, waiting for next interrupt */
static inline void
idle_cpu() {
	asm volatile("hlt");
c0100098:	f4                   	hlt    
c0100099:	eb fd                	jmp    c0100098 <os_init+0x48>
c010009b:	90                   	nop
c010009c:	90                   	nop
c010009d:	90                   	nop
c010009e:	90                   	nop
c010009f:	90                   	nop

c01000a0 <init_screen>:
	out_byte(CRT_PORT_SEL, 0x0F);
	out_byte(CRT_PORT_DAT, ((x * 80 + y)     ) & 0xFF );
}

void
init_screen() {
c01000a0:	56                   	push   %esi
	int i;
	for (i = 0; i < CRT_COLUMN * CRT_ROW; i ++)
c01000a1:	31 c0                	xor    %eax,%eax
	out_byte(CRT_PORT_SEL, 0x0F);
	out_byte(CRT_PORT_DAT, ((x * 80 + y)     ) & 0xFF );
}

void
init_screen() {
c01000a3:	53                   	push   %ebx
c01000a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int i;
	for (i = 0; i < CRT_COLUMN * CRT_ROW; i ++)
		vmem[i] = (BLACK << 12) | (WHITE << 8) | ' ';
c01000a8:	66 c7 84 00 00 80 0b 	movw   $0x720,-0x3ff48000(%eax,%eax,1)
c01000af:	c0 20 07 
}

void
init_screen() {
	int i;
	for (i = 0; i < CRT_COLUMN * CRT_ROW; i ++)
c01000b2:	83 c0 01             	add    $0x1,%eax
c01000b5:	3d d0 07 00 00       	cmp    $0x7d0,%eax
c01000ba:	75 ec                	jne    c01000a8 <init_screen+0x8>
	return data;
}

static inline void
out_byte(uint_16 port, uint_8 data) {
	asm volatile("out %%al, %%dx" : : "a"(data), "d"(port));
c01000bc:	be d4 03 00 00       	mov    $0x3d4,%esi
c01000c1:	b8 0e 00 00 00       	mov    $0xe,%eax
c01000c6:	89 f2                	mov    %esi,%edx
c01000c8:	ee                   	out    %al,(%dx)
c01000c9:	31 c9                	xor    %ecx,%ecx
c01000cb:	bb d5 03 00 00       	mov    $0x3d5,%ebx
c01000d0:	89 c8                	mov    %ecx,%eax
c01000d2:	89 da                	mov    %ebx,%edx
		vmem[i] = (BLACK << 12) | (WHITE << 8) | ' ';
	x = 0; y = 0;
c01000d4:	c7 05 00 50 10 c0 00 	movl   $0x0,0xc0105000
c01000db:	00 00 00 
c01000de:	ee                   	out    %al,(%dx)
c01000df:	c7 05 04 50 10 c0 00 	movl   $0x0,0xc0105004
c01000e6:	00 00 00 
c01000e9:	b8 0f 00 00 00       	mov    $0xf,%eax
c01000ee:	89 f2                	mov    %esi,%edx
c01000f0:	ee                   	out    %al,(%dx)
c01000f1:	89 c8                	mov    %ecx,%eax
c01000f3:	89 da                	mov    %ebx,%edx
c01000f5:	ee                   	out    %al,(%dx)
	move_cursor(0, 0);
}
c01000f6:	5b                   	pop    %ebx
c01000f7:	5e                   	pop    %esi
c01000f8:	c3                   	ret    
c01000f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c0100100 <cursor_left>:

void
cursor_left(int count) {
c0100100:	55                   	push   %ebp
c0100101:	57                   	push   %edi
c0100102:	56                   	push   %esi
c0100103:	53                   	push   %ebx
c0100104:	83 ec 04             	sub    $0x4,%esp
c0100107:	8b 7c 24 18          	mov    0x18(%esp),%edi
	while (count --) {
c010010b:	85 ff                	test   %edi,%edi
c010010d:	74 7d                	je     c010018c <cursor_left+0x8c>
c010010f:	83 ef 01             	sub    $0x1,%edi
c0100112:	8b 1d 04 50 10 c0    	mov    0xc0105004,%ebx
c0100118:	8b 0d 00 50 10 c0    	mov    0xc0105000,%ecx
c010011e:	eb 43                	jmp    c0100163 <cursor_left+0x63>
		y --;
		if (y < 0) {
c0100120:	89 ea                	mov    %ebp,%edx
c0100122:	89 eb                	mov    %ebp,%ebx
c0100124:	88 54 24 03          	mov    %dl,0x3(%esp)
c0100128:	b8 0e 00 00 00       	mov    $0xe,%eax
c010012d:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0100132:	ee                   	out    %al,(%dx)
   so the hardware separates the 16-bit cursor position
   into two registers. */
static void
move_cursor(int x, int y) {
	out_byte(CRT_PORT_SEL, 0x0E);
	out_byte(CRT_PORT_DAT, ((x * 80 + y) >> 8) & 0xFF );
c0100133:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
c0100136:	be d5 03 00 00       	mov    $0x3d5,%esi
c010013b:	c1 e0 04             	shl    $0x4,%eax
c010013e:	89 f2                	mov    %esi,%edx
c0100140:	01 d8                	add    %ebx,%eax
c0100142:	c1 f8 08             	sar    $0x8,%eax
c0100145:	ee                   	out    %al,(%dx)
c0100146:	b8 0f 00 00 00       	mov    $0xf,%eax
c010014b:	b2 d4                	mov    $0xd4,%dl
c010014d:	ee                   	out    %al,(%dx)
	out_byte(CRT_PORT_SEL, 0x0F);
	out_byte(CRT_PORT_DAT, ((x * 80 + y)     ) & 0xFF );
c010014e:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
c0100151:	89 f2                	mov    %esi,%edx
c0100153:	c1 e0 04             	shl    $0x4,%eax
c0100156:	02 44 24 03          	add    0x3(%esp),%al
c010015a:	ee                   	out    %al,(%dx)
	move_cursor(0, 0);
}

void
cursor_left(int count) {
	while (count --) {
c010015b:	83 ef 01             	sub    $0x1,%edi
c010015e:	83 ff ff             	cmp    $0xffffffff,%edi
c0100161:	74 1d                	je     c0100180 <cursor_left+0x80>
		y --;
		if (y < 0) {
c0100163:	89 dd                	mov    %ebx,%ebp
c0100165:	83 ed 01             	sub    $0x1,%ebp
c0100168:	79 b6                	jns    c0100120 <cursor_left+0x20>
			y = CRT_COLUMN - 1;
			x --;
c010016a:	83 e9 01             	sub    $0x1,%ecx
void
cursor_left(int count) {
	while (count --) {
		y --;
		if (y < 0) {
			y = CRT_COLUMN - 1;
c010016d:	bd 4f 00 00 00       	mov    $0x4f,%ebp
			x --;
c0100172:	c6 44 24 03 4f       	movb   $0x4f,0x3(%esp)
c0100177:	bb 4f 00 00 00       	mov    $0x4f,%ebx
c010017c:	eb aa                	jmp    c0100128 <cursor_left+0x28>
c010017e:	66 90                	xchg   %ax,%ax
	move_cursor(0, 0);
}

void
cursor_left(int count) {
	while (count --) {
c0100180:	89 2d 04 50 10 c0    	mov    %ebp,0xc0105004
c0100186:	89 0d 00 50 10 c0    	mov    %ecx,0xc0105000
			y = CRT_COLUMN - 1;
			x --;
		}
		move_cursor(x, y);
	}
}
c010018c:	83 c4 04             	add    $0x4,%esp
c010018f:	5b                   	pop    %ebx
c0100190:	5e                   	pop    %esi
c0100191:	5f                   	pop    %edi
c0100192:	5d                   	pop    %ebp
c0100193:	c3                   	ret    
c0100194:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c010019a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

c01001a0 <cursor_right>:

void
cursor_right(int count) {
c01001a0:	57                   	push   %edi
	while (count --) {
c01001a1:	a1 04 50 10 c0       	mov    0xc0105004,%eax
		move_cursor(x, y);
	}
}

void
cursor_right(int count) {
c01001a6:	56                   	push   %esi
c01001a7:	53                   	push   %ebx
	while (count --) {
c01001a8:	8b 1d 00 50 10 c0    	mov    0xc0105000,%ebx
		move_cursor(x, y);
	}
}

void
cursor_right(int count) {
c01001ae:	8b 54 24 10          	mov    0x10(%esp),%edx
	while (count --) {
c01001b2:	89 c1                	mov    %eax,%ecx
c01001b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c01001b8:	83 ea 01             	sub    $0x1,%edx
c01001bb:	83 fa ff             	cmp    $0xffffffff,%edx
c01001be:	74 19                	je     c01001d9 <cursor_right+0x39>
		y ++;
c01001c0:	8d 41 01             	lea    0x1(%ecx),%eax
		if (y >= CRT_COLUMN) {
c01001c3:	83 f8 4f             	cmp    $0x4f,%eax
c01001c6:	89 c1                	mov    %eax,%ecx
c01001c8:	7e ee                	jle    c01001b8 <cursor_right+0x18>
	}
}

void
cursor_right(int count) {
	while (count --) {
c01001ca:	83 ea 01             	sub    $0x1,%edx
		y ++;
		if (y >= CRT_COLUMN) {
			x ++;
c01001cd:	83 c3 01             	add    $0x1,%ebx
			y = 0;
c01001d0:	31 c0                	xor    %eax,%eax
void
cursor_right(int count) {
	while (count --) {
		y ++;
		if (y >= CRT_COLUMN) {
			x ++;
c01001d2:	31 c9                	xor    %ecx,%ecx
	}
}

void
cursor_right(int count) {
	while (count --) {
c01001d4:	83 fa ff             	cmp    $0xffffffff,%edx
c01001d7:	75 e7                	jne    c01001c0 <cursor_right+0x20>
c01001d9:	be d4 03 00 00       	mov    $0x3d4,%esi
c01001de:	a3 04 50 10 c0       	mov    %eax,0xc0105004
c01001e3:	89 f2                	mov    %esi,%edx
c01001e5:	b8 0e 00 00 00       	mov    $0xe,%eax
c01001ea:	89 1d 00 50 10 c0    	mov    %ebx,0xc0105000
c01001f0:	ee                   	out    %al,(%dx)
   so the hardware separates the 16-bit cursor position
   into two registers. */
static void
move_cursor(int x, int y) {
	out_byte(CRT_PORT_SEL, 0x0E);
	out_byte(CRT_PORT_DAT, ((x * 80 + y) >> 8) & 0xFF );
c01001f1:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
c01001f4:	bf d5 03 00 00       	mov    $0x3d5,%edi
c01001f9:	c1 e0 04             	shl    $0x4,%eax
c01001fc:	89 fa                	mov    %edi,%edx
c01001fe:	01 c8                	add    %ecx,%eax
c0100200:	c1 f8 08             	sar    $0x8,%eax
c0100203:	ee                   	out    %al,(%dx)
c0100204:	b8 0f 00 00 00       	mov    $0xf,%eax
c0100209:	89 f2                	mov    %esi,%edx
c010020b:	ee                   	out    %al,(%dx)
	out_byte(CRT_PORT_SEL, 0x0F);
	out_byte(CRT_PORT_DAT, ((x * 80 + y)     ) & 0xFF );
c010020c:	8d 1c 9b             	lea    (%ebx,%ebx,4),%ebx
c010020f:	89 fa                	mov    %edi,%edx
c0100211:	c1 e3 04             	shl    $0x4,%ebx
c0100214:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
c0100217:	ee                   	out    %al,(%dx)
			x ++;
			y = 0;
		}
	}
	move_cursor(x, y);
}
c0100218:	5b                   	pop    %ebx
c0100219:	5e                   	pop    %esi
c010021a:	5f                   	pop    %edi
c010021b:	c3                   	ret    
c010021c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c0100220 <color_console_printc>:
		vmem[CRT_ROW * CRT_COLUMN - i - 1] = (BLACK << 12) | (WHITE << 8) | ' ';
}

/* find the postion, then put the character */
void
color_console_printc(int forecolor, int backcolor, char ch) {
c0100220:	55                   	push   %ebp
c0100221:	57                   	push   %edi
c0100222:	56                   	push   %esi
	switch (ch) {
	case '\n': /* everyone will get mad if linebreak is not provided */
		x ++;
c0100223:	8b 35 00 50 10 c0    	mov    0xc0105000,%esi
		vmem[CRT_ROW * CRT_COLUMN - i - 1] = (BLACK << 12) | (WHITE << 8) | ' ';
}

/* find the postion, then put the character */
void
color_console_printc(int forecolor, int backcolor, char ch) {
c0100229:	53                   	push   %ebx
c010022a:	0f b6 44 24 1c       	movzbl 0x1c(%esp),%eax
	switch (ch) {
c010022f:	3c 0a                	cmp    $0xa,%al
c0100231:	0f 84 c0 00 00 00    	je     c01002f7 <color_console_printc+0xd7>
	case '\n': /* everyone will get mad if linebreak is not provided */
		x ++;
		y = 0;
		break;
	default: /* print the character otherwise */
		vmem[x * CRT_COLUMN + y] = (backcolor << 12) | (forecolor << 8) | ch;
c0100237:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c010023b:	66 98                	cbtw   
c010023d:	8b 0d 04 50 10 c0    	mov    0xc0105004,%ecx
c0100243:	8d 14 b6             	lea    (%esi,%esi,4),%edx
c0100246:	c1 e2 04             	shl    $0x4,%edx
c0100249:	c1 e3 0c             	shl    $0xc,%ebx
c010024c:	09 d8                	or     %ebx,%eax
c010024e:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c0100252:	01 ca                	add    %ecx,%edx
		y ++;
c0100254:	83 c1 01             	add    $0x1,%ecx
c0100257:	89 0d 04 50 10 c0    	mov    %ecx,0xc0105004
		if (y >= CRT_COLUMN) {
c010025d:	89 cd                	mov    %ecx,%ebp
	case '\n': /* everyone will get mad if linebreak is not provided */
		x ++;
		y = 0;
		break;
	default: /* print the character otherwise */
		vmem[x * CRT_COLUMN + y] = (backcolor << 12) | (forecolor << 8) | ch;
c010025f:	c1 e3 08             	shl    $0x8,%ebx
c0100262:	09 d8                	or     %ebx,%eax
		y ++;
		if (y >= CRT_COLUMN) {
c0100264:	83 f9 4f             	cmp    $0x4f,%ecx
	case '\n': /* everyone will get mad if linebreak is not provided */
		x ++;
		y = 0;
		break;
	default: /* print the character otherwise */
		vmem[x * CRT_COLUMN + y] = (backcolor << 12) | (forecolor << 8) | ch;
c0100267:	66 89 84 12 00 80 0b 	mov    %ax,-0x3ff48000(%edx,%edx,1)
c010026e:	c0 
		y ++;
		if (y >= CRT_COLUMN) {
c010026f:	0f 8f 82 00 00 00    	jg     c01002f7 <color_console_printc+0xd7>
			x ++;
			y = 0;
		}
	}
	if (x >= CRT_ROW) { /* bottom touched! */
c0100275:	83 fe 18             	cmp    $0x18,%esi
c0100278:	0f 8e 99 00 00 00    	jle    c0100317 <color_console_printc+0xf7>
		x = CRT_ROW - 1;
c010027e:	c7 05 00 50 10 c0 18 	movl   $0x18,0xc0105000
c0100285:	00 00 00 


static void
wrap_screen() {
	int i;
	for (i = CRT_COLUMN; i < CRT_ROW * CRT_COLUMN; i ++)
c0100288:	b8 50 00 00 00       	mov    $0x50,%eax
c010028d:	8d 76 00             	lea    0x0(%esi),%esi
		vmem[i - CRT_COLUMN] = vmem[i];
c0100290:	0f b7 94 00 00 80 0b 	movzwl -0x3ff48000(%eax,%eax,1),%edx
c0100297:	c0 
c0100298:	66 89 94 00 60 7f 0b 	mov    %dx,-0x3ff480a0(%eax,%eax,1)
c010029f:	c0 


static void
wrap_screen() {
	int i;
	for (i = CRT_COLUMN; i < CRT_ROW * CRT_COLUMN; i ++)
c01002a0:	83 c0 01             	add    $0x1,%eax
c01002a3:	3d d0 07 00 00       	cmp    $0x7d0,%eax
c01002a8:	75 e6                	jne    c0100290 <color_console_printc+0x70>
c01002aa:	66 b8 50 00          	mov    $0x50,%ax
c01002ae:	66 90                	xchg   %ax,%ax
		vmem[i - CRT_COLUMN] = vmem[i];
	for (i = 0; i < CRT_COLUMN; i ++)
		vmem[CRT_ROW * CRT_COLUMN - i - 1] = (BLACK << 12) | (WHITE << 8) | ' ';
c01002b0:	66 c7 84 00 fe 8e 0b 	movw   $0x720,-0x3ff47102(%eax,%eax,1)
c01002b7:	c0 20 07 
static void
wrap_screen() {
	int i;
	for (i = CRT_COLUMN; i < CRT_ROW * CRT_COLUMN; i ++)
		vmem[i - CRT_COLUMN] = vmem[i];
	for (i = 0; i < CRT_COLUMN; i ++)
c01002ba:	83 e8 01             	sub    $0x1,%eax
c01002bd:	75 f1                	jne    c01002b0 <color_console_printc+0x90>
c01002bf:	be 80 ff ff ff       	mov    $0xffffff80,%esi
c01002c4:	bf 80 07 00 00       	mov    $0x780,%edi
c01002c9:	bb d4 03 00 00       	mov    $0x3d4,%ebx
c01002ce:	b8 0e 00 00 00       	mov    $0xe,%eax
c01002d3:	89 da                	mov    %ebx,%edx
c01002d5:	ee                   	out    %al,(%dx)
   so the hardware separates the 16-bit cursor position
   into two registers. */
static void
move_cursor(int x, int y) {
	out_byte(CRT_PORT_SEL, 0x0E);
	out_byte(CRT_PORT_DAT, ((x * 80 + y) >> 8) & 0xFF );
c01002d6:	8d 04 39             	lea    (%ecx,%edi,1),%eax
c01002d9:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c01002de:	c1 f8 08             	sar    $0x8,%eax
c01002e1:	89 ca                	mov    %ecx,%edx
c01002e3:	ee                   	out    %al,(%dx)
c01002e4:	b8 0f 00 00 00       	mov    $0xf,%eax
c01002e9:	89 da                	mov    %ebx,%edx
c01002eb:	ee                   	out    %al,(%dx)
	out_byte(CRT_PORT_SEL, 0x0F);
	out_byte(CRT_PORT_DAT, ((x * 80 + y)     ) & 0xFF );
c01002ec:	8d 04 2e             	lea    (%esi,%ebp,1),%eax
c01002ef:	89 ca                	mov    %ecx,%edx
c01002f1:	ee                   	out    %al,(%dx)
	if (x >= CRT_ROW) { /* bottom touched! */
		x = CRT_ROW - 1;
		wrap_screen();
	}
	move_cursor(x, y);
}
c01002f2:	5b                   	pop    %ebx
c01002f3:	5e                   	pop    %esi
c01002f4:	5f                   	pop    %edi
c01002f5:	5d                   	pop    %ebp
c01002f6:	c3                   	ret    
		break;
	default: /* print the character otherwise */
		vmem[x * CRT_COLUMN + y] = (backcolor << 12) | (forecolor << 8) | ch;
		y ++;
		if (y >= CRT_COLUMN) {
			x ++;
c01002f7:	83 c6 01             	add    $0x1,%esi
			y = 0;
c01002fa:	31 ed                	xor    %ebp,%ebp
c01002fc:	31 c9                	xor    %ecx,%ecx
		}
	}
	if (x >= CRT_ROW) { /* bottom touched! */
c01002fe:	83 fe 18             	cmp    $0x18,%esi
		break;
	default: /* print the character otherwise */
		vmem[x * CRT_COLUMN + y] = (backcolor << 12) | (forecolor << 8) | ch;
		y ++;
		if (y >= CRT_COLUMN) {
			x ++;
c0100301:	89 35 00 50 10 c0    	mov    %esi,0xc0105000
			y = 0;
c0100307:	c7 05 04 50 10 c0 00 	movl   $0x0,0xc0105004
c010030e:	00 00 00 
		}
	}
	if (x >= CRT_ROW) { /* bottom touched! */
c0100311:	0f 8f 67 ff ff ff    	jg     c010027e <color_console_printc+0x5e>
c0100317:	8d 3c b6             	lea    (%esi,%esi,4),%edi
c010031a:	8d 34 b6             	lea    (%esi,%esi,4),%esi
c010031d:	c1 e7 04             	shl    $0x4,%edi
c0100320:	c1 e6 04             	shl    $0x4,%esi
c0100323:	eb a4                	jmp    c01002c9 <color_console_printc+0xa9>
c0100325:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0100329:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0100330 <red_console_printc>:
}



void
red_console_printc(char ch) {
c0100330:	83 ec 0c             	sub    $0xc,%esp
	color_console_printc(RED, BLACK, ch);
c0100333:	0f be 44 24 10       	movsbl 0x10(%esp),%eax
c0100338:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010033f:	00 
c0100340:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c0100347:	89 44 24 08          	mov    %eax,0x8(%esp)
c010034b:	e8 d0 fe ff ff       	call   c0100220 <color_console_printc>
}
c0100350:	83 c4 0c             	add    $0xc,%esp
c0100353:	c3                   	ret    
c0100354:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c010035a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

c0100360 <console_printc>:
	}
	move_cursor(x, y);
}

void
console_printc(char ch) {
c0100360:	83 ec 0c             	sub    $0xc,%esp
	color_console_printc(WHITE, BLACK, ch);
c0100363:	0f be 44 24 10       	movsbl 0x10(%esp),%eax
c0100368:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010036f:	00 
c0100370:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
c0100377:	89 44 24 08          	mov    %eax,0x8(%esp)
c010037b:	e8 a0 fe ff ff       	call   c0100220 <color_console_printc>
}
c0100380:	83 c4 0c             	add    $0xc,%esp
c0100383:	c3                   	ret    
c0100384:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c010038a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

c0100390 <printk>:
	color_console_printc(RED, BLACK, ch);
}


void
printk(const char *ctl, ...) {
c0100390:	83 ec 1c             	sub    $0x1c,%esp
	void **args = (void **)&ctl + 1;
	vfprintf(console_printc, ctl, args);
c0100393:	8d 44 24 24          	lea    0x24(%esp),%eax
c0100397:	89 44 24 08          	mov    %eax,0x8(%esp)
c010039b:	8b 44 24 20          	mov    0x20(%esp),%eax
c010039f:	c7 04 24 60 03 10 c0 	movl   $0xc0100360,(%esp)
c01003a6:	89 44 24 04          	mov    %eax,0x4(%esp)
c01003aa:	e8 71 00 00 00       	call   c0100420 <vfprintf>
}
c01003af:	83 c4 1c             	add    $0x1c,%esp
c01003b2:	c3                   	ret    
c01003b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c01003b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c01003c0 <panic>:

void
panic(const char *ctl, ...) {
c01003c0:	83 ec 1c             	sub    $0x1c,%esp
	void *args = (void **)&ctl + 1;
	vfprintf(console_printc, ctl, args);
c01003c3:	8d 44 24 24          	lea    0x24(%esp),%eax
c01003c7:	89 44 24 08          	mov    %eax,0x8(%esp)
c01003cb:	8b 44 24 20          	mov    0x20(%esp),%eax
c01003cf:	c7 04 24 60 03 10 c0 	movl   $0xc0100360,(%esp)
c01003d6:	89 44 24 04          	mov    %eax,0x4(%esp)
c01003da:	e8 41 00 00 00       	call   c0100420 <vfprintf>
	asm volatile("sti");
}

static inline void
disable_interrupt(void) {
	asm volatile("cli");
c01003df:	fa                   	cli    
};

/* put the CPU into idle, waiting for next interrupt */
static inline void
idle_cpu() {
	asm volatile("hlt");
c01003e0:	f4                   	hlt    
c01003e1:	eb fd                	jmp    c01003e0 <panic+0x20>
c01003e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c01003e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c01003f0 <color_panic>:
		idle_cpu();
	}
}

void
color_panic(const char *ctl, ...) {
c01003f0:	83 ec 1c             	sub    $0x1c,%esp
	void *args = (void **)&ctl + 1;
	vfprintf(red_console_printc, ctl, args);
c01003f3:	8d 44 24 24          	lea    0x24(%esp),%eax
c01003f7:	89 44 24 08          	mov    %eax,0x8(%esp)
c01003fb:	8b 44 24 20          	mov    0x20(%esp),%eax
c01003ff:	c7 04 24 30 03 10 c0 	movl   $0xc0100330,(%esp)
c0100406:	89 44 24 04          	mov    %eax,0x4(%esp)
c010040a:	e8 11 00 00 00       	call   c0100420 <vfprintf>
	asm volatile("sti");
}

static inline void
disable_interrupt(void) {
	asm volatile("cli");
c010040f:	fa                   	cli    
};

/* put the CPU into idle, waiting for next interrupt */
static inline void
idle_cpu() {
	asm volatile("hlt");
c0100410:	f4                   	hlt    
c0100411:	eb fd                	jmp    c0100410 <color_panic+0x20>
c0100413:	90                   	nop
c0100414:	90                   	nop
c0100415:	90                   	nop
c0100416:	90                   	nop
c0100417:	90                   	nop
c0100418:	90                   	nop
c0100419:	90                   	nop
c010041a:	90                   	nop
c010041b:	90                   	nop
c010041c:	90                   	nop
c010041d:	90                   	nop
c010041e:	90                   	nop
c010041f:	90                   	nop

c0100420 <vfprintf>:
#include "kernel.h"

#define MAX_LEN 10

void
vfprintf(void (*printer)(char), const char *ctl, void **args) {
c0100420:	55                   	push   %ebp
c0100421:	57                   	push   %edi
c0100422:	56                   	push   %esi
c0100423:	53                   	push   %ebx
c0100424:	83 ec 4c             	sub    $0x4c,%esp
c0100427:	8b 5c 24 64          	mov    0x64(%esp),%ebx
	int_32 dec;
	uint_32 hex;
	char *ch;
	int i;
	
	for (; *ctl != 0; ++ ctl)
c010042b:	0f b6 03             	movzbl (%ebx),%eax
c010042e:	84 c0                	test   %al,%al
c0100430:	75 1d                	jne    c010044f <vfprintf+0x2f>
c0100432:	eb 64                	jmp    c0100498 <vfprintf+0x78>
c0100434:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		if (*ctl != '%') printer(*ctl);
c0100438:	0f be c0             	movsbl %al,%eax
c010043b:	89 de                	mov    %ebx,%esi
c010043d:	89 04 24             	mov    %eax,(%esp)
c0100440:	ff 54 24 60          	call   *0x60(%esp)
	int_32 dec;
	uint_32 hex;
	char *ch;
	int i;
	
	for (; *ctl != 0; ++ ctl)
c0100444:	0f b6 46 01          	movzbl 0x1(%esi),%eax
c0100448:	8d 5e 01             	lea    0x1(%esi),%ebx
c010044b:	84 c0                	test   %al,%al
c010044d:	74 49                	je     c0100498 <vfprintf+0x78>
	{
		if (*ctl != '%') printer(*ctl);
c010044f:	3c 25                	cmp    $0x25,%al
c0100451:	75 e5                	jne    c0100438 <vfprintf+0x18>
		else
			switch (*(++ ctl))
c0100453:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0100457:	8d 73 01             	lea    0x1(%ebx),%esi
c010045a:	3c 64                	cmp    $0x64,%al
c010045c:	0f 84 be 00 00 00    	je     c0100520 <vfprintf+0x100>
c0100462:	7f 3c                	jg     c01004a0 <vfprintf+0x80>
c0100464:	3c 25                	cmp    $0x25,%al
c0100466:	0f 84 6c 01 00 00    	je     c01005d8 <vfprintf+0x1b8>
c010046c:	3c 63                	cmp    $0x63,%al
c010046e:	66 90                	xchg   %ax,%ax
c0100470:	75 d2                	jne    c0100444 <vfprintf+0x24>
						break;

				case '%':	printer('%');
						break;

				case 'c':	printer(*((char *)args ++));
c0100472:	8b 54 24 68          	mov    0x68(%esp),%edx
	int_32 dec;
	uint_32 hex;
	char *ch;
	int i;
	
	for (; *ctl != 0; ++ ctl)
c0100476:	8d 5e 01             	lea    0x1(%esi),%ebx
						break;

				case '%':	printer('%');
						break;

				case 'c':	printer(*((char *)args ++));
c0100479:	0f be 02             	movsbl (%edx),%eax
c010047c:	83 c2 04             	add    $0x4,%edx
c010047f:	89 54 24 68          	mov    %edx,0x68(%esp)
c0100483:	89 04 24             	mov    %eax,(%esp)
c0100486:	ff 54 24 60          	call   *0x60(%esp)
	int_32 dec;
	uint_32 hex;
	char *ch;
	int i;
	
	for (; *ctl != 0; ++ ctl)
c010048a:	0f b6 46 01          	movzbl 0x1(%esi),%eax
c010048e:	84 c0                	test   %al,%al
c0100490:	75 bd                	jne    c010044f <vfprintf+0x2f>
c0100492:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

			}
	}


}
c0100498:	83 c4 4c             	add    $0x4c,%esp
c010049b:	5b                   	pop    %ebx
c010049c:	5e                   	pop    %esi
c010049d:	5f                   	pop    %edi
c010049e:	5d                   	pop    %ebp
c010049f:	c3                   	ret    
	
	for (; *ctl != 0; ++ ctl)
	{
		if (*ctl != '%') printer(*ctl);
		else
			switch (*(++ ctl))
c01004a0:	3c 73                	cmp    $0x73,%al
c01004a2:	0f 84 f8 00 00 00    	je     c01005a0 <vfprintf+0x180>
c01004a8:	3c 78                	cmp    $0x78,%al
c01004aa:	75 98                	jne    c0100444 <vfprintf+0x24>
							for (-- i; i >= 0; -- i)
								printer(temp[i] + 48);
						}
						break;

				case 'x':	hex = *((uint_32 *)args ++);
c01004ac:	8b 44 24 68          	mov    0x68(%esp),%eax
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
c01004b0:	31 db                	xor    %ebx,%ebx
c01004b2:	8d 7c 24 18          	lea    0x18(%esp),%edi
							for (-- i; i >= 0; -- i)
								printer(temp[i] + 48);
						}
						break;

				case 'x':	hex = *((uint_32 *)args ++);
c01004b6:	8b 10                	mov    (%eax),%edx
c01004b8:	83 c0 04             	add    $0x4,%eax
c01004bb:	89 44 24 68          	mov    %eax,0x68(%esp)
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
c01004bf:	85 d2                	test   %edx,%edx
c01004c1:	75 07                	jne    c01004ca <vfprintf+0xaa>
c01004c3:	e9 7c ff ff ff       	jmp    c0100444 <vfprintf+0x24>
c01004c8:	89 cb                	mov    %ecx,%ebx
							temp[i] = hex & 0xF;
c01004ca:	89 d0                	mov    %edx,%eax
								printer(temp[i] + 48);
						}
						break;

				case 'x':	hex = *((uint_32 *)args ++);
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
c01004cc:	c1 ea 04             	shr    $0x4,%edx
							temp[i] = hex & 0xF;
c01004cf:	83 e0 0f             	and    $0xf,%eax
								printer(temp[i] + 48);
						}
						break;

				case 'x':	hex = *((uint_32 *)args ++);
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
c01004d2:	85 d2                	test   %edx,%edx
							temp[i] = hex & 0xF;
c01004d4:	89 04 9f             	mov    %eax,(%edi,%ebx,4)
								printer(temp[i] + 48);
						}
						break;

				case 'x':	hex = *((uint_32 *)args ++);
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
c01004d7:	8d 4b 01             	lea    0x1(%ebx),%ecx
c01004da:	75 ec                	jne    c01004c8 <vfprintf+0xa8>
c01004dc:	8b 6c 24 60          	mov    0x60(%esp),%ebp
c01004e0:	eb 1c                	jmp    c01004fe <vfprintf+0xde>
c01004e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
							temp[i] = hex & 0xF;
						for (-- i; i >= 0; -- i)
							if (temp[i] < 10)
								printer(temp[i] + 48);
c01004e8:	83 c0 30             	add    $0x30,%eax
						break;

				case 'x':	hex = *((uint_32 *)args ++);
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
							temp[i] = hex & 0xF;
						for (-- i; i >= 0; -- i)
c01004eb:	83 eb 01             	sub    $0x1,%ebx
							if (temp[i] < 10)
								printer(temp[i] + 48);
c01004ee:	0f be c0             	movsbl %al,%eax
c01004f1:	89 04 24             	mov    %eax,(%esp)
c01004f4:	ff d5                	call   *%ebp
						break;

				case 'x':	hex = *((uint_32 *)args ++);
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
							temp[i] = hex & 0xF;
						for (-- i; i >= 0; -- i)
c01004f6:	83 fb ff             	cmp    $0xffffffff,%ebx
c01004f9:	74 1b                	je     c0100516 <vfprintf+0xf6>
c01004fb:	8b 04 9f             	mov    (%edi,%ebx,4),%eax
							if (temp[i] < 10)
c01004fe:	83 f8 09             	cmp    $0x9,%eax
c0100501:	76 e5                	jbe    c01004e8 <vfprintf+0xc8>
								printer(temp[i] + 48);
							else
								printer(temp[i] - 10 + 65);
c0100503:	83 c0 37             	add    $0x37,%eax
						break;

				case 'x':	hex = *((uint_32 *)args ++);
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
							temp[i] = hex & 0xF;
						for (-- i; i >= 0; -- i)
c0100506:	83 eb 01             	sub    $0x1,%ebx
							if (temp[i] < 10)
								printer(temp[i] + 48);
							else
								printer(temp[i] - 10 + 65);
c0100509:	0f be c0             	movsbl %al,%eax
c010050c:	89 04 24             	mov    %eax,(%esp)
c010050f:	ff d5                	call   *%ebp
						break;

				case 'x':	hex = *((uint_32 *)args ++);
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
							temp[i] = hex & 0xF;
						for (-- i; i >= 0; -- i)
c0100511:	83 fb ff             	cmp    $0xffffffff,%ebx
c0100514:	75 e5                	jne    c01004fb <vfprintf+0xdb>
c0100516:	89 6c 24 60          	mov    %ebp,0x60(%esp)
c010051a:	e9 25 ff ff ff       	jmp    c0100444 <vfprintf+0x24>
c010051f:	90                   	nop
	{
		if (*ctl != '%') printer(*ctl);
		else
			switch (*(++ ctl))
			{
				case 'd':	dec = *((int_32 *)args ++);
c0100520:	8b 44 24 68          	mov    0x68(%esp),%eax
c0100524:	8b 28                	mov    (%eax),%ebp
c0100526:	83 c0 04             	add    $0x4,%eax
c0100529:	89 44 24 68          	mov    %eax,0x68(%esp)
						if (dec == 0) printer('0');
c010052d:	83 fd 00             	cmp    $0x0,%ebp
c0100530:	0f 84 b2 00 00 00    	je     c01005e8 <vfprintf+0x1c8>
						else
						{
							if (dec < 0)
c0100536:	0f 8c bc 00 00 00    	jl     c01005f8 <vfprintf+0x1d8>
							{
								printer('-');
								dec = -dec;
							}
							for (i = 0; dec != 0; dec /= 10, ++ i)
c010053c:	31 db                	xor    %ebx,%ebx
c010053e:	8d 7c 24 18          	lea    0x18(%esp),%edi
c0100542:	eb 06                	jmp    c010054a <vfprintf+0x12a>
c0100544:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0100548:	89 c3                	mov    %eax,%ebx
								temp[i] = dec % 10;	
c010054a:	b8 67 66 66 66       	mov    $0x66666667,%eax
c010054f:	f7 ed                	imul   %ebp
c0100551:	89 e8                	mov    %ebp,%eax
c0100553:	c1 f8 1f             	sar    $0x1f,%eax
c0100556:	c1 fa 02             	sar    $0x2,%edx
c0100559:	29 c2                	sub    %eax,%edx
c010055b:	89 d0                	mov    %edx,%eax
c010055d:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0100560:	01 d2                	add    %edx,%edx
c0100562:	29 d5                	sub    %edx,%ebp
c0100564:	89 ea                	mov    %ebp,%edx
c0100566:	89 2c 9f             	mov    %ebp,(%edi,%ebx,4)
							if (dec < 0)
							{
								printer('-');
								dec = -dec;
							}
							for (i = 0; dec != 0; dec /= 10, ++ i)
c0100569:	89 c5                	mov    %eax,%ebp
c010056b:	85 ed                	test   %ebp,%ebp
c010056d:	8d 43 01             	lea    0x1(%ebx),%eax
c0100570:	75 d6                	jne    c0100548 <vfprintf+0x128>
c0100572:	89 d0                	mov    %edx,%eax
c0100574:	8b 6c 24 60          	mov    0x60(%esp),%ebp
c0100578:	eb 09                	jmp    c0100583 <vfprintf+0x163>
c010057a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
								temp[i] = dec % 10;	
							for (-- i; i >= 0; -- i)
c0100580:	8b 04 9f             	mov    (%edi,%ebx,4),%eax
								printer(temp[i] + 48);
c0100583:	83 c0 30             	add    $0x30,%eax
								printer('-');
								dec = -dec;
							}
							for (i = 0; dec != 0; dec /= 10, ++ i)
								temp[i] = dec % 10;	
							for (-- i; i >= 0; -- i)
c0100586:	83 eb 01             	sub    $0x1,%ebx
								printer(temp[i] + 48);
c0100589:	0f be c0             	movsbl %al,%eax
c010058c:	89 04 24             	mov    %eax,(%esp)
c010058f:	ff d5                	call   *%ebp
								printer('-');
								dec = -dec;
							}
							for (i = 0; dec != 0; dec /= 10, ++ i)
								temp[i] = dec % 10;	
							for (-- i; i >= 0; -- i)
c0100591:	83 fb ff             	cmp    $0xffffffff,%ebx
c0100594:	75 ea                	jne    c0100580 <vfprintf+0x160>
c0100596:	89 6c 24 60          	mov    %ebp,0x60(%esp)
c010059a:	e9 a5 fe ff ff       	jmp    c0100444 <vfprintf+0x24>
c010059f:	90                   	nop
						break;

				case 'c':	printer(*((char *)args ++));
						break;

				case 's':	for (ch = (char *)(*(args ++)); *ch != 0; ++ ch)
c01005a0:	8b 44 24 68          	mov    0x68(%esp),%eax
c01005a4:	8b 18                	mov    (%eax),%ebx
c01005a6:	83 c0 04             	add    $0x4,%eax
c01005a9:	89 44 24 68          	mov    %eax,0x68(%esp)
c01005ad:	0f b6 03             	movzbl (%ebx),%eax
c01005b0:	84 c0                	test   %al,%al
c01005b2:	0f 84 8c fe ff ff    	je     c0100444 <vfprintf+0x24>
c01005b8:	8b 7c 24 60          	mov    0x60(%esp),%edi
c01005bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
							printer(*ch);
c01005c0:	0f be c0             	movsbl %al,%eax
						break;

				case 'c':	printer(*((char *)args ++));
						break;

				case 's':	for (ch = (char *)(*(args ++)); *ch != 0; ++ ch)
c01005c3:	83 c3 01             	add    $0x1,%ebx
							printer(*ch);
c01005c6:	89 04 24             	mov    %eax,(%esp)
c01005c9:	ff d7                	call   *%edi
						break;

				case 'c':	printer(*((char *)args ++));
						break;

				case 's':	for (ch = (char *)(*(args ++)); *ch != 0; ++ ch)
c01005cb:	0f b6 03             	movzbl (%ebx),%eax
c01005ce:	84 c0                	test   %al,%al
c01005d0:	75 ee                	jne    c01005c0 <vfprintf+0x1a0>
c01005d2:	e9 6d fe ff ff       	jmp    c0100444 <vfprintf+0x24>
c01005d7:	90                   	nop
								printer(temp[i] + 48);
							else
								printer(temp[i] - 10 + 65);
						break;

				case '%':	printer('%');
c01005d8:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
c01005df:	ff 54 24 60          	call   *0x60(%esp)
						break;
c01005e3:	e9 5c fe ff ff       	jmp    c0100444 <vfprintf+0x24>
		if (*ctl != '%') printer(*ctl);
		else
			switch (*(++ ctl))
			{
				case 'd':	dec = *((int_32 *)args ++);
						if (dec == 0) printer('0');
c01005e8:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
c01005ef:	ff 54 24 60          	call   *0x60(%esp)
c01005f3:	e9 4c fe ff ff       	jmp    c0100444 <vfprintf+0x24>
						else
						{
							if (dec < 0)
							{
								printer('-');
c01005f8:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
								dec = -dec;
c01005ff:	f7 dd                	neg    %ebp
						if (dec == 0) printer('0');
						else
						{
							if (dec < 0)
							{
								printer('-');
c0100601:	ff 54 24 60          	call   *0x60(%esp)
c0100605:	e9 32 ff ff ff       	jmp    c010053c <vfprintf+0x11c>
c010060a:	90                   	nop
c010060b:	90                   	nop
c010060c:	90                   	nop
c010060d:	90                   	nop
c010060e:	90                   	nop
c010060f:	90                   	nop

c0100610 <init_page>:
struct PageDirectoryEntry kpagedir[NR_PDE_ENTRY] align_to_page;
struct PageTableEntry kpagetable[USER_MEM_HIGH / PAGE_SIZE] align_to_page;

/* Build a page table for the kernel */
void
init_page(void) {
c0100610:	55                   	push   %ebp
c0100611:	57                   	push   %edi
c0100612:	56                   	push   %esi
c0100613:	be 00 70 13 00       	mov    $0x137000,%esi
c0100618:	53                   	push   %ebx
	struct CR0 cr0;
	struct CR3 cr3;
	uint_32 i, j;

	pdir = (struct PageDirectoryEntry *)va_to_pa(kpagedir);
	pent = (struct PageTableEntry *)va_to_pa(kpagetable);
c0100619:	bb 00 70 11 00       	mov    $0x117000,%ebx
struct PageDirectoryEntry kpagedir[NR_PDE_ENTRY] align_to_page;
struct PageTableEntry kpagetable[USER_MEM_HIGH / PAGE_SIZE] align_to_page;

/* Build a page table for the kernel */
void
init_page(void) {
c010061e:	83 ec 2c             	sub    $0x2c,%esp
c0100621:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	pdir = (struct PageDirectoryEntry *)va_to_pa(kpagedir);
	pent = (struct PageTableEntry *)va_to_pa(kpagetable);

	for (i = 0; i < NR_PDE_ENTRY; i ++) {
		make_invalid_pde(&pdir[i]);
c0100628:	89 34 24             	mov    %esi,(%esp)
c010062b:	83 c6 04             	add    $0x4,%esi
c010062e:	e8 2d 01 00 00       	call   c0100760 <make_invalid_pde>
	uint_32 i, j;

	pdir = (struct PageDirectoryEntry *)va_to_pa(kpagedir);
	pent = (struct PageTableEntry *)va_to_pa(kpagetable);

	for (i = 0; i < NR_PDE_ENTRY; i ++) {
c0100633:	81 fe 00 80 13 00    	cmp    $0x138000,%esi
c0100639:	75 ed                	jne    c0100628 <init_page+0x18>
struct PageDirectoryEntry kpagedir[NR_PDE_ENTRY] align_to_page;
struct PageTableEntry kpagetable[USER_MEM_HIGH / PAGE_SIZE] align_to_page;

/* Build a page table for the kernel */
void
init_page(void) {
c010063b:	bd 00 70 13 00       	mov    $0x137000,%ebp
c0100640:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c0100647:	00 
	for (i = 0; i < NR_PDE_ENTRY; i ++) {
		make_invalid_pde(&pdir[i]);
	}

	for (i = 0; i < USER_MEM_HIGH / PD_SIZE; i ++) {
		make_pde(&pdir[i], pent);
c0100648:	89 5c 24 04          	mov    %ebx,0x4(%esp)
struct PageDirectoryEntry kpagedir[NR_PDE_ENTRY] align_to_page;
struct PageTableEntry kpagetable[USER_MEM_HIGH / PAGE_SIZE] align_to_page;

/* Build a page table for the kernel */
void
init_page(void) {
c010064c:	8d bb 00 10 00 00    	lea    0x1000(%ebx),%edi
	for (i = 0; i < NR_PDE_ENTRY; i ++) {
		make_invalid_pde(&pdir[i]);
	}

	for (i = 0; i < USER_MEM_HIGH / PD_SIZE; i ++) {
		make_pde(&pdir[i], pent);
c0100652:	89 2c 24             	mov    %ebp,(%esp)
c0100655:	e8 26 01 00 00       	call   c0100780 <make_pde>
struct PageDirectoryEntry kpagedir[NR_PDE_ENTRY] align_to_page;
struct PageTableEntry kpagetable[USER_MEM_HIGH / PAGE_SIZE] align_to_page;

/* Build a page table for the kernel */
void
init_page(void) {
c010065a:	8d 85 00 0c 00 00    	lea    0xc00(%ebp),%eax
		make_invalid_pde(&pdir[i]);
	}

	for (i = 0; i < USER_MEM_HIGH / PD_SIZE; i ++) {
		make_pde(&pdir[i], pent);
		make_pde(&pdir[i + KOFFSET / PD_SIZE], pent);
c0100660:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0100664:	89 04 24             	mov    %eax,(%esp)
c0100667:	e8 14 01 00 00       	call   c0100780 <make_pde>
struct PageDirectoryEntry kpagedir[NR_PDE_ENTRY] align_to_page;
struct PageTableEntry kpagetable[USER_MEM_HIGH / PAGE_SIZE] align_to_page;

/* Build a page table for the kernel */
void
init_page(void) {
c010066c:	8b 74 24 1c          	mov    0x1c(%esp),%esi

	for (i = 0; i < USER_MEM_HIGH / PD_SIZE; i ++) {
		make_pde(&pdir[i], pent);
		make_pde(&pdir[i + KOFFSET / PD_SIZE], pent);
		for (j = 0; j < NR_PTE_ENTRY; j ++) {
			make_pte(pent, (void*)((i * NR_PTE_ENTRY + j) << 12));
c0100670:	89 f0                	mov    %esi,%eax
			pent ++;
c0100672:	83 c6 01             	add    $0x1,%esi

	for (i = 0; i < USER_MEM_HIGH / PD_SIZE; i ++) {
		make_pde(&pdir[i], pent);
		make_pde(&pdir[i + KOFFSET / PD_SIZE], pent);
		for (j = 0; j < NR_PTE_ENTRY; j ++) {
			make_pte(pent, (void*)((i * NR_PTE_ENTRY + j) << 12));
c0100675:	c1 e0 0c             	shl    $0xc,%eax
c0100678:	89 1c 24             	mov    %ebx,(%esp)
			pent ++;
c010067b:	83 c3 04             	add    $0x4,%ebx

	for (i = 0; i < USER_MEM_HIGH / PD_SIZE; i ++) {
		make_pde(&pdir[i], pent);
		make_pde(&pdir[i + KOFFSET / PD_SIZE], pent);
		for (j = 0; j < NR_PTE_ENTRY; j ++) {
			make_pte(pent, (void*)((i * NR_PTE_ENTRY + j) << 12));
c010067e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0100682:	e8 19 01 00 00       	call   c01007a0 <make_pte>
	}

	for (i = 0; i < USER_MEM_HIGH / PD_SIZE; i ++) {
		make_pde(&pdir[i], pent);
		make_pde(&pdir[i + KOFFSET / PD_SIZE], pent);
		for (j = 0; j < NR_PTE_ENTRY; j ++) {
c0100687:	39 fb                	cmp    %edi,%ebx
c0100689:	75 e5                	jne    c0100670 <init_page+0x60>
c010068b:	83 c5 04             	add    $0x4,%ebp
c010068e:	81 44 24 1c 00 04 00 	addl   $0x400,0x1c(%esp)
c0100695:	00 

	for (i = 0; i < NR_PDE_ENTRY; i ++) {
		make_invalid_pde(&pdir[i]);
	}

	for (i = 0; i < USER_MEM_HIGH / PD_SIZE; i ++) {
c0100696:	81 fb 00 70 13 00    	cmp    $0x137000,%ebx
c010069c:	75 aa                	jne    c0100648 <init_page+0x38>
		}
	}

	/* make CR3 to be the entry of page directory */
	*(uint_32*)&cr3 = 0;
	cr3.page_directory_base = ((uint_32)pdir) >> 12;
c010069e:	b8 00 70 13 00       	mov    $0x137000,%eax
c01006a3:	25 00 f0 ff ff       	and    $0xfffff000,%eax

/* write CR3, notice that CR3 are never read in Nanos */
static inline void
save_cr3(struct CR3 *ptr) {
	uint_32 val = *((uint_32*)ptr);
	asm volatile("movl %0, %%cr3" : : "r"(val));
c01006a8:	0f 22 d8             	mov    %eax,%cr3

/* read CR0 */
static inline void
load_cr0(struct CR0 *ptr) {
	uint_32 val;
	asm volatile("movl %%cr0, %0" : "=r"(val));
c01006ab:	0f 20 c0             	mov    %cr0,%eax
	save_cr3(&cr3);

	/* set PG bit in CR0 */
	load_cr0(&cr0);
	cr0.paging = 1;
c01006ae:	0d 00 00 00 80       	or     $0x80000000,%eax

/* write CR0 */
static inline void
save_cr0(struct CR0 *ptr) {
	uint_32 val = *((uint_32*)ptr);
	asm volatile("movl %0, %%cr0" : : "r"(val));
c01006b3:	0f 22 c0             	mov    %eax,%cr0
	save_cr0(&cr0);
}
c01006b6:	83 c4 2c             	add    $0x2c,%esp
c01006b9:	5b                   	pop    %ebx
c01006ba:	5e                   	pop    %esi
c01006bb:	5f                   	pop    %edi
c01006bc:	5d                   	pop    %ebp
c01006bd:	c3                   	ret    
c01006be:	66 90                	xchg   %ax,%ax

c01006c0 <init_segment>:
   previous one cannot be accessed in user process, because its virtual
   address below 0xC0000000, and is mapped into process' private space. */
void
init_segment(void) {
	int i;
	for (i = 0; i < sizeof(gdt); i ++) {
c01006c0:	31 d2                	xor    %edx,%edx
c01006c2:	31 c0                	xor    %eax,%eax
c01006c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c01006c8:	83 c0 01             	add    $0x1,%eax
		((uint_8*)gdt)[i] = 0;
c01006cb:	b9 10 50 10 c0       	mov    $0xc0105010,%ecx
   previous one cannot be accessed in user process, because its virtual
   address below 0xC0000000, and is mapped into process' private space. */
void
init_segment(void) {
	int i;
	for (i = 0; i < sizeof(gdt); i ++) {
c01006d0:	83 f8 18             	cmp    $0x18,%eax
		((uint_8*)gdt)[i] = 0;
c01006d3:	c6 82 10 50 10 c0 00 	movb   $0x0,-0x3fefaff0(%edx)
   previous one cannot be accessed in user process, because its virtual
   address below 0xC0000000, and is mapped into process' private space. */
void
init_segment(void) {
	int i;
	for (i = 0; i < sizeof(gdt); i ++) {
c01006da:	89 c2                	mov    %eax,%edx
c01006dc:	75 ea                	jne    c01006c8 <init_segment+0x8>

/* modify the value of GDTR */
static inline void
save_gdt(void *addr, uint_32 size) {
	static volatile uint_16 data[3];
	data[0] = size - 1;
c01006de:	66 c7 05 08 50 10 c0 	movw   $0x17,0xc0105008
c01006e5:	17 00 
	data[1] = (uint_32)addr;
	data[2] = ((uint_32)addr) >> 16;
	asm volatile("lgdt (%0)" : : "r"(data));
c01006e7:	b8 08 50 10 c0       	mov    $0xc0105008,%eax
/* modify the value of GDTR */
static inline void
save_gdt(void *addr, uint_32 size) {
	static volatile uint_16 data[3];
	data[0] = size - 1;
	data[1] = (uint_32)addr;
c01006ec:	66 89 0d 0a 50 10 c0 	mov    %cx,0xc010500a
	data[2] = ((uint_32)addr) >> 16;
c01006f3:	c1 e9 10             	shr    $0x10,%ecx
c01006f6:	66 89 0d 0c 50 10 c0 	mov    %cx,0xc010500c
   0xC0000000. */
static struct SegmentDescriptor gdt[NR_SEGMENTS];

static void
set_segment(struct SegmentDescriptor *ptr, uint_32 type) {
	ptr->limit_15_0  = 0xFFFF;
c01006fd:	66 c7 05 18 50 10 c0 	movw   $0xffff,0xc0105018
c0100704:	ff ff 
	ptr->base_15_0   = 0x0;
c0100706:	66 c7 05 1a 50 10 c0 	movw   $0x0,0xc010501a
c010070d:	00 00 
	ptr->base_23_16  = 0x0;
c010070f:	c6 05 1c 50 10 c0 00 	movb   $0x0,0xc010501c
	ptr->type = type;
	ptr->segment_type = 1;
	ptr->privilege_level = DPL_KERNEL;
	ptr->present = 1;
c0100716:	c6 05 1d 50 10 c0 9a 	movb   $0x9a,0xc010501d
	ptr->limit_19_16 = 0xF;
	ptr->soft_use = 0;
	ptr->operation_size = 0;
	ptr->pad0 = 1;
	ptr->granularity = 1;
c010071d:	c6 05 1e 50 10 c0 cf 	movb   $0xcf,0xc010501e
	ptr->base_31_24  = 0x0;
c0100724:	c6 05 1f 50 10 c0 00 	movb   $0x0,0xc010501f
   0xC0000000. */
static struct SegmentDescriptor gdt[NR_SEGMENTS];

static void
set_segment(struct SegmentDescriptor *ptr, uint_32 type) {
	ptr->limit_15_0  = 0xFFFF;
c010072b:	66 c7 05 20 50 10 c0 	movw   $0xffff,0xc0105020
c0100732:	ff ff 
	ptr->base_15_0   = 0x0;
c0100734:	66 c7 05 22 50 10 c0 	movw   $0x0,0xc0105022
c010073b:	00 00 
	ptr->base_23_16  = 0x0;
c010073d:	c6 05 24 50 10 c0 00 	movb   $0x0,0xc0105024
	ptr->type = type;
	ptr->segment_type = 1;
	ptr->privilege_level = DPL_KERNEL;
	ptr->present = 1;
c0100744:	c6 05 25 50 10 c0 92 	movb   $0x92,0xc0105025
	ptr->limit_19_16 = 0xF;
	ptr->soft_use = 0;
	ptr->operation_size = 0;
	ptr->pad0 = 1;
	ptr->granularity = 1;
c010074b:	c6 05 26 50 10 c0 cf 	movb   $0xcf,0xc0105026
	ptr->base_31_24  = 0x0;
c0100752:	c6 05 27 50 10 c0 00 	movb   $0x0,0xc0105027
	asm volatile("lgdt (%0)" : : "r"(data));
c0100759:	0f 01 10             	lgdtl  (%eax)
		((uint_8*)gdt)[i] = 0;
	}
	set_segment(&gdt[SEG_KERNEL_CODE], SEG_EXECUTABLE | SEG_READABLE);
	set_segment(&gdt[SEG_KERNEL_DATA], SEG_WRITABLE );
	save_gdt(gdt, sizeof(gdt));
}
c010075c:	c3                   	ret    
c010075d:	90                   	nop
c010075e:	90                   	nop
c010075f:	90                   	nop

c0100760 <make_invalid_pde>:
#include "kernel.h"

void
make_invalid_pde(struct PageDirectoryEntry *p) {
	*(uint_32*)p = 0;
c0100760:	8b 44 24 04          	mov    0x4(%esp),%eax
c0100764:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c010076a:	c3                   	ret    
c010076b:	90                   	nop
c010076c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c0100770 <make_invalid_pte>:
void
make_invalid_pte(struct PageTableEntry *p) {
	*(uint_32*)p = 0;
c0100770:	8b 44 24 04          	mov    0x4(%esp),%eax
c0100774:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c010077a:	c3                   	ret    
c010077b:	90                   	nop
c010077c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c0100780 <make_pde>:

void
make_pde(struct PageDirectoryEntry *p, void *addr) {
c0100780:	8b 44 24 08          	mov    0x8(%esp),%eax
c0100784:	8b 54 24 04          	mov    0x4(%esp),%edx
	*(uint_32*)p = 0;
	p->page_frame = ((uint_32)addr) >> 12;
c0100788:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c010078d:	89 02                	mov    %eax,(%edx)
	p->present = 1;
	p->read_write = 1;
	p->user_supervisor = 1;
c010078f:	c6 02 07             	movb   $0x7,(%edx)
}
c0100792:	c3                   	ret    
c0100793:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c0100799:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c01007a0 <make_pte>:

void
make_pte(struct PageTableEntry *p, void *addr) {
c01007a0:	8b 44 24 08          	mov    0x8(%esp),%eax
c01007a4:	8b 54 24 04          	mov    0x4(%esp),%edx
	*(uint_32*)p = 0;
	p->page_frame = ((uint_32)addr) >> 12;
c01007a8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c01007ad:	89 02                	mov    %eax,(%edx)
	p->present = 1;
	p->read_write = 1;
	p->user_supervisor = 1;
c01007af:	c6 02 07             	movb   $0x7,(%edx)
}
c01007b2:	c3                   	ret    
c01007b3:	90                   	nop
c01007b4:	90                   	nop
c01007b5:	90                   	nop
c01007b6:	90                   	nop
c01007b7:	90                   	nop
c01007b8:	90                   	nop
c01007b9:	90                   	nop
c01007ba:	90                   	nop
c01007bb:	90                   	nop
c01007bc:	90                   	nop
c01007bd:	90                   	nop
c01007be:	90                   	nop
c01007bf:	90                   	nop

c01007c0 <init_intr>:
c01007c0:	ba 21 00 00 00       	mov    $0x21,%edx
c01007c5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01007ca:	ee                   	out    %al,(%dx)
c01007cb:	b2 a1                	mov    $0xa1,%dl
c01007cd:	ee                   	out    %al,(%dx)
c01007ce:	b8 11 00 00 00       	mov    $0x11,%eax
c01007d3:	b2 20                	mov    $0x20,%dl
c01007d5:	ee                   	out    %al,(%dx)
c01007d6:	b8 20 00 00 00       	mov    $0x20,%eax
c01007db:	b2 21                	mov    $0x21,%dl
c01007dd:	ee                   	out    %al,(%dx)
c01007de:	b8 04 00 00 00       	mov    $0x4,%eax
c01007e3:	ee                   	out    %al,(%dx)
c01007e4:	b8 03 00 00 00       	mov    $0x3,%eax
c01007e9:	ee                   	out    %al,(%dx)
c01007ea:	b8 11 00 00 00       	mov    $0x11,%eax
c01007ef:	b2 a0                	mov    $0xa0,%dl
c01007f1:	ee                   	out    %al,(%dx)
c01007f2:	b8 28 00 00 00       	mov    $0x28,%eax
c01007f7:	b2 a1                	mov    $0xa1,%dl
c01007f9:	ee                   	out    %al,(%dx)
c01007fa:	b8 02 00 00 00       	mov    $0x2,%eax
c01007ff:	ee                   	out    %al,(%dx)
c0100800:	b8 03 00 00 00       	mov    $0x3,%eax
c0100805:	ee                   	out    %al,(%dx)
c0100806:	b8 68 00 00 00       	mov    $0x68,%eax
c010080b:	b2 20                	mov    $0x20,%dl
c010080d:	ee                   	out    %al,(%dx)
c010080e:	b8 0a 00 00 00       	mov    $0xa,%eax
c0100813:	ee                   	out    %al,(%dx)
c0100814:	b8 68 00 00 00       	mov    $0x68,%eax
c0100819:	b2 a0                	mov    $0xa0,%dl
c010081b:	ee                   	out    %al,(%dx)
c010081c:	b8 0a 00 00 00       	mov    $0xa,%eax
c0100821:	ee                   	out    %al,(%dx)

	out_byte(PORT_PIC_MASTER, 0x68);
	out_byte(PORT_PIC_MASTER, 0x0A);
	out_byte(PORT_PIC_SLAVE, 0x68);
	out_byte(PORT_PIC_SLAVE, 0x0A);
}
c0100822:	c3                   	ret    
c0100823:	90                   	nop
c0100824:	90                   	nop
c0100825:	90                   	nop
c0100826:	90                   	nop
c0100827:	90                   	nop
c0100828:	90                   	nop
c0100829:	90                   	nop
c010082a:	90                   	nop
c010082b:	90                   	nop
c010082c:	90                   	nop
c010082d:	90                   	nop
c010082e:	90                   	nop
c010082f:	90                   	nop

c0100830 <set_intr>:
/* the global IDT list
   in Nanos, each entry of the IDT is either an interrupt gate, or a trap gate */
struct GateDescriptor idt[NR_IRQ];

/* setup a interrupt gate for interrupt handlers */
void set_intr(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
c0100830:	8b 44 24 04          	mov    0x4(%esp),%eax
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100834:	8b 54 24 08          	mov    0x8(%esp),%edx
/* the global IDT list
   in Nanos, each entry of the IDT is either an interrupt gate, or a trap gate */
struct GateDescriptor idt[NR_IRQ];

/* setup a interrupt gate for interrupt handlers */
void set_intr(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
c0100838:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
	ptr->pad0 = 0;
c010083c:	c6 40 04 00          	movb   $0x0,0x4(%eax)
struct GateDescriptor idt[NR_IRQ];

/* setup a interrupt gate for interrupt handlers */
void set_intr(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100840:	66 89 50 02          	mov    %dx,0x2(%eax)
	ptr->pad0 = 0;
	ptr->type = INTERRUPT_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
c0100844:	8b 54 24 10          	mov    0x10(%esp),%edx
   in Nanos, each entry of the IDT is either an interrupt gate, or a trap gate */
struct GateDescriptor idt[NR_IRQ];

/* setup a interrupt gate for interrupt handlers */
void set_intr(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100848:	66 89 08             	mov    %cx,(%eax)
	ptr->pad0 = 0;
	ptr->type = INTERRUPT_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c010084b:	c1 e9 10             	shr    $0x10,%ecx
c010084e:	66 89 48 06          	mov    %cx,0x6(%eax)
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
	ptr->pad0 = 0;
	ptr->type = INTERRUPT_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
c0100852:	83 e2 03             	and    $0x3,%edx
c0100855:	c1 e2 05             	shl    $0x5,%edx
	ptr->present = TRUE;
c0100858:	83 ca 8e             	or     $0xffffff8e,%edx
c010085b:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}
c010085e:	c3                   	ret    
c010085f:	90                   	nop

c0100860 <set_trap>:

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
c0100860:	8b 44 24 04          	mov    0x4(%esp),%eax
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100864:	8b 54 24 08          	mov    0x8(%esp),%edx
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
c0100868:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
	ptr->pad0 = 0;
c010086c:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100870:	66 89 50 02          	mov    %dx,0x2(%eax)
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
c0100874:	8b 54 24 10          	mov    0x10(%esp),%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100878:	66 89 08             	mov    %cx,(%eax)
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c010087b:	c1 e9 10             	shr    $0x10,%ecx
c010087e:	66 89 48 06          	mov    %cx,0x6(%eax)
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
c0100882:	83 e2 03             	and    $0x3,%edx
c0100885:	c1 e2 05             	shl    $0x5,%edx
	ptr->present = TRUE;
c0100888:	83 ca 8f             	or     $0xffffff8f,%edx
c010088b:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}
c010088e:	c3                   	ret    
c010088f:	90                   	nop

c0100890 <init_idt>:

void irq_empty();

void init_idt() {
	int i;
	for (i = 0; i < NR_IRQ; i ++) {
c0100890:	b9 f1 0d 10 c0       	mov    $0xc0100df1,%ecx
c0100895:	31 c0                	xor    %eax,%eax
void vec14();
void vecsys();

void irq_empty();

void init_idt() {
c0100897:	53                   	push   %ebx
	int i;
	for (i = 0; i < NR_IRQ; i ++) {
c0100898:	89 cb                	mov    %ecx,%ebx
c010089a:	c1 e9 10             	shr    $0x10,%ecx
c010089d:	8d 76 00             	lea    0x0(%esi),%esi
		set_trap(idt + i, SEG_KERNEL_CODE << 3, (uint_32)irq_empty, DPL_KERNEL);
c01008a0:	8d 14 c5 00 80 13 c0 	lea    -0x3fec8000(,%eax,8),%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c01008a7:	66 89 1c c5 00 80 13 	mov    %bx,-0x3fec8000(,%eax,8)
c01008ae:	c0 

void irq_empty();

void init_idt() {
	int i;
	for (i = 0; i < NR_IRQ; i ++) {
c01008af:	83 c0 01             	add    $0x1,%eax
c01008b2:	3d 00 01 00 00       	cmp    $0x100,%eax
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c01008b7:	66 c7 42 02 08 00    	movw   $0x8,0x2(%edx)
	ptr->pad0 = 0;
c01008bd:	c6 42 04 00          	movb   $0x0,0x4(%edx)
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c01008c1:	c6 42 05 8f          	movb   $0x8f,0x5(%edx)
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c01008c5:	66 89 4a 06          	mov    %cx,0x6(%edx)

void irq_empty();

void init_idt() {
	int i;
	for (i = 0; i < NR_IRQ; i ++) {
c01008c9:	75 d5                	jne    c01008a0 <init_idt+0x10>
		set_trap(idt + i, SEG_KERNEL_CODE << 3, (uint_32)irq_empty, DPL_KERNEL);
	}
	set_trap(idt + 0, SEG_KERNEL_CODE << 3, (uint_32)vec0, DPL_KERNEL);
c01008cb:	ba 60 0d 10 c0       	mov    $0xc0100d60,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c01008d0:	b8 00 80 13 c0       	mov    $0xc0138000,%eax
c01008d5:	66 89 15 00 80 13 c0 	mov    %dx,0xc0138000
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c01008dc:	c1 ea 10             	shr    $0x10,%edx
c01008df:	66 89 15 06 80 13 c0 	mov    %dx,0xc0138006
	int i;
	for (i = 0; i < NR_IRQ; i ++) {
		set_trap(idt + i, SEG_KERNEL_CODE << 3, (uint_32)irq_empty, DPL_KERNEL);
	}
	set_trap(idt + 0, SEG_KERNEL_CODE << 3, (uint_32)vec0, DPL_KERNEL);
	set_trap(idt + 1, SEG_KERNEL_CODE << 3, (uint_32)vec1, DPL_KERNEL);
c01008e6:	ba 67 0d 10 c0       	mov    $0xc0100d67,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c01008eb:	66 89 15 08 80 13 c0 	mov    %dx,0xc0138008
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c01008f2:	c1 ea 10             	shr    $0x10,%edx
c01008f5:	66 89 15 0e 80 13 c0 	mov    %dx,0xc013800e
	for (i = 0; i < NR_IRQ; i ++) {
		set_trap(idt + i, SEG_KERNEL_CODE << 3, (uint_32)irq_empty, DPL_KERNEL);
	}
	set_trap(idt + 0, SEG_KERNEL_CODE << 3, (uint_32)vec0, DPL_KERNEL);
	set_trap(idt + 1, SEG_KERNEL_CODE << 3, (uint_32)vec1, DPL_KERNEL);
	set_trap(idt + 2, SEG_KERNEL_CODE << 3, (uint_32)vec2, DPL_KERNEL);
c01008fc:	ba 6e 0d 10 c0       	mov    $0xc0100d6e,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100901:	66 89 15 10 80 13 c0 	mov    %dx,0xc0138010
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100908:	c1 ea 10             	shr    $0x10,%edx
c010090b:	66 89 15 16 80 13 c0 	mov    %dx,0xc0138016
		set_trap(idt + i, SEG_KERNEL_CODE << 3, (uint_32)irq_empty, DPL_KERNEL);
	}
	set_trap(idt + 0, SEG_KERNEL_CODE << 3, (uint_32)vec0, DPL_KERNEL);
	set_trap(idt + 1, SEG_KERNEL_CODE << 3, (uint_32)vec1, DPL_KERNEL);
	set_trap(idt + 2, SEG_KERNEL_CODE << 3, (uint_32)vec2, DPL_KERNEL);
	set_trap(idt + 3, SEG_KERNEL_CODE << 3, (uint_32)vec3, DPL_KERNEL);
c0100912:	ba 75 0d 10 c0       	mov    $0xc0100d75,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100917:	66 89 15 18 80 13 c0 	mov    %dx,0xc0138018
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c010091e:	c1 ea 10             	shr    $0x10,%edx
c0100921:	66 89 15 1e 80 13 c0 	mov    %dx,0xc013801e
	}
	set_trap(idt + 0, SEG_KERNEL_CODE << 3, (uint_32)vec0, DPL_KERNEL);
	set_trap(idt + 1, SEG_KERNEL_CODE << 3, (uint_32)vec1, DPL_KERNEL);
	set_trap(idt + 2, SEG_KERNEL_CODE << 3, (uint_32)vec2, DPL_KERNEL);
	set_trap(idt + 3, SEG_KERNEL_CODE << 3, (uint_32)vec3, DPL_KERNEL);
	set_trap(idt + 4, SEG_KERNEL_CODE << 3, (uint_32)vec4, DPL_KERNEL);
c0100928:	ba 7c 0d 10 c0       	mov    $0xc0100d7c,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c010092d:	66 89 15 20 80 13 c0 	mov    %dx,0xc0138020
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100934:	c1 ea 10             	shr    $0x10,%edx
c0100937:	66 89 15 26 80 13 c0 	mov    %dx,0xc0138026
	set_trap(idt + 0, SEG_KERNEL_CODE << 3, (uint_32)vec0, DPL_KERNEL);
	set_trap(idt + 1, SEG_KERNEL_CODE << 3, (uint_32)vec1, DPL_KERNEL);
	set_trap(idt + 2, SEG_KERNEL_CODE << 3, (uint_32)vec2, DPL_KERNEL);
	set_trap(idt + 3, SEG_KERNEL_CODE << 3, (uint_32)vec3, DPL_KERNEL);
	set_trap(idt + 4, SEG_KERNEL_CODE << 3, (uint_32)vec4, DPL_KERNEL);
	set_trap(idt + 5, SEG_KERNEL_CODE << 3, (uint_32)vec5, DPL_KERNEL);
c010093e:	ba 83 0d 10 c0       	mov    $0xc0100d83,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100943:	66 89 15 28 80 13 c0 	mov    %dx,0xc0138028
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c010094a:	c1 ea 10             	shr    $0x10,%edx
c010094d:	66 89 15 2e 80 13 c0 	mov    %dx,0xc013802e
	set_trap(idt + 1, SEG_KERNEL_CODE << 3, (uint_32)vec1, DPL_KERNEL);
	set_trap(idt + 2, SEG_KERNEL_CODE << 3, (uint_32)vec2, DPL_KERNEL);
	set_trap(idt + 3, SEG_KERNEL_CODE << 3, (uint_32)vec3, DPL_KERNEL);
	set_trap(idt + 4, SEG_KERNEL_CODE << 3, (uint_32)vec4, DPL_KERNEL);
	set_trap(idt + 5, SEG_KERNEL_CODE << 3, (uint_32)vec5, DPL_KERNEL);
	set_trap(idt + 6, SEG_KERNEL_CODE << 3, (uint_32)vec6, DPL_KERNEL);
c0100954:	ba 8a 0d 10 c0       	mov    $0xc0100d8a,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100959:	66 89 15 30 80 13 c0 	mov    %dx,0xc0138030
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100960:	c1 ea 10             	shr    $0x10,%edx
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100963:	66 c7 05 02 80 13 c0 	movw   $0x8,0xc0138002
c010096a:	08 00 
	ptr->pad0 = 0;
c010096c:	c6 05 04 80 13 c0 00 	movb   $0x0,0xc0138004
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100973:	c6 05 05 80 13 c0 8f 	movb   $0x8f,0xc0138005
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c010097a:	66 c7 05 0a 80 13 c0 	movw   $0x8,0xc013800a
c0100981:	08 00 
	ptr->pad0 = 0;
c0100983:	c6 05 0c 80 13 c0 00 	movb   $0x0,0xc013800c
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c010098a:	c6 05 0d 80 13 c0 8f 	movb   $0x8f,0xc013800d
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100991:	66 c7 05 12 80 13 c0 	movw   $0x8,0xc0138012
c0100998:	08 00 
	ptr->pad0 = 0;
c010099a:	c6 05 14 80 13 c0 00 	movb   $0x0,0xc0138014
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c01009a1:	c6 05 15 80 13 c0 8f 	movb   $0x8f,0xc0138015
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c01009a8:	66 c7 05 1a 80 13 c0 	movw   $0x8,0xc013801a
c01009af:	08 00 
	ptr->pad0 = 0;
c01009b1:	c6 05 1c 80 13 c0 00 	movb   $0x0,0xc013801c
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c01009b8:	c6 05 1d 80 13 c0 8f 	movb   $0x8f,0xc013801d
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c01009bf:	66 c7 05 22 80 13 c0 	movw   $0x8,0xc0138022
c01009c6:	08 00 
	ptr->pad0 = 0;
c01009c8:	c6 05 24 80 13 c0 00 	movb   $0x0,0xc0138024
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c01009cf:	c6 05 25 80 13 c0 8f 	movb   $0x8f,0xc0138025
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c01009d6:	66 c7 05 2a 80 13 c0 	movw   $0x8,0xc013802a
c01009dd:	08 00 
	ptr->pad0 = 0;
c01009df:	c6 05 2c 80 13 c0 00 	movb   $0x0,0xc013802c
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c01009e6:	c6 05 2d 80 13 c0 8f 	movb   $0x8f,0xc013802d
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c01009ed:	66 c7 05 32 80 13 c0 	movw   $0x8,0xc0138032
c01009f4:	08 00 
	ptr->pad0 = 0;
c01009f6:	c6 05 34 80 13 c0 00 	movb   $0x0,0xc0138034
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c01009fd:	c6 05 35 80 13 c0 8f 	movb   $0x8f,0xc0138035
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100a04:	66 89 15 36 80 13 c0 	mov    %dx,0xc0138036
	set_trap(idt + 2, SEG_KERNEL_CODE << 3, (uint_32)vec2, DPL_KERNEL);
	set_trap(idt + 3, SEG_KERNEL_CODE << 3, (uint_32)vec3, DPL_KERNEL);
	set_trap(idt + 4, SEG_KERNEL_CODE << 3, (uint_32)vec4, DPL_KERNEL);
	set_trap(idt + 5, SEG_KERNEL_CODE << 3, (uint_32)vec5, DPL_KERNEL);
	set_trap(idt + 6, SEG_KERNEL_CODE << 3, (uint_32)vec6, DPL_KERNEL);
	set_trap(idt + 7, SEG_KERNEL_CODE << 3, (uint_32)vec7, DPL_KERNEL);
c0100a0b:	ba 91 0d 10 c0       	mov    $0xc0100d91,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100a10:	66 89 15 38 80 13 c0 	mov    %dx,0xc0138038
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100a17:	c1 ea 10             	shr    $0x10,%edx
c0100a1a:	66 89 15 3e 80 13 c0 	mov    %dx,0xc013803e
	set_trap(idt + 3, SEG_KERNEL_CODE << 3, (uint_32)vec3, DPL_KERNEL);
	set_trap(idt + 4, SEG_KERNEL_CODE << 3, (uint_32)vec4, DPL_KERNEL);
	set_trap(idt + 5, SEG_KERNEL_CODE << 3, (uint_32)vec5, DPL_KERNEL);
	set_trap(idt + 6, SEG_KERNEL_CODE << 3, (uint_32)vec6, DPL_KERNEL);
	set_trap(idt + 7, SEG_KERNEL_CODE << 3, (uint_32)vec7, DPL_KERNEL);
	set_trap(idt + 8, SEG_KERNEL_CODE << 3, (uint_32)vec8, DPL_KERNEL);
c0100a21:	ba 98 0d 10 c0       	mov    $0xc0100d98,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100a26:	66 89 15 40 80 13 c0 	mov    %dx,0xc0138040
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100a2d:	c1 ea 10             	shr    $0x10,%edx
c0100a30:	66 89 15 46 80 13 c0 	mov    %dx,0xc0138046
	set_trap(idt + 4, SEG_KERNEL_CODE << 3, (uint_32)vec4, DPL_KERNEL);
	set_trap(idt + 5, SEG_KERNEL_CODE << 3, (uint_32)vec5, DPL_KERNEL);
	set_trap(idt + 6, SEG_KERNEL_CODE << 3, (uint_32)vec6, DPL_KERNEL);
	set_trap(idt + 7, SEG_KERNEL_CODE << 3, (uint_32)vec7, DPL_KERNEL);
	set_trap(idt + 8, SEG_KERNEL_CODE << 3, (uint_32)vec8, DPL_KERNEL);
	set_trap(idt + 9, SEG_KERNEL_CODE << 3, (uint_32)vec9, DPL_KERNEL);
c0100a37:	ba 9f 0d 10 c0       	mov    $0xc0100d9f,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100a3c:	66 89 15 48 80 13 c0 	mov    %dx,0xc0138048
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100a43:	c1 ea 10             	shr    $0x10,%edx
c0100a46:	66 89 15 4e 80 13 c0 	mov    %dx,0xc013804e
	set_trap(idt + 5, SEG_KERNEL_CODE << 3, (uint_32)vec5, DPL_KERNEL);
	set_trap(idt + 6, SEG_KERNEL_CODE << 3, (uint_32)vec6, DPL_KERNEL);
	set_trap(idt + 7, SEG_KERNEL_CODE << 3, (uint_32)vec7, DPL_KERNEL);
	set_trap(idt + 8, SEG_KERNEL_CODE << 3, (uint_32)vec8, DPL_KERNEL);
	set_trap(idt + 9, SEG_KERNEL_CODE << 3, (uint_32)vec9, DPL_KERNEL);
	set_trap(idt + 10, SEG_KERNEL_CODE << 3, (uint_32)vec10, DPL_KERNEL);
c0100a4d:	ba a6 0d 10 c0       	mov    $0xc0100da6,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100a52:	66 89 15 50 80 13 c0 	mov    %dx,0xc0138050
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100a59:	c1 ea 10             	shr    $0x10,%edx
c0100a5c:	66 89 15 56 80 13 c0 	mov    %dx,0xc0138056
	set_trap(idt + 6, SEG_KERNEL_CODE << 3, (uint_32)vec6, DPL_KERNEL);
	set_trap(idt + 7, SEG_KERNEL_CODE << 3, (uint_32)vec7, DPL_KERNEL);
	set_trap(idt + 8, SEG_KERNEL_CODE << 3, (uint_32)vec8, DPL_KERNEL);
	set_trap(idt + 9, SEG_KERNEL_CODE << 3, (uint_32)vec9, DPL_KERNEL);
	set_trap(idt + 10, SEG_KERNEL_CODE << 3, (uint_32)vec10, DPL_KERNEL);
	set_trap(idt + 11, SEG_KERNEL_CODE << 3, (uint_32)vec11, DPL_KERNEL);
c0100a63:	ba ad 0d 10 c0       	mov    $0xc0100dad,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100a68:	66 89 15 58 80 13 c0 	mov    %dx,0xc0138058
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100a6f:	c1 ea 10             	shr    $0x10,%edx
c0100a72:	66 89 15 5e 80 13 c0 	mov    %dx,0xc013805e
	set_trap(idt + 7, SEG_KERNEL_CODE << 3, (uint_32)vec7, DPL_KERNEL);
	set_trap(idt + 8, SEG_KERNEL_CODE << 3, (uint_32)vec8, DPL_KERNEL);
	set_trap(idt + 9, SEG_KERNEL_CODE << 3, (uint_32)vec9, DPL_KERNEL);
	set_trap(idt + 10, SEG_KERNEL_CODE << 3, (uint_32)vec10, DPL_KERNEL);
	set_trap(idt + 11, SEG_KERNEL_CODE << 3, (uint_32)vec11, DPL_KERNEL);
	set_trap(idt + 12, SEG_KERNEL_CODE << 3, (uint_32)vec12, DPL_KERNEL);
c0100a79:	ba b4 0d 10 c0       	mov    $0xc0100db4,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100a7e:	66 89 15 60 80 13 c0 	mov    %dx,0xc0138060
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100a85:	c1 ea 10             	shr    $0x10,%edx
c0100a88:	66 89 15 66 80 13 c0 	mov    %dx,0xc0138066
	set_trap(idt + 8, SEG_KERNEL_CODE << 3, (uint_32)vec8, DPL_KERNEL);
	set_trap(idt + 9, SEG_KERNEL_CODE << 3, (uint_32)vec9, DPL_KERNEL);
	set_trap(idt + 10, SEG_KERNEL_CODE << 3, (uint_32)vec10, DPL_KERNEL);
	set_trap(idt + 11, SEG_KERNEL_CODE << 3, (uint_32)vec11, DPL_KERNEL);
	set_trap(idt + 12, SEG_KERNEL_CODE << 3, (uint_32)vec12, DPL_KERNEL);
	set_trap(idt + 13, SEG_KERNEL_CODE << 3, (uint_32)vec13, DPL_KERNEL);
c0100a8f:	ba bb 0d 10 c0       	mov    $0xc0100dbb,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100a94:	66 89 15 68 80 13 c0 	mov    %dx,0xc0138068
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100a9b:	c1 ea 10             	shr    $0x10,%edx
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100a9e:	66 c7 05 3a 80 13 c0 	movw   $0x8,0xc013803a
c0100aa5:	08 00 
	ptr->pad0 = 0;
c0100aa7:	c6 05 3c 80 13 c0 00 	movb   $0x0,0xc013803c
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100aae:	c6 05 3d 80 13 c0 8f 	movb   $0x8f,0xc013803d
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100ab5:	66 c7 05 42 80 13 c0 	movw   $0x8,0xc0138042
c0100abc:	08 00 
	ptr->pad0 = 0;
c0100abe:	c6 05 44 80 13 c0 00 	movb   $0x0,0xc0138044
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100ac5:	c6 05 45 80 13 c0 8f 	movb   $0x8f,0xc0138045
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100acc:	66 c7 05 4a 80 13 c0 	movw   $0x8,0xc013804a
c0100ad3:	08 00 
	ptr->pad0 = 0;
c0100ad5:	c6 05 4c 80 13 c0 00 	movb   $0x0,0xc013804c
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100adc:	c6 05 4d 80 13 c0 8f 	movb   $0x8f,0xc013804d
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100ae3:	66 c7 05 52 80 13 c0 	movw   $0x8,0xc0138052
c0100aea:	08 00 
	ptr->pad0 = 0;
c0100aec:	c6 05 54 80 13 c0 00 	movb   $0x0,0xc0138054
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100af3:	c6 05 55 80 13 c0 8f 	movb   $0x8f,0xc0138055
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100afa:	66 c7 05 5a 80 13 c0 	movw   $0x8,0xc013805a
c0100b01:	08 00 
	ptr->pad0 = 0;
c0100b03:	c6 05 5c 80 13 c0 00 	movb   $0x0,0xc013805c
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100b0a:	c6 05 5d 80 13 c0 8f 	movb   $0x8f,0xc013805d
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100b11:	66 c7 05 62 80 13 c0 	movw   $0x8,0xc0138062
c0100b18:	08 00 
	ptr->pad0 = 0;
c0100b1a:	c6 05 64 80 13 c0 00 	movb   $0x0,0xc0138064
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100b21:	c6 05 65 80 13 c0 8f 	movb   $0x8f,0xc0138065
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100b28:	66 c7 05 6a 80 13 c0 	movw   $0x8,0xc013806a
c0100b2f:	08 00 
	ptr->pad0 = 0;
c0100b31:	c6 05 6c 80 13 c0 00 	movb   $0x0,0xc013806c
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100b38:	66 89 15 6e 80 13 c0 	mov    %dx,0xc013806e
	set_trap(idt + 9, SEG_KERNEL_CODE << 3, (uint_32)vec9, DPL_KERNEL);
	set_trap(idt + 10, SEG_KERNEL_CODE << 3, (uint_32)vec10, DPL_KERNEL);
	set_trap(idt + 11, SEG_KERNEL_CODE << 3, (uint_32)vec11, DPL_KERNEL);
	set_trap(idt + 12, SEG_KERNEL_CODE << 3, (uint_32)vec12, DPL_KERNEL);
	set_trap(idt + 13, SEG_KERNEL_CODE << 3, (uint_32)vec13, DPL_KERNEL);
	set_trap(idt + 14, SEG_KERNEL_CODE << 3, (uint_32)vec14, DPL_KERNEL);
c0100b3f:	ba c2 0d 10 c0       	mov    $0xc0100dc2,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100b44:	66 89 15 70 80 13 c0 	mov    %dx,0xc0138070
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100b4b:	c1 ea 10             	shr    $0x10,%edx
c0100b4e:	66 89 15 76 80 13 c0 	mov    %dx,0xc0138076
	set_trap(idt + 12, SEG_KERNEL_CODE << 3, (uint_32)vec12, DPL_KERNEL);
	set_trap(idt + 13, SEG_KERNEL_CODE << 3, (uint_32)vec13, DPL_KERNEL);
	set_trap(idt + 14, SEG_KERNEL_CODE << 3, (uint_32)vec14, DPL_KERNEL);

	/* the system call 0x80 */
	set_trap(idt + 0x80, SEG_KERNEL_CODE << 3, (uint_32)vecsys, DPL_KERNEL);
c0100b55:	ba c9 0d 10 c0       	mov    $0xc0100dc9,%edx
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100b5a:	66 89 15 00 84 13 c0 	mov    %dx,0xc0138400
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100b61:	c1 ea 10             	shr    $0x10,%edx
c0100b64:	66 89 15 06 84 13 c0 	mov    %dx,0xc0138406
	set_trap(idt + 14, SEG_KERNEL_CODE << 3, (uint_32)vec14, DPL_KERNEL);

	/* the system call 0x80 */
	set_trap(idt + 0x80, SEG_KERNEL_CODE << 3, (uint_32)vecsys, DPL_KERNEL);

	set_intr(idt+32 + 0, SEG_KERNEL_CODE << 3, (uint_32)irq0, DPL_KERNEL);
c0100b6b:	ba d3 0d 10 c0       	mov    $0xc0100dd3,%edx
   in Nanos, each entry of the IDT is either an interrupt gate, or a trap gate */
struct GateDescriptor idt[NR_IRQ];

/* setup a interrupt gate for interrupt handlers */
void set_intr(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100b70:	66 89 15 00 81 13 c0 	mov    %dx,0xc0138100
	ptr->pad0 = 0;
	ptr->type = INTERRUPT_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100b77:	c1 ea 10             	shr    $0x10,%edx
c0100b7a:	66 89 15 06 81 13 c0 	mov    %dx,0xc0138106

	/* the system call 0x80 */
	set_trap(idt + 0x80, SEG_KERNEL_CODE << 3, (uint_32)vecsys, DPL_KERNEL);

	set_intr(idt+32 + 0, SEG_KERNEL_CODE << 3, (uint_32)irq0, DPL_KERNEL);
	set_intr(idt+32 + 1, SEG_KERNEL_CODE << 3, (uint_32)irq1, DPL_KERNEL);
c0100b81:	ba dd 0d 10 c0       	mov    $0xc0100ddd,%edx
   in Nanos, each entry of the IDT is either an interrupt gate, or a trap gate */
struct GateDescriptor idt[NR_IRQ];

/* setup a interrupt gate for interrupt handlers */
void set_intr(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100b86:	66 89 15 08 81 13 c0 	mov    %dx,0xc0138108
	ptr->pad0 = 0;
	ptr->type = INTERRUPT_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100b8d:	c1 ea 10             	shr    $0x10,%edx
c0100b90:	66 89 15 0e 81 13 c0 	mov    %dx,0xc013810e
	/* the system call 0x80 */
	set_trap(idt + 0x80, SEG_KERNEL_CODE << 3, (uint_32)vecsys, DPL_KERNEL);

	set_intr(idt+32 + 0, SEG_KERNEL_CODE << 3, (uint_32)irq0, DPL_KERNEL);
	set_intr(idt+32 + 1, SEG_KERNEL_CODE << 3, (uint_32)irq1, DPL_KERNEL);
	set_intr(idt+32 + 14, SEG_KERNEL_CODE << 3, (uint_32)irq14, DPL_KERNEL);
c0100b97:	ba e7 0d 10 c0       	mov    $0xc0100de7,%edx

/* modify the value of IDTR */
static inline void
save_idt(void *addr, uint_32 size) {
	static volatile uint_16 data[3];
	data[0] = size - 1;
c0100b9c:	66 c7 05 28 50 10 c0 	movw   $0x7ff,0xc0105028
c0100ba3:	ff 07 
   in Nanos, each entry of the IDT is either an interrupt gate, or a trap gate */
struct GateDescriptor idt[NR_IRQ];

/* setup a interrupt gate for interrupt handlers */
void set_intr(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
c0100ba5:	66 89 15 70 81 13 c0 	mov    %dx,0xc0138170
	ptr->pad0 = 0;
	ptr->type = INTERRUPT_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100bac:	c1 ea 10             	shr    $0x10,%edx
	data[1] = (uint_32)addr;
c0100baf:	66 a3 2a 50 10 c0    	mov    %ax,0xc010502a
	data[2] = ((uint_32)addr) >> 16;
c0100bb5:	c1 e8 10             	shr    $0x10,%eax
c0100bb8:	66 89 15 76 81 13 c0 	mov    %dx,0xc0138176
c0100bbf:	66 a3 2c 50 10 c0    	mov    %ax,0xc010502c
	asm volatile("lidt (%0)" : : "r"(data));
c0100bc5:	b8 28 50 10 c0       	mov    $0xc0105028,%eax
	ptr->segment = selector;
	ptr->pad0 = 0;
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100bca:	c6 05 6d 80 13 c0 8f 	movb   $0x8f,0xc013806d
c0100bd1:	0f 01 18             	lidtl  (%eax)
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100bd4:	66 c7 05 72 80 13 c0 	movw   $0x8,0xc0138072
c0100bdb:	08 00 
	ptr->pad0 = 0;
c0100bdd:	c6 05 74 80 13 c0 00 	movb   $0x0,0xc0138074
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100be4:	c6 05 75 80 13 c0 8f 	movb   $0x8f,0xc0138075
}

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100beb:	66 c7 05 02 84 13 c0 	movw   $0x8,0xc0138402
c0100bf2:	08 00 
	ptr->pad0 = 0;
c0100bf4:	c6 05 04 84 13 c0 00 	movb   $0x0,0xc0138404
	ptr->type = TRAP_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100bfb:	c6 05 05 84 13 c0 8f 	movb   $0x8f,0xc0138405
struct GateDescriptor idt[NR_IRQ];

/* setup a interrupt gate for interrupt handlers */
void set_intr(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100c02:	66 c7 05 02 81 13 c0 	movw   $0x8,0xc0138102
c0100c09:	08 00 
	ptr->pad0 = 0;
c0100c0b:	c6 05 04 81 13 c0 00 	movb   $0x0,0xc0138104
	ptr->type = INTERRUPT_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100c12:	c6 05 05 81 13 c0 8e 	movb   $0x8e,0xc0138105
struct GateDescriptor idt[NR_IRQ];

/* setup a interrupt gate for interrupt handlers */
void set_intr(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100c19:	66 c7 05 0a 81 13 c0 	movw   $0x8,0xc013810a
c0100c20:	08 00 
	ptr->pad0 = 0;
c0100c22:	c6 05 0c 81 13 c0 00 	movb   $0x0,0xc013810c
	ptr->type = INTERRUPT_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100c29:	c6 05 0d 81 13 c0 8e 	movb   $0x8e,0xc013810d
struct GateDescriptor idt[NR_IRQ];

/* setup a interrupt gate for interrupt handlers */
void set_intr(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
	ptr->offset_15_0 = offset & 0xFFFF;
	ptr->segment = selector;
c0100c30:	66 c7 05 72 81 13 c0 	movw   $0x8,0xc0138172
c0100c37:	08 00 
	ptr->pad0 = 0;
c0100c39:	c6 05 74 81 13 c0 00 	movb   $0x0,0xc0138174
	ptr->type = INTERRUPT_GATE_32;
	ptr->system = FALSE;
	ptr->privilege_level = dpl;
	ptr->present = TRUE;
c0100c40:	c6 05 75 81 13 c0 8e 	movb   $0x8e,0xc0138175
	set_intr(idt+32 + 1, SEG_KERNEL_CODE << 3, (uint_32)irq1, DPL_KERNEL);
	set_intr(idt+32 + 14, SEG_KERNEL_CODE << 3, (uint_32)irq14, DPL_KERNEL);

	/* the ``idt'' is its virtual address */
	save_idt(idt, sizeof(idt));
}
c0100c47:	5b                   	pop    %ebx
c0100c48:	c3                   	ret    
c0100c49:	90                   	nop
c0100c4a:	90                   	nop
c0100c4b:	90                   	nop
c0100c4c:	90                   	nop
c0100c4d:	90                   	nop
c0100c4e:	90                   	nop
c0100c4f:	90                   	nop

c0100c50 <add_irq_handle>:
static struct IRQ_t handle_pool[NR_IRQ_HANDLE];
static struct IRQ_t *handles[NR_IRQ];
static int handle_count = 0;

void
add_irq_handle( int irq, void (*func)(void) ) {
c0100c50:	53                   	push   %ebx
c0100c51:	83 ec 18             	sub    $0x18,%esp
	struct IRQ_t *ptr;
	if (handle_count > NR_IRQ_HANDLE) {
c0100c54:	a1 40 50 10 c0       	mov    0xc0105040,%eax
static struct IRQ_t handle_pool[NR_IRQ_HANDLE];
static struct IRQ_t *handles[NR_IRQ];
static int handle_count = 0;

void
add_irq_handle( int irq, void (*func)(void) ) {
c0100c59:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	struct IRQ_t *ptr;
	if (handle_count > NR_IRQ_HANDLE) {
c0100c5d:	83 f8 20             	cmp    $0x20,%eax
c0100c60:	7e 11                	jle    c0100c73 <add_irq_handle+0x23>
		panic("Too many irq registrations!");
c0100c62:	c7 04 24 d2 34 10 c0 	movl   $0xc01034d2,(%esp)
c0100c69:	e8 52 f7 ff ff       	call   c01003c0 <panic>
c0100c6e:	a1 40 50 10 c0       	mov    0xc0105040,%eax
	}
	ptr = &handle_pool[handle_count ++]; /* get a free handler */
c0100c73:	8d 48 01             	lea    0x1(%eax),%ecx
c0100c76:	89 0d 40 50 10 c0    	mov    %ecx,0xc0105040
	ptr->routine = func;
c0100c7c:	8b 4c 24 24          	mov    0x24(%esp),%ecx
add_irq_handle( int irq, void (*func)(void) ) {
	struct IRQ_t *ptr;
	if (handle_count > NR_IRQ_HANDLE) {
		panic("Too many irq registrations!");
	}
	ptr = &handle_pool[handle_count ++]; /* get a free handler */
c0100c80:	8d 14 c5 60 50 10 c0 	lea    -0x3fefafa0(,%eax,8),%edx
	ptr->routine = func;
c0100c87:	89 0c c5 60 50 10 c0 	mov    %ecx,-0x3fefafa0(,%eax,8)
	ptr->next = handles[irq]; /* insert into the linked list */
c0100c8e:	8b 04 9d 60 51 10 c0 	mov    -0x3fefaea0(,%ebx,4),%eax
	handles[irq] = ptr;
c0100c95:	89 14 9d 60 51 10 c0 	mov    %edx,-0x3fefaea0(,%ebx,4)
	if (handle_count > NR_IRQ_HANDLE) {
		panic("Too many irq registrations!");
	}
	ptr = &handle_pool[handle_count ++]; /* get a free handler */
	ptr->routine = func;
	ptr->next = handles[irq]; /* insert into the linked list */
c0100c9c:	89 42 04             	mov    %eax,0x4(%edx)
	handles[irq] = ptr;
}
c0100c9f:	83 c4 18             	add    $0x18,%esp
c0100ca2:	5b                   	pop    %ebx
c0100ca3:	c3                   	ret    
c0100ca4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c0100caa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

c0100cb0 <irq_handle>:

//void schedule();

void irq_handle(struct TrapFrame *tf) {
c0100cb0:	53                   	push   %ebx
c0100cb1:	83 ec 18             	sub    $0x18,%esp
	int irq = tf -> irq;
//	printk("***************** %d\n", enter_interrupt);

//	enter_interrupt = TRUE;	

	current_pcb -> esp = tf;
c0100cb4:	8b 15 04 90 1d c0    	mov    0xc01d9004,%edx
	handles[irq] = ptr;
}

//void schedule();

void irq_handle(struct TrapFrame *tf) {
c0100cba:	8b 44 24 20          	mov    0x20(%esp),%eax
//	asm volatile("cli");
//	printk("*********************************** %d\n", global_lock_counter);
//	lock();
	int irq = tf -> irq;
c0100cbe:	8b 58 20             	mov    0x20(%eax),%ebx
//	printk("***************** %d\n", enter_interrupt);

//	enter_interrupt = TRUE;	

	current_pcb -> esp = tf;
c0100cc1:	89 02                	mov    %eax,(%edx)

	if (irq < 0) {
c0100cc3:	85 db                	test   %ebx,%ebx
c0100cc5:	78 29                	js     c0100cf0 <irq_handle+0x40>
		panic("Unhandled exception!");
	}

	if (irq < 1000) {
c0100cc7:	81 fb e7 03 00 00    	cmp    $0x3e7,%ebx
c0100ccd:	7e 2d                	jle    c0100cfc <irq_handle+0x4c>
		panic("Unexpected exception #%d\n", irq);
	} else if (irq >= 1000) {
		int irq_id = irq - 1000;
		struct IRQ_t *f = handles[irq_id];
c0100ccf:	8b 1c 9d c0 41 10 c0 	mov    -0x3fefbe40(,%ebx,4),%ebx

		while (f != NULL) { /* call handlers one by one */
c0100cd6:	85 db                	test   %ebx,%ebx
c0100cd8:	74 0f                	je     c0100ce9 <irq_handle+0x39>
c0100cda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			f->routine(); 
c0100ce0:	ff 13                	call   *(%ebx)
			f = f->next;
c0100ce2:	8b 5b 04             	mov    0x4(%ebx),%ebx
		panic("Unexpected exception #%d\n", irq);
	} else if (irq >= 1000) {
		int irq_id = irq - 1000;
		struct IRQ_t *f = handles[irq_id];

		while (f != NULL) { /* call handlers one by one */
c0100ce5:	85 db                	test   %ebx,%ebx
c0100ce7:	75 f7                	jne    c0100ce0 <irq_handle+0x30>
	//schedule();
	//unlock();
	//-- global_lock_counter;
//	enter_interrupt = FALSE;
	
}
c0100ce9:	83 c4 18             	add    $0x18,%esp
c0100cec:	5b                   	pop    %ebx
c0100ced:	c3                   	ret    
c0100cee:	66 90                	xchg   %ax,%ax
//	enter_interrupt = TRUE;	

	current_pcb -> esp = tf;

	if (irq < 0) {
		panic("Unhandled exception!");
c0100cf0:	c7 04 24 ee 34 10 c0 	movl   $0xc01034ee,(%esp)
c0100cf7:	e8 c4 f6 ff ff       	call   c01003c0 <panic>
	}

	if (irq < 1000) {
		panic("Unexpected exception #%d\n", irq);
c0100cfc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0100d00:	c7 04 24 03 35 10 c0 	movl   $0xc0103503,(%esp)
c0100d07:	e8 b4 f6 ff ff       	call   c01003c0 <panic>
	//schedule();
	//unlock();
	//-- global_lock_counter;
//	enter_interrupt = FALSE;
	
}
c0100d0c:	83 c4 18             	add    $0x18,%esp
c0100d0f:	5b                   	pop    %ebx
c0100d10:	c3                   	ret    
c0100d11:	eb 0d                	jmp    c0100d20 <int_handle>
c0100d13:	90                   	nop
c0100d14:	90                   	nop
c0100d15:	90                   	nop
c0100d16:	90                   	nop
c0100d17:	90                   	nop
c0100d18:	90                   	nop
c0100d19:	90                   	nop
c0100d1a:	90                   	nop
c0100d1b:	90                   	nop
c0100d1c:	90                   	nop
c0100d1d:	90                   	nop
c0100d1e:	90                   	nop
c0100d1f:	90                   	nop

c0100d20 <int_handle>:

void int_handle(struct TrapFrame *tf) {

	//printk("begin\n");	

	current_pcb -> esp = tf;
c0100d20:	8b 54 24 04          	mov    0x4(%esp),%edx
c0100d24:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0100d29:	89 10                	mov    %edx,(%eax)

	need_sched = TRUE;	
c0100d2b:	c6 05 e8 4b 10 c0 01 	movb   $0x1,0xc0104be8
	
	//printk("end\n");	
}
c0100d32:	c3                   	ret    
c0100d33:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c0100d39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0100d40 <init_handle>:
*/


void init_handle() {
	int i;
	for (i = 0; i < NR_IRQ; ++ i)
c0100d40:	31 c0                	xor    %eax,%eax
c0100d42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		handles[i] = NULL;
c0100d48:	c7 04 85 60 51 10 c0 	movl   $0x0,-0x3fefaea0(,%eax,4)
c0100d4f:	00 00 00 00 
*/


void init_handle() {
	int i;
	for (i = 0; i < NR_IRQ; ++ i)
c0100d53:	83 c0 01             	add    $0x1,%eax
c0100d56:	3d 00 01 00 00       	cmp    $0x100,%eax
c0100d5b:	75 eb                	jne    c0100d48 <init_handle+0x8>
		handles[i] = NULL;

//	add_irq_handle(0, set_need_sched);
}
c0100d5d:	f3 c3                	repz ret 
c0100d5f:	90                   	nop

c0100d60 <vec0>:
c0100d60:	6a 00                	push   $0x0
c0100d62:	e9 91 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100d67 <vec1>:
c0100d67:	6a 01                	push   $0x1
c0100d69:	e9 8a 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100d6e <vec2>:
c0100d6e:	6a 02                	push   $0x2
c0100d70:	e9 83 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100d75 <vec3>:
c0100d75:	6a 03                	push   $0x3
c0100d77:	e9 7c 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100d7c <vec4>:
c0100d7c:	6a 04                	push   $0x4
c0100d7e:	e9 75 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100d83 <vec5>:
c0100d83:	6a 05                	push   $0x5
c0100d85:	e9 6e 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100d8a <vec6>:
c0100d8a:	6a 06                	push   $0x6
c0100d8c:	e9 67 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100d91 <vec7>:
c0100d91:	6a 07                	push   $0x7
c0100d93:	e9 60 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100d98 <vec8>:
c0100d98:	6a 08                	push   $0x8
c0100d9a:	e9 59 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100d9f <vec9>:
c0100d9f:	6a 09                	push   $0x9
c0100da1:	e9 52 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100da6 <vec10>:
c0100da6:	6a 0a                	push   $0xa
c0100da8:	e9 4b 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100dad <vec11>:
c0100dad:	6a 0b                	push   $0xb
c0100daf:	e9 44 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100db4 <vec12>:
c0100db4:	6a 0c                	push   $0xc
c0100db6:	e9 3d 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100dbb <vec13>:
c0100dbb:	6a 0d                	push   $0xd
c0100dbd:	e9 36 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100dc2 <vec14>:
c0100dc2:	6a 0e                	push   $0xe
c0100dc4:	e9 2f 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100dc9 <vecsys>:
c0100dc9:	68 80 00 00 00       	push   $0x80
c0100dce:	e9 6b 00 00 00       	jmp    c0100e3e <asm_do_int>

c0100dd3 <irq0>:
c0100dd3:	68 e8 03 00 00       	push   $0x3e8
c0100dd8:	e9 1b 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100ddd <irq1>:
c0100ddd:	68 e9 03 00 00       	push   $0x3e9
c0100de2:	e9 11 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100de7 <irq14>:
c0100de7:	68 f6 03 00 00       	push   $0x3f6
c0100dec:	e9 07 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100df1 <irq_empty>:
c0100df1:	6a ff                	push   $0xffffffff
c0100df3:	e9 00 00 00 00       	jmp    c0100df8 <asm_do_irq>

c0100df8 <asm_do_irq>:
c0100df8:	c7 05 60 55 10 c0 01 	movl   $0x1,0xc0105560
c0100dff:	00 00 00 
c0100e02:	60                   	pusha  
c0100e03:	89 e3                	mov    %esp,%ebx
c0100e05:	81 fc 00 00 00 c0    	cmp    $0xc0000000,%esp
c0100e0b:	73 08                	jae    c0100e15 <irq_in_kernel>
c0100e0d:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0100e12:	8b 60 04             	mov    0x4(%eax),%esp

c0100e15 <irq_in_kernel>:
c0100e15:	53                   	push   %ebx
c0100e16:	e8 95 fe ff ff       	call   c0100cb0 <irq_handle>
c0100e1b:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0100e20:	89 20                	mov    %esp,(%eax)
c0100e22:	e8 29 05 00 00       	call   c0101350 <schedule>
c0100e27:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0100e2c:	8b 20                	mov    (%eax),%esp
c0100e2e:	5c                   	pop    %esp
c0100e2f:	61                   	popa   
c0100e30:	83 c4 04             	add    $0x4,%esp
c0100e33:	c7 05 60 55 10 c0 00 	movl   $0x0,0xc0105560
c0100e3a:	00 00 00 
c0100e3d:	cf                   	iret   

c0100e3e <asm_do_int>:
c0100e3e:	60                   	pusha  
c0100e3f:	89 e3                	mov    %esp,%ebx
c0100e41:	81 fc 00 00 00 c0    	cmp    $0xc0000000,%esp
c0100e47:	73 08                	jae    c0100e51 <int_in_kernel>
c0100e49:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0100e4e:	8b 60 04             	mov    0x4(%eax),%esp

c0100e51 <int_in_kernel>:
c0100e51:	53                   	push   %ebx
c0100e52:	e8 c9 fe ff ff       	call   c0100d20 <int_handle>
c0100e57:	fa                   	cli    
c0100e58:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0100e5d:	89 20                	mov    %esp,(%eax)
c0100e5f:	e8 ec 04 00 00       	call   c0101350 <schedule>
c0100e64:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0100e69:	8b 20                	mov    (%eax),%esp
c0100e6b:	5c                   	pop    %esp
c0100e6c:	61                   	popa   
c0100e6d:	83 c4 04             	add    $0x4,%esp
c0100e70:	cf                   	iret   
c0100e71:	90                   	nop
c0100e72:	90                   	nop
c0100e73:	90                   	nop
c0100e74:	90                   	nop
c0100e75:	90                   	nop
c0100e76:	90                   	nop
c0100e77:	90                   	nop
c0100e78:	90                   	nop
c0100e79:	90                   	nop
c0100e7a:	90                   	nop
c0100e7b:	90                   	nop
c0100e7c:	90                   	nop
c0100e7d:	90                   	nop
c0100e7e:	90                   	nop
c0100e7f:	90                   	nop

c0100e80 <Find_Empty_PCB>:

int Find_Empty_PCB() {
	int i;
	for (i = 1; i < MAX_PROC; ++ i)
		if (Proc[i].flag == TRUE) return i;
	return PROC_FULL;
c0100e80:	ba 10 00 14 c0       	mov    $0xc0140010,%edx



int Find_Empty_PCB() {
	int i;
	for (i = 1; i < MAX_PROC; ++ i)
c0100e85:	b8 01 00 00 00       	mov    $0x1,%eax
c0100e8a:	eb 12                	jmp    c0100e9e <Find_Empty_PCB+0x1e>
c0100e8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0100e90:	83 c0 01             	add    $0x1,%eax
c0100e93:	81 c2 00 50 00 00    	add    $0x5000,%edx
c0100e99:	83 f8 20             	cmp    $0x20,%eax
c0100e9c:	74 0a                	je     c0100ea8 <Find_Empty_PCB+0x28>
		if (Proc[i].flag == TRUE) return i;
c0100e9e:	80 3a 01             	cmpb   $0x1,(%edx)
c0100ea1:	75 ed                	jne    c0100e90 <Find_Empty_PCB+0x10>
	return PROC_FULL;

}
c0100ea3:	f3 c3                	repz ret 
c0100ea5:	8d 76 00             	lea    0x0(%esi),%esi

int Find_Empty_PCB() {
	int i;
	for (i = 1; i < MAX_PROC; ++ i)
		if (Proc[i].flag == TRUE) return i;
	return PROC_FULL;
c0100ea8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0100ead:	8d 76 00             	lea    0x0(%esi),%esi

}
c0100eb0:	c3                   	ret    
c0100eb1:	eb 0d                	jmp    c0100ec0 <fetch_pcb>
c0100eb3:	90                   	nop
c0100eb4:	90                   	nop
c0100eb5:	90                   	nop
c0100eb6:	90                   	nop
c0100eb7:	90                   	nop
c0100eb8:	90                   	nop
c0100eb9:	90                   	nop
c0100eba:	90                   	nop
c0100ebb:	90                   	nop
c0100ebc:	90                   	nop
c0100ebd:	90                   	nop
c0100ebe:	90                   	nop
c0100ebf:	90                   	nop

c0100ec0 <fetch_pcb>:



struct PCB* fetch_pcb(pid_t pid) {
c0100ec0:	8b 44 24 04          	mov    0x4(%esp),%eax
	return (Proc + pid);
c0100ec4:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0100ec7:	c1 e0 0c             	shl    $0xc,%eax
c0100eca:	05 00 90 13 c0       	add    $0xc0139000,%eax
}
c0100ecf:	c3                   	ret    

c0100ed0 <copy_from_kernel>:


void copy_from_kernel(struct PCB *pcb, void *dest, void *src, int length) {
c0100ed0:	55                   	push   %ebp
c0100ed1:	57                   	push   %edi
c0100ed2:	56                   	push   %esi
c0100ed3:	53                   	push   %ebx
c0100ed4:	83 ec 08             	sub    $0x8,%esp
c0100ed7:	8b 44 24 20          	mov    0x20(%esp),%eax
c0100edb:	8b 54 24 28          	mov    0x28(%esp),%edx
c0100edf:	8b 4c 24 24          	mov    0x24(%esp),%ecx
	uint_32 pde = ((uint_32)dest) >> 22;
c0100ee3:	89 c3                	mov    %eax,%ebx
c0100ee5:	c1 eb 16             	shr    $0x16,%ebx
c0100ee8:	89 1c 24             	mov    %ebx,(%esp)
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent;

	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
c0100eeb:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c0100eef:	8b 34 24             	mov    (%esp),%esi
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent;

	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
c0100ef2:	8b 9b 18 20 00 00    	mov    0x2018(%ebx),%ebx
c0100ef8:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c0100efe:	89 5c 24 04          	mov    %ebx,0x4(%esp)
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c0100f02:	8b 2c b3             	mov    (%ebx,%esi,4),%ebp
c0100f05:	c1 ed 0c             	shr    $0xc,%ebp

	while (length != 0)
c0100f08:	85 d2                	test   %edx,%edx
c0100f0a:	74 6f                	je     c0100f7b <copy_from_kernel+0xab>
}


void copy_from_kernel(struct PCB *pcb, void *dest, void *src, int length) {
	uint_32 pde = ((uint_32)dest) >> 22;
	uint_32 pte = (((uint_32)dest) >> 12) & 0x3FF;
c0100f0c:	89 c7                	mov    %eax,%edi
	uint_32 pa = ((uint_32)dest) & 0xFFF;
c0100f0e:	25 ff 0f 00 00       	and    $0xfff,%eax
}


void copy_from_kernel(struct PCB *pcb, void *dest, void *src, int length) {
	uint_32 pde = ((uint_32)dest) >> 22;
	uint_32 pte = (((uint_32)dest) >> 12) & 0x3FF;
c0100f13:	c1 ef 0c             	shr    $0xc,%edi
c0100f16:	81 e7 ff 03 00 00    	and    $0x3ff,%edi
	struct PageTableEntry		*pent;

	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c0100f1c:	c1 e5 0c             	shl    $0xc,%ebp
c0100f1f:	90                   	nop

	while (length != 0)
	{
		ptr = (void *)(((pent + pte) -> page_frame) << 12);
c0100f20:	8b 74 bd 00          	mov    0x0(%ebp,%edi,4),%esi
c0100f24:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c0100f2a:	eb 0e                	jmp    c0100f3a <copy_from_kernel+0x6a>
c0100f2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

		while (pa < PAGE_SIZE)
		{
			*((uint_8 *)ptr + (pa ++)) = *(uint_8 *)(src ++);
c0100f30:	83 c0 01             	add    $0x1,%eax

	while (length != 0)
	{
		ptr = (void *)(((pent + pte) -> page_frame) << 12);

		while (pa < PAGE_SIZE)
c0100f33:	3d 00 10 00 00       	cmp    $0x1000,%eax
c0100f38:	74 0e                	je     c0100f48 <copy_from_kernel+0x78>
		{
			*((uint_8 *)ptr + (pa ++)) = *(uint_8 *)(src ++);
c0100f3a:	0f b6 19             	movzbl (%ecx),%ebx
c0100f3d:	83 c1 01             	add    $0x1,%ecx
			-- length;
			if (length == 0) break;
c0100f40:	83 ea 01             	sub    $0x1,%edx
	{
		ptr = (void *)(((pent + pte) -> page_frame) << 12);

		while (pa < PAGE_SIZE)
		{
			*((uint_8 *)ptr + (pa ++)) = *(uint_8 *)(src ++);
c0100f43:	88 1c 30             	mov    %bl,(%eax,%esi,1)
			-- length;
			if (length == 0) break;
c0100f46:	75 e8                	jne    c0100f30 <copy_from_kernel+0x60>
		}
		pa = 0;
		++ pte;
c0100f48:	83 c7 01             	add    $0x1,%edi
		if (pte == NR_PTE_ENTRY)
c0100f4b:	81 ff 00 04 00 00    	cmp    $0x400,%edi
c0100f51:	74 0d                	je     c0100f60 <copy_from_kernel+0x90>
	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);

	while (length != 0)
c0100f53:	85 d2                	test   %edx,%edx
c0100f55:	74 24                	je     c0100f7b <copy_from_kernel+0xab>
c0100f57:	31 c0                	xor    %eax,%eax
c0100f59:	eb c5                	jmp    c0100f20 <copy_from_kernel+0x50>
c0100f5b:	90                   	nop
c0100f5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		pa = 0;
		++ pte;
		if (pte == NR_PTE_ENTRY)
		{
			pte = 0;
			++ pde;
c0100f60:	83 04 24 01          	addl   $0x1,(%esp)
		}
		pa = 0;
		++ pte;
		if (pte == NR_PTE_ENTRY)
		{
			pte = 0;
c0100f64:	66 31 ff             	xor    %di,%di
			++ pde;
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c0100f67:	8b 04 24             	mov    (%esp),%eax
c0100f6a:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c0100f6e:	8b 2c 83             	mov    (%ebx,%eax,4),%ebp
c0100f71:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);

	while (length != 0)
c0100f77:	85 d2                	test   %edx,%edx
c0100f79:	75 dc                	jne    c0100f57 <copy_from_kernel+0x87>
			++ pde;
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
		}

	}
}
c0100f7b:	83 c4 08             	add    $0x8,%esp
c0100f7e:	5b                   	pop    %ebx
c0100f7f:	5e                   	pop    %esi
c0100f80:	5f                   	pop    %edi
c0100f81:	5d                   	pop    %ebp
c0100f82:	c3                   	ret    
c0100f83:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c0100f89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0100f90 <copy_to_kernel>:

void copy_to_kernel(struct PCB *pcb, void *dest, void *src, int length) {
c0100f90:	55                   	push   %ebp
c0100f91:	57                   	push   %edi
c0100f92:	56                   	push   %esi
c0100f93:	53                   	push   %ebx
c0100f94:	83 ec 08             	sub    $0x8,%esp
c0100f97:	8b 44 24 24          	mov    0x24(%esp),%eax
c0100f9b:	8b 54 24 28          	mov    0x28(%esp),%edx
c0100f9f:	8b 4c 24 20          	mov    0x20(%esp),%ecx
	uint_32 pde = ((uint_32)src) >> 22;
c0100fa3:	89 c3                	mov    %eax,%ebx
c0100fa5:	c1 eb 16             	shr    $0x16,%ebx
c0100fa8:	89 1c 24             	mov    %ebx,(%esp)
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent;

	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
c0100fab:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c0100faf:	8b 34 24             	mov    (%esp),%esi
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent;

	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
c0100fb2:	8b 9b 18 20 00 00    	mov    0x2018(%ebx),%ebx
c0100fb8:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
c0100fbe:	89 5c 24 04          	mov    %ebx,0x4(%esp)
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c0100fc2:	8b 2c b3             	mov    (%ebx,%esi,4),%ebp
c0100fc5:	c1 ed 0c             	shr    $0xc,%ebp

	while (length != 0)
c0100fc8:	85 d2                	test   %edx,%edx
c0100fca:	74 6f                	je     c010103b <copy_to_kernel+0xab>
	}
}

void copy_to_kernel(struct PCB *pcb, void *dest, void *src, int length) {
	uint_32 pde = ((uint_32)src) >> 22;
	uint_32 pte = (((uint_32)src) >> 12) & 0x3FF;
c0100fcc:	89 c7                	mov    %eax,%edi
	uint_32 pa = ((uint_32)src) & 0xFFF;
c0100fce:	25 ff 0f 00 00       	and    $0xfff,%eax
	}
}

void copy_to_kernel(struct PCB *pcb, void *dest, void *src, int length) {
	uint_32 pde = ((uint_32)src) >> 22;
	uint_32 pte = (((uint_32)src) >> 12) & 0x3FF;
c0100fd3:	c1 ef 0c             	shr    $0xc,%edi
c0100fd6:	81 e7 ff 03 00 00    	and    $0x3ff,%edi
	struct PageTableEntry		*pent;

	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c0100fdc:	c1 e5 0c             	shl    $0xc,%ebp
c0100fdf:	90                   	nop

	while (length != 0)
	{
		ptr = (void *)(((pent + pte) -> page_frame) << 12);
c0100fe0:	8b 74 bd 00          	mov    0x0(%ebp,%edi,4),%esi
c0100fe4:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c0100fea:	eb 0e                	jmp    c0100ffa <copy_to_kernel+0x6a>
c0100fec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

		while (pa < PAGE_SIZE)
		{
			*(uint_8 *)(dest ++) = *((uint_8 *)ptr + (pa ++));
c0100ff0:	83 c0 01             	add    $0x1,%eax

	while (length != 0)
	{
		ptr = (void *)(((pent + pte) -> page_frame) << 12);

		while (pa < PAGE_SIZE)
c0100ff3:	3d 00 10 00 00       	cmp    $0x1000,%eax
c0100ff8:	74 0e                	je     c0101008 <copy_to_kernel+0x78>
		{
			*(uint_8 *)(dest ++) = *((uint_8 *)ptr + (pa ++));
c0100ffa:	0f b6 1c 30          	movzbl (%eax,%esi,1),%ebx
c0100ffe:	88 19                	mov    %bl,(%ecx)
c0101000:	83 c1 01             	add    $0x1,%ecx
			-- length;
			if (length == 0) break;
c0101003:	83 ea 01             	sub    $0x1,%edx
c0101006:	75 e8                	jne    c0100ff0 <copy_to_kernel+0x60>
		}
		pa = 0;
		++ pte;
c0101008:	83 c7 01             	add    $0x1,%edi
		if (pte == NR_PTE_ENTRY)
c010100b:	81 ff 00 04 00 00    	cmp    $0x400,%edi
c0101011:	74 0d                	je     c0101020 <copy_to_kernel+0x90>
	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);

	while (length != 0)
c0101013:	85 d2                	test   %edx,%edx
c0101015:	74 24                	je     c010103b <copy_to_kernel+0xab>
c0101017:	31 c0                	xor    %eax,%eax
c0101019:	eb c5                	jmp    c0100fe0 <copy_to_kernel+0x50>
c010101b:	90                   	nop
c010101c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		pa = 0;
		++ pte;
		if (pte == NR_PTE_ENTRY)
		{
			pte = 0;
			++ pde;
c0101020:	83 04 24 01          	addl   $0x1,(%esp)
		}
		pa = 0;
		++ pte;
		if (pte == NR_PTE_ENTRY)
		{
			pte = 0;
c0101024:	66 31 ff             	xor    %di,%di
			++ pde;
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c0101027:	8b 04 24             	mov    (%esp),%eax
c010102a:	8b 5c 24 04          	mov    0x4(%esp),%ebx
c010102e:	8b 2c 83             	mov    (%ebx,%eax,4),%ebp
c0101031:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);

	while (length != 0)
c0101037:	85 d2                	test   %edx,%edx
c0101039:	75 dc                	jne    c0101017 <copy_to_kernel+0x87>
			++ pde;
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
		}

	}
}
c010103b:	83 c4 08             	add    $0x8,%esp
c010103e:	5b                   	pop    %ebx
c010103f:	5e                   	pop    %esi
c0101040:	5f                   	pop    %edi
c0101041:	5d                   	pop    %ebp
c0101042:	c3                   	ret    
c0101043:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c0101049:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0101050 <init_message_pool>:

struct PCB *init;

//struct PCB *preempt_proc = NULL;

void init_message_pool(struct PCB *ptr) {
c0101050:	83 ec 1c             	sub    $0x1c,%esp
c0101053:	31 c0                	xor    %eax,%eax
c0101055:	8b 54 24 20          	mov    0x20(%esp),%edx
c0101059:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
		(ptr -> Msg_rec_Pool[i]).flag = TRUE;
c0101060:	c6 84 02 14 21 00 00 	movb   $0x1,0x2114(%edx,%eax,1)
c0101067:	01 
c0101068:	83 c0 28             	add    $0x28,%eax
//struct PCB *preempt_proc = NULL;

void init_message_pool(struct PCB *ptr) {

	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
c010106b:	3d 00 14 00 00       	cmp    $0x1400,%eax
c0101070:	75 ee                	jne    c0101060 <init_message_pool+0x10>
		(ptr -> Msg_rec_Pool[i]).flag = TRUE;
	ptr -> Msg_rec = NULL;
c0101072:	c7 82 f0 34 00 00 00 	movl   $0x0,0x34f0(%edx)
c0101079:	00 00 00 
	ptr -> Msg_ign = NULL;
c010107c:	c7 82 f4 34 00 00 00 	movl   $0x0,0x34f4(%edx)
c0101083:	00 00 00 
	Sem_init(&(ptr -> Msg_lock), 0);
c0101086:	81 c2 20 20 00 00    	add    $0x2020,%edx
c010108c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0101093:	00 
c0101094:	89 14 24             	mov    %edx,(%esp)
c0101097:	e8 54 05 00 00       	call   c01015f0 <Sem_init>
}
c010109c:	83 c4 1c             	add    $0x1c,%esp
c010109f:	c3                   	ret    

c01010a0 <Push_Stack_4Byte>:


void Push_Stack_4Byte(uint_8 **Addr, uint_32 Key) {
c01010a0:	8b 44 24 04          	mov    0x4(%esp),%eax
	*((uint_32 *)(*Addr)) = Key;	
c01010a4:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c01010a8:	8b 10                	mov    (%eax),%edx
c01010aa:	89 0a                	mov    %ecx,(%edx)
	*Addr -= 4;
c01010ac:	83 28 04             	subl   $0x4,(%eax)
}
c01010af:	c3                   	ret    

c01010b0 <Create_kthread>:


void Create_kthread(void (*thread)(void)) {
c01010b0:	56                   	push   %esi

int Find_Empty_PCB() {
	int i;
	for (i = 1; i < MAX_PROC; ++ i)
		if (Proc[i].flag == TRUE) return i;
	return PROC_FULL;
c01010b1:	ba 10 00 14 c0       	mov    $0xc0140010,%edx
	*((uint_32 *)(*Addr)) = Key;	
	*Addr -= 4;
}


void Create_kthread(void (*thread)(void)) {
c01010b6:	53                   	push   %ebx



int Find_Empty_PCB() {
	int i;
	for (i = 1; i < MAX_PROC; ++ i)
c01010b7:	b8 01 00 00 00       	mov    $0x1,%eax
	*((uint_32 *)(*Addr)) = Key;	
	*Addr -= 4;
}


void Create_kthread(void (*thread)(void)) {
c01010bc:	83 ec 14             	sub    $0x14,%esp
c01010bf:	eb 19                	jmp    c01010da <Create_kthread+0x2a>
c01010c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi



int Find_Empty_PCB() {
	int i;
	for (i = 1; i < MAX_PROC; ++ i)
c01010c8:	83 c0 01             	add    $0x1,%eax
c01010cb:	81 c2 00 50 00 00    	add    $0x5000,%edx
c01010d1:	83 f8 20             	cmp    $0x20,%eax
c01010d4:	0f 84 ce 00 00 00    	je     c01011a8 <Create_kthread+0xf8>
		if (Proc[i].flag == TRUE) return i;
c01010da:	80 3a 01             	cmpb   $0x1,(%edx)
c01010dd:	75 e9                	jne    c01010c8 <Create_kthread+0x18>



int Find_Empty_PCB() {
	int i;
	for (i = 1; i < MAX_PROC; ++ i)
c01010df:	89 c2                	mov    %eax,%edx
void Create_kthread(void (*thread)(void)) {
	int new = Find_Empty_PCB();
	if (new == PROC_FULL)
		panic("Process Table is Full!\n");

	struct PCB *new_pcb = Proc + new; 
c01010e1:	8d 34 92             	lea    (%edx,%edx,4),%esi
	new_pcb -> next = init;
c01010e4:	8b 15 00 90 1d c0    	mov    0xc01d9000,%edx
void Create_kthread(void (*thread)(void)) {
	int new = Find_Empty_PCB();
	if (new == PROC_FULL)
		panic("Process Table is Full!\n");

	struct PCB *new_pcb = Proc + new; 
c01010ea:	c1 e6 0c             	shl    $0xc,%esi
c01010ed:	8d 9e 00 90 13 c0    	lea    -0x3fec7000(%esi),%ebx
	new_pcb -> next = init;
c01010f3:	89 96 08 b0 13 c0    	mov    %edx,-0x3fec4ff8(%esi)
	new_pcb -> prev = init -> prev;
c01010f9:	8b 8a 0c 20 00 00    	mov    0x200c(%edx),%ecx
c01010ff:	89 8e 0c b0 13 c0    	mov    %ecx,-0x3fec4ff4(%esi)
	init -> prev -> next = new_pcb;
c0101105:	8b 8a 0c 20 00 00    	mov    0x200c(%edx),%ecx
c010110b:	89 99 08 20 00 00    	mov    %ebx,0x2008(%ecx)
	init -> prev = new_pcb;
c0101111:	89 9a 0c 20 00 00    	mov    %ebx,0x200c(%edx)


	//Initialize

	new_pcb -> status = STATUS_WAITING;
	new_pcb -> pid = new;
c0101117:	89 86 1c b0 13 c0    	mov    %eax,-0x3fec4fe4(%esi)

	new_pcb -> time_elapsed = 0;


	*(uint_32 *)&(new_pcb -> cr3) = 0;
	(new_pcb -> cr3).page_directory_base = ((uint_32)va_to_pa(kpagedir)) >> 12;
c010111d:	b8 00 70 13 00       	mov    $0x137000,%eax
c0101122:	25 00 f0 ff ff       	and    $0xfffff000,%eax


	init_message_pool(new_pcb);
c0101127:	89 1c 24             	mov    %ebx,(%esp)
	*((uint_32 *)(*Addr)) = Key;	
	*Addr -= 4;
}


void Create_kthread(void (*thread)(void)) {
c010112a:	8d 9e d4 af 13 c0    	lea    -0x3fec502c(%esi),%ebx

	new_pcb -> time_elapsed = 0;


	*(uint_32 *)&(new_pcb -> cr3) = 0;
	(new_pcb -> cr3).page_directory_base = ((uint_32)va_to_pa(kpagedir)) >> 12;
c0101130:	89 86 18 b0 13 c0    	mov    %eax,-0x3fec4fe8(%esi)



	//Initialize

	new_pcb -> status = STATUS_WAITING;
c0101136:	c7 86 14 b0 13 c0 00 	movl   $0x0,-0x3fec4fec(%esi)
c010113d:	00 00 00 
	new_pcb -> pid = new;
	new_pcb -> flag = FALSE;
c0101140:	c6 86 10 b0 13 c0 00 	movb   $0x0,-0x3fec4ff0(%esi)

	new_pcb -> time_elapsed = 0;
c0101147:	c7 86 f8 c4 13 c0 00 	movl   $0x0,-0x3fec3b08(%esi)
c010114e:	00 00 00 

	*(uint_32 *)&(new_pcb -> cr3) = 0;
	(new_pcb -> cr3).page_directory_base = ((uint_32)va_to_pa(kpagedir)) >> 12;


	init_message_pool(new_pcb);
c0101151:	e8 fa fe ff ff       	call   c0101050 <init_message_pool>
	Sem_init(&(ptr -> Msg_lock), 0);
}


void Push_Stack_4Byte(uint_8 **Addr, uint_32 Key) {
	*((uint_32 *)(*Addr)) = Key;	
c0101156:	8b 44 24 20          	mov    0x20(%esp),%eax


	init_message_pool(new_pcb);

	//printk("kernel stack : %x\n", new_pcb -> kstack);
	uint_8 *stack_ptr = (uint_8 *)((uint_32)(new_pcb -> kstack) + STACK_SIZE - 4);
c010115a:	8d 96 04 b0 13 c0    	lea    -0x3fec4ffc(%esi),%edx
	Sem_init(&(ptr -> Msg_lock), 0);
}


void Push_Stack_4Byte(uint_8 **Addr, uint_32 Key) {
	*((uint_32 *)(*Addr)) = Key;	
c0101160:	c7 86 04 b0 13 c0 00 	movl   $0x200,-0x3fec4ffc(%esi)
c0101167:	02 00 00 
c010116a:	c7 42 fc 08 00 00 00 	movl   $0x8,-0x4(%edx)
c0101171:	89 42 f8             	mov    %eax,-0x8(%edx)
	*Addr -= 4;
c0101174:	8d 86 f8 af 13 c0    	lea    -0x3fec5008(%esi),%eax
c010117a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	Sem_init(&(ptr -> Msg_lock), 0);
}


void Push_Stack_4Byte(uint_8 **Addr, uint_32 Key) {
	*((uint_32 *)(*Addr)) = Key;	
c0101180:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	*Addr -= 4;
}


void Create_kthread(void (*thread)(void)) {
c0101186:	83 e8 04             	sub    $0x4,%eax
	Push_Stack_4Byte(&stack_ptr, key);
	
	//TrapFrame
	uint_32 i;
	key = 0;
	for (i = 0; i < 9; ++ i)
c0101189:	39 c3                	cmp    %eax,%ebx
c010118b:	75 f3                	jne    c0101180 <Create_kthread+0xd0>
c010118d:	8d 42 d0             	lea    -0x30(%edx),%eax
		Push_Stack_4Byte(&stack_ptr, key);

	//%esp & PCB -> esp
	new_pcb -> esp = (void *)((uint_32)stack_ptr);
c0101190:	89 86 00 90 13 c0    	mov    %eax,-0x3fec7000(%esi)
	Push_Stack_4Byte(&stack_ptr, (uint_32)stack_ptr + 4);
c0101196:	8d 42 d4             	lea    -0x2c(%edx),%eax
c0101199:	89 42 d0             	mov    %eax,-0x30(%edx)
	struct TrapFrame tf;
	uint_32 eip;
	uint_32 cs;
	struct EFLAGS eflags;
	*/
}
c010119c:	83 c4 14             	add    $0x14,%esp
c010119f:	5b                   	pop    %ebx
c01011a0:	5e                   	pop    %esi
c01011a1:	c3                   	ret    
c01011a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi


void Create_kthread(void (*thread)(void)) {
	int new = Find_Empty_PCB();
	if (new == PROC_FULL)
		panic("Process Table is Full!\n");
c01011a8:	c7 04 24 1d 35 10 c0 	movl   $0xc010351d,(%esp)
c01011af:	e8 0c f2 ff ff       	call   c01003c0 <panic>
c01011b4:	ba ff ff ff ff       	mov    $0xffffffff,%edx

int Find_Empty_PCB() {
	int i;
	for (i = 1; i < MAX_PROC; ++ i)
		if (Proc[i].flag == TRUE) return i;
	return PROC_FULL;
c01011b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c01011be:	e9 1e ff ff ff       	jmp    c01010e1 <Create_kthread+0x31>
c01011c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c01011c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c01011d0 <init_proc>:
	*/
}

struct PCB *current_pcb;

void init_proc() {
c01011d0:	53                   	push   %ebx
c01011d1:	83 ec 18             	sub    $0x18,%esp
	init -> next = init -> prev = init;
	init -> flag = FALSE;
	init -> pid = 0;
	init -> status = STATUS_WAITING;
	init -> time_elapsed = 0;
	init_message_pool(init);
c01011d4:	c7 04 24 00 90 13 c0 	movl   $0xc0139000,(%esp)

void init_proc() {

	int i;

	init = Proc;			//Proc[0] --> init
c01011db:	c7 05 00 90 1d c0 00 	movl   $0xc0139000,0xc01d9000
c01011e2:	90 13 c0 
	init -> next = init -> prev = init;
c01011e5:	c7 05 0c b0 13 c0 00 	movl   $0xc0139000,0xc013b00c
c01011ec:	90 13 c0 
c01011ef:	c7 05 08 b0 13 c0 00 	movl   $0xc0139000,0xc013b008
c01011f6:	90 13 c0 
	init -> flag = FALSE;
c01011f9:	c6 05 10 b0 13 c0 00 	movb   $0x0,0xc013b010
	init -> pid = 0;
c0101200:	c7 05 1c b0 13 c0 00 	movl   $0x0,0xc013b01c
c0101207:	00 00 00 
	init -> status = STATUS_WAITING;
c010120a:	c7 05 14 b0 13 c0 00 	movl   $0x0,0xc013b014
c0101211:	00 00 00 
	init -> time_elapsed = 0;
c0101214:	c7 05 f8 c4 13 c0 00 	movl   $0x0,0xc013c4f8
c010121b:	00 00 00 
	init_message_pool(init);
c010121e:	e8 2d fe ff ff       	call   c0101050 <init_message_pool>

	*(uint_32*)&(init -> cr3) = 0;
	(init -> cr3).page_directory_base = ((uint_32)va_to_pa(kpagedir)) >> 12;
c0101223:	8b 15 00 90 1d c0    	mov    0xc01d9000,%edx
c0101229:	b8 00 70 13 00       	mov    $0x137000,%eax
c010122e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0101233:	89 82 18 20 00 00    	mov    %eax,0x2018(%edx)
c0101239:	b8 10 00 14 c0       	mov    $0xc0140010,%eax
c010123e:	66 90                	xchg   %ax,%ax
	

	for (i = 1; i < MAX_PROC; ++ i)
		Proc[i].flag = 1;
c0101240:	c6 00 01             	movb   $0x1,(%eax)
c0101243:	05 00 50 00 00       	add    $0x5000,%eax

	*(uint_32*)&(init -> cr3) = 0;
	(init -> cr3).page_directory_base = ((uint_32)va_to_pa(kpagedir)) >> 12;
	

	for (i = 1; i < MAX_PROC; ++ i)
c0101248:	3d 10 b0 1d c0       	cmp    $0xc01db010,%eax
c010124d:	75 f1                	jne    c0101240 <init_proc+0x70>
		Proc[i].flag = 1;


	Create_kthread(timer_driver_thread);
c010124f:	c7 04 24 90 1a 10 c0 	movl   $0xc0101a90,(%esp)
	Create_kthread(ProcessManagement);
	PM = 6;

	Create_kthread(test_ide);

			for (i = 0; i < 8; ++ i)
c0101256:	31 db                	xor    %ebx,%ebx

	for (i = 1; i < MAX_PROC; ++ i)
		Proc[i].flag = 1;


	Create_kthread(timer_driver_thread);
c0101258:	e8 53 fe ff ff       	call   c01010b0 <Create_kthread>
	TIMER = 1;
	Create_kthread(tty_driver_thread);
c010125d:	c7 04 24 d0 1c 10 c0 	movl   $0xc0101cd0,(%esp)
	for (i = 1; i < MAX_PROC; ++ i)
		Proc[i].flag = 1;


	Create_kthread(timer_driver_thread);
	TIMER = 1;
c0101264:	c7 05 c0 a6 1d c0 01 	movl   $0x1,0xc01da6c0
c010126b:	00 00 00 
	Create_kthread(tty_driver_thread);
c010126e:	e8 3d fe ff ff       	call   c01010b0 <Create_kthread>
	TTY = 2;
	Create_kthread(ide_driver_thread);
c0101273:	c7 04 24 70 24 10 c0 	movl   $0xc0102470,(%esp)


	Create_kthread(timer_driver_thread);
	TIMER = 1;
	Create_kthread(tty_driver_thread);
	TTY = 2;
c010127a:	c7 05 c4 a6 1d c0 02 	movl   $0x2,0xc01da6c4
c0101281:	00 00 00 
	Create_kthread(ide_driver_thread);
c0101284:	e8 27 fe ff ff       	call   c01010b0 <Create_kthread>
	IDE = 3;
	Create_kthread(FileManagement);
c0101289:	c7 04 24 90 26 10 c0 	movl   $0xc0102690,(%esp)
	Create_kthread(timer_driver_thread);
	TIMER = 1;
	Create_kthread(tty_driver_thread);
	TTY = 2;
	Create_kthread(ide_driver_thread);
	IDE = 3;
c0101290:	c7 05 c8 a6 1d c0 03 	movl   $0x3,0xc01da6c8
c0101297:	00 00 00 
	Create_kthread(FileManagement);
c010129a:	e8 11 fe ff ff       	call   c01010b0 <Create_kthread>
	FM = 4;
	Create_kthread(MemoryManagement);
c010129f:	c7 04 24 c0 2a 10 c0 	movl   $0xc0102ac0,(%esp)
	Create_kthread(tty_driver_thread);
	TTY = 2;
	Create_kthread(ide_driver_thread);
	IDE = 3;
	Create_kthread(FileManagement);
	FM = 4;
c01012a6:	c7 05 cc a6 1d c0 04 	movl   $0x4,0xc01da6cc
c01012ad:	00 00 00 
	Create_kthread(MemoryManagement);
c01012b0:	e8 fb fd ff ff       	call   c01010b0 <Create_kthread>
	MM = 5;
	Create_kthread(ProcessManagement);
c01012b5:	c7 04 24 d0 30 10 c0 	movl   $0xc01030d0,(%esp)
	Create_kthread(ide_driver_thread);
	IDE = 3;
	Create_kthread(FileManagement);
	FM = 4;
	Create_kthread(MemoryManagement);
	MM = 5;
c01012bc:	c7 05 e0 a6 1d c0 05 	movl   $0x5,0xc01da6e0
c01012c3:	00 00 00 
	Create_kthread(ProcessManagement);
c01012c6:	e8 e5 fd ff ff       	call   c01010b0 <Create_kthread>
	PM = 6;

	Create_kthread(test_ide);
c01012cb:	c7 04 24 30 34 10 c0 	movl   $0xc0103430,(%esp)
	Create_kthread(FileManagement);
	FM = 4;
	Create_kthread(MemoryManagement);
	MM = 5;
	Create_kthread(ProcessManagement);
	PM = 6;
c01012d2:	c7 05 00 17 1e c0 06 	movl   $0x6,0xc01e1700
c01012d9:	00 00 00 

	Create_kthread(test_ide);
c01012dc:	e8 cf fd ff ff       	call   c01010b0 <Create_kthread>
c01012e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

			for (i = 0; i < 8; ++ i)
				printk("Process %d, CR3 = %x\n", i, *((uint_32 *)(&((Proc + i) -> cr3))));
c01012e8:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
c01012eb:	c1 e0 0c             	shl    $0xc,%eax
c01012ee:	8b 80 18 b0 13 c0    	mov    -0x3fec4fe8(%eax),%eax
c01012f4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
	Create_kthread(ProcessManagement);
	PM = 6;

	Create_kthread(test_ide);

			for (i = 0; i < 8; ++ i)
c01012f8:	83 c3 01             	add    $0x1,%ebx
				printk("Process %d, CR3 = %x\n", i, *((uint_32 *)(&((Proc + i) -> cr3))));
c01012fb:	c7 04 24 35 35 10 c0 	movl   $0xc0103535,(%esp)
c0101302:	89 44 24 08          	mov    %eax,0x8(%esp)
c0101306:	e8 85 f0 ff ff       	call   c0100390 <printk>
	Create_kthread(ProcessManagement);
	PM = 6;

	Create_kthread(test_ide);

			for (i = 0; i < 8; ++ i)
c010130b:	83 fb 08             	cmp    $0x8,%ebx
c010130e:	75 d8                	jne    c01012e8 <init_proc+0x118>
				printk("Process %d, CR3 = %x\n", i, *((uint_32 *)(&((Proc + i) -> cr3))));
			printk("============================\n");
c0101310:	c7 04 24 4b 35 10 c0 	movl   $0xc010354b,(%esp)
c0101317:	e8 74 f0 ff ff       	call   c0100390 <printk>
	current_pcb = init;
c010131c:	a1 00 90 1d c0       	mov    0xc01d9000,%eax
c0101321:	a3 04 90 1d c0       	mov    %eax,0xc01d9004
}
c0101326:	83 c4 18             	add    $0x18,%esp
c0101329:	5b                   	pop    %ebx
c010132a:	c3                   	ret    
c010132b:	90                   	nop
c010132c:	90                   	nop
c010132d:	90                   	nop
c010132e:	90                   	nop
c010132f:	90                   	nop

c0101330 <find_next_live_process>:
	{
		p = preempt_proc;	
		preempt_proc = NULL;
	}
	else*/
	for (p = current_pcb -> next; p != NULL && p -> status != STATUS_WAITING; p = p -> next);
c0101330:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0101335:	eb 0b                	jmp    c0101342 <find_next_live_process+0x12>
c0101337:	90                   	nop
c0101338:	8b 90 14 20 00 00    	mov    0x2014(%eax),%edx
c010133e:	85 d2                	test   %edx,%edx
c0101340:	74 0a                	je     c010134c <find_next_live_process+0x1c>
c0101342:	8b 80 08 20 00 00    	mov    0x2008(%eax),%eax
c0101348:	85 c0                	test   %eax,%eax
c010134a:	75 ec                	jne    c0101338 <find_next_live_process+0x8>
	return p;
}
c010134c:	f3 c3                	repz ret 
c010134e:	66 90                	xchg   %ax,%ax

c0101350 <schedule>:

void schedule(void) {
c0101350:	53                   	push   %ebx
c0101351:	83 ec 18             	sub    $0x18,%esp
	//lock();
	if (need_sched)
c0101354:	80 3d e8 4b 10 c0 00 	cmpb   $0x0,0xc0104be8
c010135b:	0f 84 d8 00 00 00    	je     c0101439 <schedule+0xe9>
	{
		if (current_pcb -> status == STATUS_RUNNING)
c0101361:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0101366:	83 b8 14 20 00 00 01 	cmpl   $0x1,0x2014(%eax)
c010136d:	75 23                	jne    c0101392 <schedule+0x42>
			current_pcb -> status = STATUS_WAITING;
c010136f:	c7 80 14 20 00 00 00 	movl   $0x0,0x2014(%eax)
c0101376:	00 00 00 
	{
		p = preempt_proc;	
		preempt_proc = NULL;
	}
	else*/
	for (p = current_pcb -> next; p != NULL && p -> status != STATUS_WAITING; p = p -> next);
c0101379:	8b 80 08 20 00 00    	mov    0x2008(%eax),%eax
c010137f:	85 c0                	test   %eax,%eax
c0101381:	74 19                	je     c010139c <schedule+0x4c>
c0101383:	90                   	nop
c0101384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0101388:	8b 88 14 20 00 00    	mov    0x2014(%eax),%ecx
c010138e:	85 c9                	test   %ecx,%ecx
c0101390:	74 0a                	je     c010139c <schedule+0x4c>
c0101392:	8b 80 08 20 00 00    	mov    0x2008(%eax),%eax
c0101398:	85 c0                	test   %eax,%eax
c010139a:	75 ec                	jne    c0101388 <schedule+0x38>
	{
		if (current_pcb -> status == STATUS_RUNNING)
			current_pcb -> status = STATUS_WAITING;
		current_pcb = find_next_live_process();
	//	printk("%d\n", current_pcb -> pid);
		current_pcb -> status = STATUS_RUNNING;
c010139c:	c7 80 14 20 00 00 01 	movl   $0x1,0x2014(%eax)
c01013a3:	00 00 00 
	//lock();
	if (need_sched)
	{
		if (current_pcb -> status == STATUS_RUNNING)
			current_pcb -> status = STATUS_WAITING;
		current_pcb = find_next_live_process();
c01013a6:	a3 04 90 1d c0       	mov    %eax,0xc01d9004
	//	printk("%d\n", current_pcb -> pid);
		current_pcb -> status = STATUS_RUNNING;
		printk("Next PCB = %d\n", current_pcb -> pid);
c01013ab:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c01013b1:	c7 04 24 69 35 10 c0 	movl   $0xc0103569,(%esp)
c01013b8:	89 44 24 04          	mov    %eax,0x4(%esp)
c01013bc:	e8 cf ef ff ff       	call   c0100390 <printk>
		printk("CR3 = %x\n", *((uint_32 *)(&(current_pcb -> cr3))));
c01013c1:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c01013c6:	8b 80 18 20 00 00    	mov    0x2018(%eax),%eax
c01013cc:	c7 04 24 41 35 10 c0 	movl   $0xc0103541,(%esp)
c01013d3:	89 44 24 04          	mov    %eax,0x4(%esp)
c01013d7:	e8 b4 ef ff ff       	call   c0100390 <printk>
		//save_cr3(&(current_pcb -> cr3));
		if (*((uint_32 *)&(Proc[6].cr3)) < 1000) 
c01013dc:	81 3d 18 90 15 c0 e7 	cmpl   $0x3e7,0xc0159018
c01013e3:	03 00 00 
c01013e6:	77 3c                	ja     c0101424 <schedule+0xd4>
c01013e8:	31 db                	xor    %ebx,%ebx
c01013ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		{
			int i;
			for (i = 0; i < 8; ++ i)
				printk("Process %d, CR3 = %x\n", i, *((uint_32 *)(&((Proc + i) -> cr3))));
c01013f0:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
c01013f3:	c1 e0 0c             	shl    $0xc,%eax
c01013f6:	8b 80 18 b0 13 c0    	mov    -0x3fec4fe8(%eax),%eax
c01013fc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
		printk("CR3 = %x\n", *((uint_32 *)(&(current_pcb -> cr3))));
		//save_cr3(&(current_pcb -> cr3));
		if (*((uint_32 *)&(Proc[6].cr3)) < 1000) 
		{
			int i;
			for (i = 0; i < 8; ++ i)
c0101400:	83 c3 01             	add    $0x1,%ebx
				printk("Process %d, CR3 = %x\n", i, *((uint_32 *)(&((Proc + i) -> cr3))));
c0101403:	c7 04 24 35 35 10 c0 	movl   $0xc0103535,(%esp)
c010140a:	89 44 24 08          	mov    %eax,0x8(%esp)
c010140e:	e8 7d ef ff ff       	call   c0100390 <printk>
		printk("CR3 = %x\n", *((uint_32 *)(&(current_pcb -> cr3))));
		//save_cr3(&(current_pcb -> cr3));
		if (*((uint_32 *)&(Proc[6].cr3)) < 1000) 
		{
			int i;
			for (i = 0; i < 8; ++ i)
c0101413:	83 fb 08             	cmp    $0x8,%ebx
c0101416:	75 d8                	jne    c01013f0 <schedule+0xa0>
				printk("Process %d, CR3 = %x\n", i, *((uint_32 *)(&((Proc + i) -> cr3))));
				
			panic("why, why?\n");
c0101418:	c7 04 24 78 35 10 c0 	movl   $0xc0103578,(%esp)
c010141f:	e8 9c ef ff ff       	call   c01003c0 <panic>
		}
		asm volatile ("movl %0, %%cr3" : : "r"(*((uint_32 *)(&(current_pcb -> cr3)))));
c0101424:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
		need_sched = FALSE;
c0101429:	c6 05 e8 4b 10 c0 00 	movb   $0x0,0xc0104be8
			for (i = 0; i < 8; ++ i)
				printk("Process %d, CR3 = %x\n", i, *((uint_32 *)(&((Proc + i) -> cr3))));
				
			panic("why, why?\n");
		}
		asm volatile ("movl %0, %%cr3" : : "r"(*((uint_32 *)(&(current_pcb -> cr3)))));
c0101430:	8b 80 18 20 00 00    	mov    0x2018(%eax),%eax
c0101436:	0f 22 d8             	mov    %eax,%cr3
		need_sched = FALSE;
	}
	//unlock();
}
c0101439:	83 c4 18             	add    $0x18,%esp
c010143c:	5b                   	pop    %ebx
c010143d:	c3                   	ret    
c010143e:	90                   	nop
c010143f:	90                   	nop

c0101440 <process_A>:
#include "kernel.h"

void process_A(void) {
c0101440:	83 ec 1c             	sub    $0x1c,%esp
c0101443:	90                   	nop
c0101444:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	while (1)
		printk("A");
c0101448:	c7 04 24 83 35 10 c0 	movl   $0xc0103583,(%esp)
c010144f:	e8 3c ef ff ff       	call   c0100390 <printk>
c0101454:	eb f2                	jmp    c0101448 <process_A+0x8>
c0101456:	8d 76 00             	lea    0x0(%esi),%esi
c0101459:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0101460 <process_B>:
}


void process_B(void) {
c0101460:	83 ec 1c             	sub    $0x1c,%esp
c0101463:	90                   	nop
c0101464:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	while (1)
		printk("B");
c0101468:	c7 04 24 85 35 10 c0 	movl   $0xc0103585,(%esp)
c010146f:	e8 1c ef ff ff       	call   c0100390 <printk>
c0101474:	eb f2                	jmp    c0101468 <process_B+0x8>
c0101476:	8d 76 00             	lea    0x0(%esi),%esi
c0101479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0101480 <process_C>:
}

void process_C(void) {
c0101480:	83 ec 1c             	sub    $0x1c,%esp
c0101483:	90                   	nop
c0101484:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	while (1)
		printk("C");
c0101488:	c7 04 24 87 35 10 c0 	movl   $0xc0103587,(%esp)
c010148f:	e8 fc ee ff ff       	call   c0100390 <printk>
c0101494:	eb f2                	jmp    c0101488 <process_C+0x8>
c0101496:	8d 76 00             	lea    0x0(%esi),%esi
c0101499:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c01014a0 <init_producer_consumer>:
struct Sem_type empty;
struct Sem_type full;
struct Sem_type mutex;
int	PC_counter;

void init_producer_consumer(void) {
c01014a0:	83 ec 1c             	sub    $0x1c,%esp
	Sem_init(&empty, 20);
c01014a3:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
c01014aa:	00 
c01014ab:	c7 04 24 e0 91 1d c0 	movl   $0xc01d91e0,(%esp)
c01014b2:	e8 39 01 00 00       	call   c01015f0 <Sem_init>
	Sem_init(&full, 0);
c01014b7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01014be:	00 
c01014bf:	c7 04 24 20 90 1d c0 	movl   $0xc01d9020,(%esp)
c01014c6:	e8 25 01 00 00       	call   c01015f0 <Sem_init>
	Sem_init(&mutex, 1);
c01014cb:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c01014d2:	00 
c01014d3:	c7 04 24 00 91 1d c0 	movl   $0xc01d9100,(%esp)
c01014da:	e8 11 01 00 00       	call   c01015f0 <Sem_init>
	PC_counter = 0;
c01014df:	c7 05 f0 90 1d c0 00 	movl   $0x0,0xc01d90f0
c01014e6:	00 00 00 
}
c01014e9:	83 c4 1c             	add    $0x1c,%esp
c01014ec:	c3                   	ret    
c01014ed:	8d 76 00             	lea    0x0(%esi),%esi

c01014f0 <producer>:
	


void producer(void) {
c01014f0:	83 ec 1c             	sub    $0x1c,%esp
c01014f3:	90                   	nop
c01014f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	//panic("sb");
	while (1)
	{
		Sem_P(&empty);
c01014f8:	c7 04 24 e0 91 1d c0 	movl   $0xc01d91e0,(%esp)
c01014ff:	e8 0c 01 00 00       	call   c0101610 <Sem_P>
		Sem_P(&mutex);
c0101504:	c7 04 24 00 91 1d c0 	movl   $0xc01d9100,(%esp)
c010150b:	e8 00 01 00 00       	call   c0101610 <Sem_P>
		++ PC_counter;
c0101510:	a1 f0 90 1d c0       	mov    0xc01d90f0,%eax
		printk("producing! %d\n", PC_counter);
c0101515:	c7 04 24 89 35 10 c0 	movl   $0xc0103589,(%esp)
	//panic("sb");
	while (1)
	{
		Sem_P(&empty);
		Sem_P(&mutex);
		++ PC_counter;
c010151c:	83 c0 01             	add    $0x1,%eax
		printk("producing! %d\n", PC_counter);
c010151f:	89 44 24 04          	mov    %eax,0x4(%esp)
	//panic("sb");
	while (1)
	{
		Sem_P(&empty);
		Sem_P(&mutex);
		++ PC_counter;
c0101523:	a3 f0 90 1d c0       	mov    %eax,0xc01d90f0
		printk("producing! %d\n", PC_counter);
c0101528:	e8 63 ee ff ff       	call   c0100390 <printk>
		Sem_V(&mutex);
c010152d:	c7 04 24 00 91 1d c0 	movl   $0xc01d9100,(%esp)
c0101534:	e8 37 01 00 00       	call   c0101670 <Sem_V>
		Sem_V(&full);
c0101539:	c7 04 24 20 90 1d c0 	movl   $0xc01d9020,(%esp)
c0101540:	e8 2b 01 00 00       	call   c0101670 <Sem_V>
c0101545:	eb b1                	jmp    c01014f8 <producer+0x8>
c0101547:	89 f6                	mov    %esi,%esi
c0101549:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0101550 <consumer>:
	}
}

void consumer(void) {
c0101550:	83 ec 1c             	sub    $0x1c,%esp
c0101553:	90                   	nop
c0101554:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

//	panic("fuck");
	while (1)
	{
		Sem_P(&full);
c0101558:	c7 04 24 20 90 1d c0 	movl   $0xc01d9020,(%esp)
c010155f:	e8 ac 00 00 00       	call   c0101610 <Sem_P>
		Sem_P(&mutex);
c0101564:	c7 04 24 00 91 1d c0 	movl   $0xc01d9100,(%esp)
c010156b:	e8 a0 00 00 00       	call   c0101610 <Sem_P>
		-- PC_counter;
c0101570:	a1 f0 90 1d c0       	mov    0xc01d90f0,%eax
		printk("consuming! %d\n", PC_counter);
c0101575:	c7 04 24 98 35 10 c0 	movl   $0xc0103598,(%esp)
//	panic("fuck");
	while (1)
	{
		Sem_P(&full);
		Sem_P(&mutex);
		-- PC_counter;
c010157c:	83 e8 01             	sub    $0x1,%eax
		printk("consuming! %d\n", PC_counter);
c010157f:	89 44 24 04          	mov    %eax,0x4(%esp)
//	panic("fuck");
	while (1)
	{
		Sem_P(&full);
		Sem_P(&mutex);
		-- PC_counter;
c0101583:	a3 f0 90 1d c0       	mov    %eax,0xc01d90f0
		printk("consuming! %d\n", PC_counter);
c0101588:	e8 03 ee ff ff       	call   c0100390 <printk>
		Sem_V(&mutex);
c010158d:	c7 04 24 00 91 1d c0 	movl   $0xc01d9100,(%esp)
c0101594:	e8 d7 00 00 00       	call   c0101670 <Sem_V>
		Sem_V(&empty);
c0101599:	c7 04 24 e0 91 1d c0 	movl   $0xc01d91e0,(%esp)
c01015a0:	e8 cb 00 00 00       	call   c0101670 <Sem_V>
c01015a5:	eb b1                	jmp    c0101558 <consumer+0x8>
c01015a7:	90                   	nop
c01015a8:	90                   	nop
c01015a9:	90                   	nop
c01015aa:	90                   	nop
c01015ab:	90                   	nop
c01015ac:	90                   	nop
c01015ad:	90                   	nop
c01015ae:	90                   	nop
c01015af:	90                   	nop

c01015b0 <lock>:

uint_32 enter_interrupt = 0;

void lock(void)
{
	if (global_lock_counter == 0)
c01015b0:	a1 64 55 10 c0       	mov    0xc0105564,%eax
c01015b5:	85 c0                	test   %eax,%eax
c01015b7:	75 01                	jne    c01015ba <lock+0xa>
	asm volatile("sti");
}

static inline void
disable_interrupt(void) {
	asm volatile("cli");
c01015b9:	fa                   	cli    
		disable_interrupt();
	++ global_lock_counter;
c01015ba:	83 c0 01             	add    $0x1,%eax
c01015bd:	a3 64 55 10 c0       	mov    %eax,0xc0105564
}
c01015c2:	c3                   	ret    
c01015c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c01015c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c01015d0 <unlock>:


void unlock(void)
{
	-- global_lock_counter;
c01015d0:	a1 64 55 10 c0       	mov    0xc0105564,%eax
c01015d5:	83 e8 01             	sub    $0x1,%eax
	if (global_lock_counter == 0 && enter_interrupt == 0)
c01015d8:	85 c0                	test   %eax,%eax
}


void unlock(void)
{
	-- global_lock_counter;
c01015da:	a3 64 55 10 c0       	mov    %eax,0xc0105564
	if (global_lock_counter == 0 && enter_interrupt == 0)
c01015df:	75 0a                	jne    c01015eb <unlock+0x1b>
c01015e1:	a1 60 55 10 c0       	mov    0xc0105560,%eax
c01015e6:	85 c0                	test   %eax,%eax
c01015e8:	75 01                	jne    c01015eb <unlock+0x1b>
	asm volatile("lidt (%0)" : : "r"(data));
}

static inline void
enable_interrupt(void) {
	asm volatile("sti");
c01015ea:	fb                   	sti    
c01015eb:	f3 c3                	repz ret 
c01015ed:	90                   	nop
c01015ee:	90                   	nop
c01015ef:	90                   	nop

c01015f0 <Sem_init>:
#include "kernel.h"


void Sem_init(struct Sem_type *sem, int init_token) {
c01015f0:	8b 44 24 04          	mov    0x4(%esp),%eax
	sem -> token = init_token;
c01015f4:	8b 54 24 08          	mov    0x8(%esp),%edx
	sem -> queue_tail = 0;
c01015f8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#include "kernel.h"


void Sem_init(struct Sem_type *sem, int init_token) {
	sem -> token = init_token;
c01015ff:	89 10                	mov    %edx,(%eax)
	sem -> queue_tail = 0;
}
c0101601:	c3                   	ret    
c0101602:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0101609:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0101610 <Sem_P>:
	return NULL;
}
*/

void Sem_P(struct Sem_type *sem)
{
c0101610:	53                   	push   %ebx
c0101611:	83 ec 08             	sub    $0x8,%esp
c0101614:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	lock();
c0101618:	e8 93 ff ff ff       	call   c01015b0 <lock>
	if (sem -> token > 0)
c010161d:	8b 03                	mov    (%ebx),%eax
c010161f:	85 c0                	test   %eax,%eax
c0101621:	7e 15                	jle    c0101638 <Sem_P+0x28>
	{
		-- (sem -> token);
c0101623:	83 e8 01             	sub    $0x1,%eax
c0101626:	89 03                	mov    %eax,(%ebx)
		sem -> queue[sem -> queue_tail ++] = current_pcb -> pid;
		current_pcb -> status = STATUS_SLEEPING;
		unlock();
		asm volatile("int $0x80");
	}
}
c0101628:	83 c4 08             	add    $0x8,%esp
c010162b:	5b                   	pop    %ebx
{
	lock();
	if (sem -> token > 0)
	{
		-- (sem -> token);
		unlock();
c010162c:	e9 9f ff ff ff       	jmp    c01015d0 <unlock>
c0101631:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}
	else
	{
		sem -> queue[sem -> queue_tail ++] = current_pcb -> pid;
c0101638:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c010163d:	8b 53 04             	mov    0x4(%ebx),%edx
c0101640:	8b 88 1c 20 00 00    	mov    0x201c(%eax),%ecx
c0101646:	89 4c 93 08          	mov    %ecx,0x8(%ebx,%edx,4)
c010164a:	83 c2 01             	add    $0x1,%edx
c010164d:	89 53 04             	mov    %edx,0x4(%ebx)
		current_pcb -> status = STATUS_SLEEPING;
c0101650:	c7 80 14 20 00 00 ff 	movl   $0xffffffff,0x2014(%eax)
c0101657:	ff ff ff 
		unlock();
c010165a:	e8 71 ff ff ff       	call   c01015d0 <unlock>
		asm volatile("int $0x80");
c010165f:	cd 80                	int    $0x80
	}
}
c0101661:	83 c4 08             	add    $0x8,%esp
c0101664:	5b                   	pop    %ebx
c0101665:	c3                   	ret    
c0101666:	8d 76 00             	lea    0x0(%esi),%esi
c0101669:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0101670 <Sem_V>:


void Sem_V(struct Sem_type *sem)
{
c0101670:	53                   	push   %ebx
c0101671:	83 ec 08             	sub    $0x8,%esp
c0101674:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	lock();
c0101678:	e8 33 ff ff ff       	call   c01015b0 <lock>
	if (sem -> queue_tail != 0)
c010167d:	8b 43 04             	mov    0x4(%ebx),%eax
c0101680:	85 c0                	test   %eax,%eax
c0101682:	75 0c                	jne    c0101690 <Sem_V+0x20>
		-- (sem -> queue_tail);
		(Proc + (sem -> queue[sem -> queue_tail])) -> status = STATUS_WAITING;
		//preempt_proc = Proc + (sem -> queue[sem -> queue_tail]);
	}
	else
		++ (sem -> token);	
c0101684:	83 03 01             	addl   $0x1,(%ebx)
	unlock();
}
c0101687:	83 c4 08             	add    $0x8,%esp
c010168a:	5b                   	pop    %ebx
		(Proc + (sem -> queue[sem -> queue_tail])) -> status = STATUS_WAITING;
		//preempt_proc = Proc + (sem -> queue[sem -> queue_tail]);
	}
	else
		++ (sem -> token);	
	unlock();
c010168b:	e9 40 ff ff ff       	jmp    c01015d0 <unlock>
void Sem_V(struct Sem_type *sem)
{
	lock();
	if (sem -> queue_tail != 0)
	{
		-- (sem -> queue_tail);
c0101690:	83 e8 01             	sub    $0x1,%eax
c0101693:	89 43 04             	mov    %eax,0x4(%ebx)
		(Proc + (sem -> queue[sem -> queue_tail])) -> status = STATUS_WAITING;
c0101696:	8b 44 83 08          	mov    0x8(%ebx,%eax,4),%eax
c010169a:	8d 04 80             	lea    (%eax,%eax,4),%eax
c010169d:	c1 e0 0c             	shl    $0xc,%eax
c01016a0:	c7 80 14 b0 13 c0 00 	movl   $0x0,-0x3fec4fec(%eax)
c01016a7:	00 00 00 
		//preempt_proc = Proc + (sem -> queue[sem -> queue_tail]);
	}
	else
		++ (sem -> token);	
	unlock();
}
c01016aa:	83 c4 08             	add    $0x8,%esp
c01016ad:	5b                   	pop    %ebx
		(Proc + (sem -> queue[sem -> queue_tail])) -> status = STATUS_WAITING;
		//preempt_proc = Proc + (sem -> queue[sem -> queue_tail]);
	}
	else
		++ (sem -> token);	
	unlock();
c01016ae:	e9 1d ff ff ff       	jmp    c01015d0 <unlock>
c01016b3:	90                   	nop
c01016b4:	90                   	nop
c01016b5:	90                   	nop
c01016b6:	90                   	nop
c01016b7:	90                   	nop
c01016b8:	90                   	nop
c01016b9:	90                   	nop
c01016ba:	90                   	nop
c01016bb:	90                   	nop
c01016bc:	90                   	nop
c01016bd:	90                   	nop
c01016be:	90                   	nop
c01016bf:	90                   	nop

c01016c0 <Find_Empty_Message>:
//static
struct Message_Pool_type* Find_Empty_Message(struct Message_Pool_type *Pool) {
	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
		if ((Pool + i) -> flag == TRUE) return (Pool + i);
	return NULL;
c01016c0:	8b 44 24 04          	mov    0x4(%esp),%eax
#include "kernel.h"

struct Message_Pool_type	Message_Pool[Max_Message_Pool];

//static
struct Message_Pool_type* Find_Empty_Message(struct Message_Pool_type *Pool) {
c01016c4:	ba 80 00 00 00       	mov    $0x80,%edx
c01016c9:	eb 0d                	jmp    c01016d8 <Find_Empty_Message+0x18>
c01016cb:	90                   	nop
c01016cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
		if ((Pool + i) -> flag == TRUE) return (Pool + i);
c01016d0:	83 c0 28             	add    $0x28,%eax
struct Message_Pool_type	Message_Pool[Max_Message_Pool];

//static
struct Message_Pool_type* Find_Empty_Message(struct Message_Pool_type *Pool) {
	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
c01016d3:	83 ea 01             	sub    $0x1,%edx
c01016d6:	74 08                	je     c01016e0 <Find_Empty_Message+0x20>
		if ((Pool + i) -> flag == TRUE) return (Pool + i);
c01016d8:	80 78 24 01          	cmpb   $0x1,0x24(%eax)
c01016dc:	75 f2                	jne    c01016d0 <Find_Empty_Message+0x10>
	return NULL;
}
c01016de:	f3 c3                	repz ret 
//static
struct Message_Pool_type* Find_Empty_Message(struct Message_Pool_type *Pool) {
	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
		if ((Pool + i) -> flag == TRUE) return (Pool + i);
	return NULL;
c01016e0:	31 c0                	xor    %eax,%eax
}
c01016e2:	c3                   	ret    
c01016e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c01016e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c01016f0 <send>:

void send(pid_t pid, struct Message *m) {
c01016f0:	57                   	push   %edi
c01016f1:	56                   	push   %esi
c01016f2:	53                   	push   %ebx
c01016f3:	83 ec 10             	sub    $0x10,%esp
c01016f6:	8b 7c 24 20          	mov    0x20(%esp),%edi
c01016fa:	8b 74 24 24          	mov    0x24(%esp),%esi

#ifdef DEBUG
printk("In send, from %d to %d\n", (enter_interrupt == 1) ? MSG_HARD_INTR : current_pcb -> pid, pid);
#endif

	lock();
c01016fe:	e8 ad fe ff ff       	call   c01015b0 <lock>
struct Message_Pool_type	Message_Pool[Max_Message_Pool];

//static
struct Message_Pool_type* Find_Empty_Message(struct Message_Pool_type *Pool) {
	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
c0101703:	31 c0                	xor    %eax,%eax
printk("In send, from %d to %d\n", (enter_interrupt == 1) ? MSG_HARD_INTR : current_pcb -> pid, pid);
#endif

	lock();

	struct PCB	*target_pcb = Proc + pid;
c0101705:	8d 1c bf             	lea    (%edi,%edi,4),%ebx
c0101708:	c1 e3 0c             	shl    $0xc,%ebx
c010170b:	81 c3 00 90 13 c0    	add    $0xc0139000,%ebx
c0101711:	eb 13                	jmp    c0101726 <send+0x36>
c0101713:	90                   	nop
c0101714:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
struct Message_Pool_type	Message_Pool[Max_Message_Pool];

//static
struct Message_Pool_type* Find_Empty_Message(struct Message_Pool_type *Pool) {
	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
c0101718:	83 c0 01             	add    $0x1,%eax
c010171b:	3d 80 00 00 00       	cmp    $0x80,%eax
c0101720:	0f 84 aa 00 00 00    	je     c01017d0 <send+0xe0>
		if ((Pool + i) -> flag == TRUE) return (Pool + i);
c0101726:	8d 14 80             	lea    (%eax,%eax,4),%edx
c0101729:	8d 14 d5 f0 20 00 00 	lea    0x20f0(,%edx,8),%edx
c0101730:	80 7c 13 24 01       	cmpb   $0x1,0x24(%ebx,%edx,1)
c0101735:	75 e1                	jne    c0101718 <send+0x28>
c0101737:	01 da                	add    %ebx,%edx
	struct Message_Pool_type *new_msg = Find_Empty_Message(target_pcb -> Msg_rec_Pool);

	if (new_msg == NULL)
		panic("\nNo enough space for message passing!\n");

	new_msg -> flag = FALSE;
c0101739:	c6 42 24 00          	movb   $0x0,0x24(%edx)

	new_msg -> msg = *m;
c010173d:	8b 06                	mov    (%esi),%eax

	if (enter_interrupt == 1)
c010173f:	83 3d 60 55 10 c0 01 	cmpl   $0x1,0xc0105560
	if (new_msg == NULL)
		panic("\nNo enough space for message passing!\n");

	new_msg -> flag = FALSE;

	new_msg -> msg = *m;
c0101746:	89 02                	mov    %eax,(%edx)
c0101748:	8b 46 04             	mov    0x4(%esi),%eax
c010174b:	89 42 04             	mov    %eax,0x4(%edx)
c010174e:	8b 46 08             	mov    0x8(%esi),%eax
c0101751:	89 42 08             	mov    %eax,0x8(%edx)
c0101754:	8b 46 0c             	mov    0xc(%esi),%eax
c0101757:	89 42 0c             	mov    %eax,0xc(%edx)
c010175a:	8b 46 10             	mov    0x10(%esi),%eax
c010175d:	89 42 10             	mov    %eax,0x10(%edx)
c0101760:	8b 46 14             	mov    0x14(%esi),%eax
c0101763:	89 42 14             	mov    %eax,0x14(%edx)
c0101766:	8b 46 18             	mov    0x18(%esi),%eax
c0101769:	89 42 18             	mov    %eax,0x18(%edx)

	if (enter_interrupt == 1)
c010176c:	74 4a                	je     c01017b8 <send+0xc8>
		(new_msg -> msg).src = MSG_HARD_INTR;
	else
		(new_msg -> msg).src = current_pcb -> pid;
c010176e:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0101773:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c0101779:	89 02                	mov    %eax,(%edx)

	(new_msg -> msg).dest = pid;
c010177b:	89 7a 04             	mov    %edi,0x4(%edx)

	//printk("from %d to %d\n", (new_msg -> msg).src, (new_msg -> msg).dest);

	new_msg -> next = NULL;
c010177e:	c7 42 20 00 00 00 00 	movl   $0x0,0x20(%edx)

	if (target_pcb -> Msg_rec == NULL)
c0101785:	8b 83 f0 34 00 00    	mov    0x34f0(%ebx),%eax
c010178b:	85 c0                	test   %eax,%eax
c010178d:	74 31                	je     c01017c0 <send+0xd0>
		target_pcb -> Msg_rec = new_msg;
		target_pcb -> Msg_rec -> prev = target_pcb -> Msg_rec;
	}
	else
	{
		target_pcb -> Msg_rec -> prev -> next = new_msg;
c010178f:	8b 40 1c             	mov    0x1c(%eax),%eax
c0101792:	89 50 20             	mov    %edx,0x20(%eax)
		target_pcb -> Msg_rec -> prev = new_msg;
c0101795:	8b 83 f0 34 00 00    	mov    0x34f0(%ebx),%eax
c010179b:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	unlock();
c010179e:	e8 2d fe ff ff       	call   c01015d0 <unlock>

	Sem_V(&(target_pcb -> Msg_lock));
c01017a3:	81 c3 20 20 00 00    	add    $0x2020,%ebx
c01017a9:	89 5c 24 20          	mov    %ebx,0x20(%esp)
	
}
c01017ad:	83 c4 10             	add    $0x10,%esp
c01017b0:	5b                   	pop    %ebx
c01017b1:	5e                   	pop    %esi
c01017b2:	5f                   	pop    %edi
		target_pcb -> Msg_rec -> prev = new_msg;
	}

	unlock();

	Sem_V(&(target_pcb -> Msg_lock));
c01017b3:	e9 b8 fe ff ff       	jmp    c0101670 <Sem_V>
	new_msg -> flag = FALSE;

	new_msg -> msg = *m;

	if (enter_interrupt == 1)
		(new_msg -> msg).src = MSG_HARD_INTR;
c01017b8:	c7 02 80 ff ff ff    	movl   $0xffffff80,(%edx)
c01017be:	eb bb                	jmp    c010177b <send+0x8b>
	if (target_pcb -> Msg_rec == NULL)
	{
#ifdef DEBUG
printk("Exact NULL %d\n", target_pcb -> pid);
#endif
		target_pcb -> Msg_rec = new_msg;
c01017c0:	89 93 f0 34 00 00    	mov    %edx,0x34f0(%ebx)
		target_pcb -> Msg_rec -> prev = target_pcb -> Msg_rec;
c01017c6:	89 52 1c             	mov    %edx,0x1c(%edx)
c01017c9:	eb d3                	jmp    c010179e <send+0xae>
c01017cb:	90                   	nop
c01017cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	struct PCB	*target_pcb = Proc + pid;

	struct Message_Pool_type *new_msg = Find_Empty_Message(target_pcb -> Msg_rec_Pool);

	if (new_msg == NULL)
		panic("\nNo enough space for message passing!\n");
c01017d0:	c7 04 24 a8 35 10 c0 	movl   $0xc01035a8,(%esp)
c01017d7:	e8 e4 eb ff ff       	call   c01003c0 <panic>
c01017dc:	31 d2                	xor    %edx,%edx
c01017de:	e9 56 ff ff ff       	jmp    c0101739 <send+0x49>
c01017e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c01017e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c01017f0 <receive>:
	Sem_V(&(target_pcb -> Msg_lock));
	
}


void receive(pid_t pid, struct Message *m) {
c01017f0:	57                   	push   %edi
c01017f1:	56                   	push   %esi
c01017f2:	53                   	push   %ebx
c01017f3:	83 ec 10             	sub    $0x10,%esp
printk("In receive, from %d\n", pid);
#endif

	struct Message_Pool_type	*ptr;

	for (ptr = (current_pcb -> Msg_ign); ptr != NULL && !(pid == ANY || pid == (ptr -> msg).src); ptr = ptr -> next);
c01017f6:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
	Sem_V(&(target_pcb -> Msg_lock));
	
}


void receive(pid_t pid, struct Message *m) {
c01017fb:	8b 74 24 20          	mov    0x20(%esp),%esi
c01017ff:	8b 7c 24 24          	mov    0x24(%esp),%edi
printk("In receive, from %d\n", pid);
#endif

	struct Message_Pool_type	*ptr;

	for (ptr = (current_pcb -> Msg_ign); ptr != NULL && !(pid == ANY || pid == (ptr -> msg).src); ptr = ptr -> next);
c0101803:	8b 90 f4 34 00 00    	mov    0x34f4(%eax),%edx
c0101809:	85 d2                	test   %edx,%edx
c010180b:	74 33                	je     c0101840 <receive+0x50>
c010180d:	83 fe ff             	cmp    $0xffffffff,%esi
c0101810:	89 d3                	mov    %edx,%ebx
c0101812:	0f 84 a8 00 00 00    	je     c01018c0 <receive+0xd0>
c0101818:	39 32                	cmp    %esi,(%edx)
c010181a:	75 1a                	jne    c0101836 <receive+0x46>
c010181c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0101820:	e9 9b 00 00 00       	jmp    c01018c0 <receive+0xd0>
c0101825:	8d 76 00             	lea    0x0(%esi),%esi
c0101828:	39 33                	cmp    %esi,(%ebx)
c010182a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c0101830:	0f 84 ea 00 00 00    	je     c0101920 <receive+0x130>
c0101836:	8b 5b 20             	mov    0x20(%ebx),%ebx
c0101839:	85 db                	test   %ebx,%ebx
c010183b:	75 eb                	jne    c0101828 <receive+0x38>
c010183d:	8d 76 00             	lea    0x0(%esi),%esi
	}
	else
	{
		while (1)
		{
			Sem_P(&(current_pcb -> Msg_lock));
c0101840:	05 20 20 00 00       	add    $0x2020,%eax
c0101845:	89 04 24             	mov    %eax,(%esp)
c0101848:	e8 c3 fd ff ff       	call   c0101610 <Sem_P>
#ifdef DEBUG
printk("received\n");
#endif

			lock();
c010184d:	e8 5e fd ff ff       	call   c01015b0 <lock>

			ptr = current_pcb -> Msg_rec;
c0101852:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0101857:	8b 98 f0 34 00 00    	mov    0x34f0(%eax),%ebx

#ifdef DEBUG
printk("fuck you %d\n", current_pcb -> pid);
printk("Token = %d\n", (current_pcb -> Msg_lock).token);
#endif
			if (current_pcb -> Msg_rec -> next == NULL)
c010185d:	8b 53 20             	mov    0x20(%ebx),%edx
c0101860:	85 d2                	test   %edx,%edx
c0101862:	0f 84 d0 00 00 00    	je     c0101938 <receive+0x148>
			{
				current_pcb -> Msg_rec = NULL;
			}
			else
			{
				current_pcb -> Msg_rec -> next -> prev = current_pcb -> Msg_rec -> prev;
c0101868:	8b 4b 1c             	mov    0x1c(%ebx),%ecx
c010186b:	89 4a 1c             	mov    %ecx,0x1c(%edx)
				current_pcb -> Msg_rec = current_pcb -> Msg_rec -> next;
c010186e:	8b 90 f0 34 00 00    	mov    0x34f0(%eax),%edx
c0101874:	8b 52 20             	mov    0x20(%edx),%edx
c0101877:	89 90 f0 34 00 00    	mov    %edx,0x34f0(%eax)
			}

			unlock();
c010187d:	e8 4e fd ff ff       	call   c01015d0 <unlock>

			if (pid == ANY || pid == (ptr -> msg).src) break;
c0101882:	83 fe ff             	cmp    $0xffffffff,%esi
c0101885:	74 59                	je     c01018e0 <receive+0xf0>
c0101887:	39 33                	cmp    %esi,(%ebx)
c0101889:	74 55                	je     c01018e0 <receive+0xf0>

			if (current_pcb -> Msg_ign == NULL)
c010188b:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
c0101890:	8b 90 f4 34 00 00    	mov    0x34f4(%eax),%edx
c0101896:	85 d2                	test   %edx,%edx
c0101898:	0f 84 aa 00 00 00    	je     c0101948 <receive+0x158>
				current_pcb -> Msg_ign -> next = NULL;
				current_pcb -> Msg_ign -> prev = ptr;
			}
			else
			{
				ptr -> next = NULL;
c010189e:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
				current_pcb -> Msg_ign -> prev -> next = current_pcb -> Msg_ign;
c01018a5:	8b 90 f4 34 00 00    	mov    0x34f4(%eax),%edx
c01018ab:	8b 4a 1c             	mov    0x1c(%edx),%ecx
c01018ae:	89 51 20             	mov    %edx,0x20(%ecx)
				current_pcb -> Msg_ign -> prev = ptr;
c01018b1:	8b 90 f4 34 00 00    	mov    0x34f4(%eax),%edx
c01018b7:	89 5a 1c             	mov    %ebx,0x1c(%edx)
c01018ba:	eb 84                	jmp    c0101840 <receive+0x50>
c01018bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	if (ptr != NULL)
	{
		if (ptr == (current_pcb -> Msg_ign))
		{
			if (ptr -> next == NULL)
c01018c0:	8b 53 20             	mov    0x20(%ebx),%edx
c01018c3:	85 d2                	test   %edx,%edx
c01018c5:	0f 84 98 00 00 00    	je     c0101963 <receive+0x173>
				current_pcb -> Msg_ign = NULL;

			}
			else
			{
				ptr -> next -> prev = ptr -> prev;
c01018cb:	8b 4b 1c             	mov    0x1c(%ebx),%ecx
c01018ce:	89 4a 1c             	mov    %ecx,0x1c(%edx)
				current_pcb -> Msg_ign = ptr -> next;
c01018d1:	8b 53 20             	mov    0x20(%ebx),%edx
c01018d4:	89 90 f4 34 00 00    	mov    %edx,0x34f4(%eax)
c01018da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				current_pcb -> Msg_ign -> prev = ptr;
			}
		}
	}
	
	*m = ptr -> msg;
c01018e0:	8b 03                	mov    (%ebx),%eax
c01018e2:	89 07                	mov    %eax,(%edi)
c01018e4:	8b 43 04             	mov    0x4(%ebx),%eax
c01018e7:	89 47 04             	mov    %eax,0x4(%edi)
c01018ea:	8b 43 08             	mov    0x8(%ebx),%eax
c01018ed:	89 47 08             	mov    %eax,0x8(%edi)
c01018f0:	8b 43 0c             	mov    0xc(%ebx),%eax
c01018f3:	89 47 0c             	mov    %eax,0xc(%edi)
c01018f6:	8b 43 10             	mov    0x10(%ebx),%eax
c01018f9:	89 47 10             	mov    %eax,0x10(%edi)
c01018fc:	8b 43 14             	mov    0x14(%ebx),%eax
c01018ff:	89 47 14             	mov    %eax,0x14(%edi)
c0101902:	8b 43 18             	mov    0x18(%ebx),%eax
c0101905:	89 47 18             	mov    %eax,0x18(%edi)
	
	lock();
c0101908:	e8 a3 fc ff ff       	call   c01015b0 <lock>
	ptr -> flag = TRUE;
c010190d:	c6 43 24 01          	movb   $0x1,0x24(%ebx)
	unlock();
}
c0101911:	83 c4 10             	add    $0x10,%esp
c0101914:	5b                   	pop    %ebx
c0101915:	5e                   	pop    %esi
c0101916:	5f                   	pop    %edi
	
	*m = ptr -> msg;
	
	lock();
	ptr -> flag = TRUE;
	unlock();
c0101917:	e9 b4 fc ff ff       	jmp    c01015d0 <unlock>
c010191c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	for (ptr = (current_pcb -> Msg_ign); ptr != NULL && !(pid == ANY || pid == (ptr -> msg).src); ptr = ptr -> next);

	if (ptr != NULL)
	{
		if (ptr == (current_pcb -> Msg_ign))
c0101920:	39 d3                	cmp    %edx,%ebx
c0101922:	74 9c                	je     c01018c0 <receive+0xd0>
				current_pcb -> Msg_ign = ptr -> next;
			}
		}
		else
		{
			ptr -> prev -> next = ptr -> next;
c0101924:	8b 43 1c             	mov    0x1c(%ebx),%eax
c0101927:	8b 53 20             	mov    0x20(%ebx),%edx
c010192a:	89 50 20             	mov    %edx,0x20(%eax)
			ptr -> next -> prev = ptr -> prev;
c010192d:	8b 43 20             	mov    0x20(%ebx),%eax
c0101930:	8b 53 1c             	mov    0x1c(%ebx),%edx
c0101933:	89 50 1c             	mov    %edx,0x1c(%eax)
c0101936:	eb a8                	jmp    c01018e0 <receive+0xf0>
printk("fuck you %d\n", current_pcb -> pid);
printk("Token = %d\n", (current_pcb -> Msg_lock).token);
#endif
			if (current_pcb -> Msg_rec -> next == NULL)
			{
				current_pcb -> Msg_rec = NULL;
c0101938:	c7 80 f0 34 00 00 00 	movl   $0x0,0x34f0(%eax)
c010193f:	00 00 00 
c0101942:	e9 36 ff ff ff       	jmp    c010187d <receive+0x8d>
c0101947:	90                   	nop

			if (pid == ANY || pid == (ptr -> msg).src) break;

			if (current_pcb -> Msg_ign == NULL)
			{
				current_pcb -> Msg_ign = ptr;
c0101948:	89 98 f4 34 00 00    	mov    %ebx,0x34f4(%eax)
				current_pcb -> Msg_ign -> next = NULL;
c010194e:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
				current_pcb -> Msg_ign -> prev = ptr;
c0101955:	8b 90 f4 34 00 00    	mov    0x34f4(%eax),%edx
c010195b:	89 5a 1c             	mov    %ebx,0x1c(%edx)
c010195e:	e9 dd fe ff ff       	jmp    c0101840 <receive+0x50>
	{
		if (ptr == (current_pcb -> Msg_ign))
		{
			if (ptr -> next == NULL)
			{
				current_pcb -> Msg_ign = NULL;
c0101963:	c7 80 f4 34 00 00 00 	movl   $0x0,0x34f4(%eax)
c010196a:	00 00 00 
c010196d:	e9 6e ff ff ff       	jmp    c01018e0 <receive+0xf0>
c0101972:	90                   	nop
c0101973:	90                   	nop
c0101974:	90                   	nop
c0101975:	90                   	nop
c0101976:	90                   	nop
c0101977:	90                   	nop
c0101978:	90                   	nop
c0101979:	90                   	nop
c010197a:	90                   	nop
c010197b:	90                   	nop
c010197c:	90                   	nop
c010197d:	90                   	nop
c010197e:	90                   	nop
c010197f:	90                   	nop

c0101980 <timer_intr>:
		}
	}
}

static void
timer_intr(void) {
c0101980:	83 ec 1c             	sub    $0x1c,%esp
#ifdef DEBUG
printk("Timer Interupt\n");
#endif
	static struct Message m;

	current_pcb->time_elapsed ++;
c0101983:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
	if (current_pcb->time_elapsed % NR_PROC_TIME == 0) {
c0101988:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
#ifdef DEBUG
printk("Timer Interupt\n");
#endif
	static struct Message m;

	current_pcb->time_elapsed ++;
c010198d:	8b 88 f8 34 00 00    	mov    0x34f8(%eax),%ecx
c0101993:	83 c1 01             	add    $0x1,%ecx
c0101996:	89 88 f8 34 00 00    	mov    %ecx,0x34f8(%eax)
	if (current_pcb->time_elapsed % NR_PROC_TIME == 0) {
c010199c:	89 c8                	mov    %ecx,%eax
c010199e:	f7 e2                	mul    %edx
c01019a0:	c1 ea 02             	shr    $0x2,%edx
c01019a3:	8d 04 92             	lea    (%edx,%edx,4),%eax
c01019a6:	39 c1                	cmp    %eax,%ecx
c01019a8:	75 07                	jne    c01019b1 <timer_intr+0x31>
		need_sched = TRUE;
c01019aa:	c6 05 e8 4b 10 c0 01 	movb   $0x1,0xc0104be8
	}
	if (alarm_queue != NULL) {
c01019b1:	a1 20 57 10 c0       	mov    0xc0105720,%eax
c01019b6:	85 c0                	test   %eax,%eax
c01019b8:	74 5a                	je     c0101a14 <timer_intr+0x94>
		alarm_queue->remain_time --;
c01019ba:	8b 50 04             	mov    0x4(%eax),%edx
c01019bd:	83 ea 01             	sub    $0x1,%edx
		while (alarm_queue != NULL && alarm_queue->remain_time <= 0) {
c01019c0:	85 d2                	test   %edx,%edx
	current_pcb->time_elapsed ++;
	if (current_pcb->time_elapsed % NR_PROC_TIME == 0) {
		need_sched = TRUE;
	}
	if (alarm_queue != NULL) {
		alarm_queue->remain_time --;
c01019c2:	89 50 04             	mov    %edx,0x4(%eax)
		while (alarm_queue != NULL && alarm_queue->remain_time <= 0) {
c01019c5:	7e 10                	jle    c01019d7 <timer_intr+0x57>
c01019c7:	eb 4b                	jmp    c0101a14 <timer_intr+0x94>
c01019c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c01019d0:	8b 50 04             	mov    0x4(%eax),%edx
c01019d3:	85 d2                	test   %edx,%edx
c01019d5:	7f 3d                	jg     c0101a14 <timer_intr+0x94>
			m.type = TIMER_ALRM_FIRE;
c01019d7:	c7 05 2c 57 10 c0 0b 	movl   $0xb,0xc010572c
c01019de:	00 00 00 
#ifdef DEBUG
printk("God want to send to %d\n", alarm_queue -> pid);
#endif
			send(alarm_queue->pid, &m);
c01019e1:	c7 44 24 04 24 57 10 	movl   $0xc0105724,0x4(%esp)
c01019e8:	c0 
c01019e9:	8b 00                	mov    (%eax),%eax
c01019eb:	89 04 24             	mov    %eax,(%esp)
c01019ee:	e8 fd fc ff ff       	call   c01016f0 <send>
pop_alarm(void) {
#ifdef DEBUG
printk("In Pop_alarm, head = %d\n", alarm_queue -> pid);
#endif
	struct Alarm *ptr;
	ptr = alarm_queue;
c01019f3:	8b 15 20 57 10 c0    	mov    0xc0105720,%edx
	alarm_queue = alarm_queue->next;
	ptr->next = alarm_free;
c01019f9:	8b 0d 80 55 10 c0    	mov    0xc0105580,%ecx
#ifdef DEBUG
printk("In Pop_alarm, head = %d\n", alarm_queue -> pid);
#endif
	struct Alarm *ptr;
	ptr = alarm_queue;
	alarm_queue = alarm_queue->next;
c01019ff:	8b 42 08             	mov    0x8(%edx),%eax
	ptr->next = alarm_free;
	alarm_free = ptr;
c0101a02:	89 15 80 55 10 c0    	mov    %edx,0xc0105580
printk("In Pop_alarm, head = %d\n", alarm_queue -> pid);
#endif
	struct Alarm *ptr;
	ptr = alarm_queue;
	alarm_queue = alarm_queue->next;
	ptr->next = alarm_free;
c0101a08:	89 4a 08             	mov    %ecx,0x8(%edx)
	if (current_pcb->time_elapsed % NR_PROC_TIME == 0) {
		need_sched = TRUE;
	}
	if (alarm_queue != NULL) {
		alarm_queue->remain_time --;
		while (alarm_queue != NULL && alarm_queue->remain_time <= 0) {
c0101a0b:	85 c0                	test   %eax,%eax
#ifdef DEBUG
printk("In Pop_alarm, head = %d\n", alarm_queue -> pid);
#endif
	struct Alarm *ptr;
	ptr = alarm_queue;
	alarm_queue = alarm_queue->next;
c0101a0d:	a3 20 57 10 c0       	mov    %eax,0xc0105720
	if (current_pcb->time_elapsed % NR_PROC_TIME == 0) {
		need_sched = TRUE;
	}
	if (alarm_queue != NULL) {
		alarm_queue->remain_time --;
		while (alarm_queue != NULL && alarm_queue->remain_time <= 0) {
c0101a12:	75 bc                	jne    c01019d0 <timer_intr+0x50>


			pop_alarm();
		}
	}
}
c0101a14:	83 c4 1c             	add    $0x1c,%esp
c0101a17:	c3                   	ret    
c0101a18:	90                   	nop
c0101a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c0101a20 <timer_driver_initialize>:
static void init_alarm(void);
static void new_alarm(pid_t, int_32);
static void pop_alarm(void);


void timer_driver_initialize(void) {
c0101a20:	83 ec 1c             	sub    $0x1c,%esp
c0101a23:	ba 43 00 00 00       	mov    $0x43,%edx
c0101a28:	b8 34 00 00 00       	mov    $0x34,%eax
}

static void
init_alarm(void) {
	int i;
	alarm_free = alarm_pool;
c0101a2d:	c7 05 80 55 10 c0 a0 	movl   $0xc01055a0,0xc0105580
c0101a34:	55 10 c0 
c0101a37:	ee                   	out    %al,(%dx)
	alarm_queue = NULL;
c0101a38:	c7 05 20 57 10 c0 00 	movl   $0x0,0xc0105720
c0101a3f:	00 00 00 
c0101a42:	b2 40                	mov    $0x40,%dl
c0101a44:	b8 9c ff ff ff       	mov    $0xffffff9c,%eax
c0101a49:	ee                   	out    %al,(%dx)
c0101a4a:	b8 2e 00 00 00       	mov    $0x2e,%eax
c0101a4f:	ee                   	out    %al,(%dx)
c0101a50:	ba a8 55 10 c0       	mov    $0xc01055a8,%edx
c0101a55:	b8 01 00 00 00       	mov    $0x1,%eax
c0101a5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	for (i = 0; i < NR_PROCESS - 1; i ++) {
		alarm_pool[i].next = &alarm_pool[i + 1];
c0101a60:	8d 0c 40             	lea    (%eax,%eax,2),%ecx
c0101a63:	83 c0 01             	add    $0x1,%eax
c0101a66:	8d 0c 8d a0 55 10 c0 	lea    -0x3fefaa60(,%ecx,4),%ecx
c0101a6d:	89 0a                	mov    %ecx,(%edx)
c0101a6f:	83 c2 0c             	add    $0xc,%edx
static void
init_alarm(void) {
	int i;
	alarm_free = alarm_pool;
	alarm_queue = NULL;
	for (i = 0; i < NR_PROCESS - 1; i ++) {
c0101a72:	83 f8 20             	cmp    $0x20,%eax
c0101a75:	75 e9                	jne    c0101a60 <timer_driver_initialize+0x40>

void timer_driver_initialize(void) {

	init_100hz_timer();
	init_alarm();
	add_irq_handle(0, timer_intr);
c0101a77:	c7 44 24 04 80 19 10 	movl   $0xc0101980,0x4(%esp)
c0101a7e:	c0 
c0101a7f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0101a86:	e8 c5 f1 ff ff       	call   c0100c50 <add_irq_handle>
}
c0101a8b:	83 c4 1c             	add    $0x1c,%esp
c0101a8e:	c3                   	ret    
c0101a8f:	90                   	nop

c0101a90 <timer_driver_thread>:

void
timer_driver_thread(void) {
c0101a90:	56                   	push   %esi
c0101a91:	53                   	push   %ebx
c0101a92:	83 ec 14             	sub    $0x14,%esp
c0101a95:	8d 76 00             	lea    0x0(%esi),%esi

	while (TRUE) {
#ifdef DEBUG
printk("God want to receive\n");
#endif
		receive(ANY, &m);
c0101a98:	c7 44 24 04 40 57 10 	movl   $0xc0105740,0x4(%esp)
c0101a9f:	c0 
c0101aa0:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0101aa7:	e8 44 fd ff ff       	call   c01017f0 <receive>
#ifdef DEBUG	
printk("Rogar that!\n");
#endif
		switch (m.type) {
c0101aac:	83 3d 48 57 10 c0 0a 	cmpl   $0xa,0xc0105748
c0101ab3:	75 e3                	jne    c0101a98 <timer_driver_thread+0x8>
			case TIMER_SET_ALRM:
				lock();
c0101ab5:	e8 f6 fa ff ff       	call   c01015b0 <lock>
static void
new_alarm(pid_t pid, int_32 second) {
	struct Alarm *ptr;
	int time = second * 100;

	ptr = alarm_free;
c0101aba:	8b 35 80 55 10 c0    	mov    0xc0105580,%esi
}

static void
new_alarm(pid_t pid, int_32 second) {
	struct Alarm *ptr;
	int time = second * 100;
c0101ac0:	6b 05 50 57 10 c0 64 	imul   $0x64,0xc0105750,%eax
printk("Rogar that!\n");
#endif
		switch (m.type) {
			case TIMER_SET_ALRM:
				lock();
				new_alarm(m.int_msg.p1, m.int_msg.p2);
c0101ac7:	8b 15 4c 57 10 c0    	mov    0xc010574c,%edx
new_alarm(pid_t pid, int_32 second) {
	struct Alarm *ptr;
	int time = second * 100;

	ptr = alarm_free;
	alarm_free = alarm_free->next;
c0101acd:	8b 4e 08             	mov    0x8(%esi),%ecx

	ptr->remain_time = time;
c0101ad0:	89 46 04             	mov    %eax,0x4(%esi)
	ptr->pid = pid;
c0101ad3:	89 16                	mov    %edx,(%esi)
new_alarm(pid_t pid, int_32 second) {
	struct Alarm *ptr;
	int time = second * 100;

	ptr = alarm_free;
	alarm_free = alarm_free->next;
c0101ad5:	89 0d 80 55 10 c0    	mov    %ecx,0xc0105580

	ptr->remain_time = time;
	ptr->pid = pid;

	if (alarm_queue == NULL ||
c0101adb:	8b 0d 20 57 10 c0    	mov    0xc0105720,%ecx
c0101ae1:	85 c9                	test   %ecx,%ecx
c0101ae3:	74 07                	je     c0101aec <timer_driver_thread+0x5c>
		ptr->remain_time < alarm_queue->remain_time) {
c0101ae5:	8b 59 04             	mov    0x4(%ecx),%ebx
	alarm_free = alarm_free->next;

	ptr->remain_time = time;
	ptr->pid = pid;

	if (alarm_queue == NULL ||
c0101ae8:	39 d8                	cmp    %ebx,%eax
c0101aea:	7d 25                	jge    c0101b11 <timer_driver_thread+0x81>
		ptr->remain_time < alarm_queue->remain_time) {
		ptr->next = alarm_queue;
c0101aec:	89 4e 08             	mov    %ecx,0x8(%esi)
		alarm_queue = ptr;
c0101aef:	89 35 20 57 10 c0    	mov    %esi,0xc0105720
		if (cnt == NULL) panic("No insert position of timer!");
		ptr->next = cnt->next;
		cnt->next = ptr;
	}
	
	if (ptr -> next != NULL)
c0101af5:	85 c9                	test   %ecx,%ecx
c0101af7:	74 06                	je     c0101aff <timer_driver_thread+0x6f>
		ptr -> next -> remain_time -= ptr -> remain_time;
c0101af9:	8b 46 04             	mov    0x4(%esi),%eax
c0101afc:	29 41 04             	sub    %eax,0x4(%ecx)
#endif
		switch (m.type) {
			case TIMER_SET_ALRM:
				lock();
				new_alarm(m.int_msg.p1, m.int_msg.p2);
				unlock();
c0101aff:	e8 cc fa ff ff       	call   c01015d0 <unlock>
c0101b04:	eb 92                	jmp    c0101a98 <timer_driver_thread+0x8>
c0101b06:	66 90                	xchg   %ax,%ax
	} else {
		struct Alarm *cnt = alarm_queue;
		for (; ; cnt = cnt->next) {
			ptr->remain_time -= cnt->remain_time;
			if (cnt->next == NULL ||
				cnt->next->remain_time > ptr->remain_time) {
c0101b08:	8b 5a 04             	mov    0x4(%edx),%ebx
		alarm_queue = ptr;
	} else {
		struct Alarm *cnt = alarm_queue;
		for (; ; cnt = cnt->next) {
			ptr->remain_time -= cnt->remain_time;
			if (cnt->next == NULL ||
c0101b0b:	39 d8                	cmp    %ebx,%eax
c0101b0d:	7c 0e                	jl     c0101b1d <timer_driver_thread+0x8d>
c0101b0f:	89 d1                	mov    %edx,%ecx
		ptr->next = alarm_queue;
		alarm_queue = ptr;
	} else {
		struct Alarm *cnt = alarm_queue;
		for (; ; cnt = cnt->next) {
			ptr->remain_time -= cnt->remain_time;
c0101b11:	29 d8                	sub    %ebx,%eax
c0101b13:	89 46 04             	mov    %eax,0x4(%esi)
			if (cnt->next == NULL ||
c0101b16:	8b 51 08             	mov    0x8(%ecx),%edx
c0101b19:	85 d2                	test   %edx,%edx
c0101b1b:	75 eb                	jne    c0101b08 <timer_driver_thread+0x78>
				cnt->next->remain_time > ptr->remain_time) {
				break;
			}
		}
		if (cnt == NULL) panic("No insert position of timer!");
		ptr->next = cnt->next;
c0101b1d:	89 56 08             	mov    %edx,0x8(%esi)
		cnt->next = ptr;
c0101b20:	89 71 08             	mov    %esi,0x8(%ecx)
c0101b23:	8b 4e 08             	mov    0x8(%esi),%ecx
c0101b26:	eb cd                	jmp    c0101af5 <timer_driver_thread+0x65>
c0101b28:	90                   	nop
c0101b29:	90                   	nop
c0101b2a:	90                   	nop
c0101b2b:	90                   	nop
c0101b2c:	90                   	nop
c0101b2d:	90                   	nop
c0101b2e:	90                   	nop
c0101b2f:	90                   	nop

c0101b30 <keyboard_intr>:
		}
	}
}

void
keyboard_intr(void) {
c0101b30:	83 ec 1c             	sub    $0x1c,%esp
	static struct Message m;
	send(TTY, &m);
c0101b33:	a1 c4 a6 1d c0       	mov    0xc01da6c4,%eax
c0101b38:	c7 44 24 04 20 60 10 	movl   $0xc0106020,0x4(%esp)
c0101b3f:	c0 
c0101b40:	89 04 24             	mov    %eax,(%esp)
c0101b43:	e8 a8 fb ff ff       	call   c01016f0 <send>
}
c0101b48:	83 c4 1c             	add    $0x1c,%esp
c0101b4b:	c3                   	ret    
c0101b4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c0101b50 <canonic_wakeup_read>:
	ptr->next = free;
	free = ptr;
}

static void
canonic_wakeup_read(void) {
c0101b50:	57                   	push   %edi
c0101b51:	56                   	push   %esi
c0101b52:	53                   	push   %ebx
c0101b53:	83 ec 10             	sub    $0x10,%esp
	int i, nread = 0;
	static struct Message m;

	if (top != NULL && f != r) {
c0101b56:	8b 15 64 59 10 c0    	mov    0xc0105964,%edx
c0101b5c:	85 d2                	test   %edx,%edx
c0101b5e:	0f 84 d9 00 00 00    	je     c0101c3d <canonic_wakeup_read+0xed>
c0101b64:	8b 35 00 60 10 c0    	mov    0xc0106000,%esi
c0101b6a:	3b 35 e4 5b 10 c0    	cmp    0xc0105be4,%esi
c0101b70:	0f 84 c7 00 00 00    	je     c0101c3d <canonic_wakeup_read+0xed>
		for (i = 0; i < top->length && input_pool[f] != 0; i ++) {
c0101b76:	8b 42 08             	mov    0x8(%edx),%eax
c0101b79:	85 c0                	test   %eax,%eax
c0101b7b:	0f 84 e4 00 00 00    	je     c0101c65 <canonic_wakeup_read+0x115>
c0101b81:	80 be 00 5c 10 c0 00 	cmpb   $0x0,-0x3fefa400(%esi)
c0101b88:	0f 84 b6 00 00 00    	je     c0101c44 <canonic_wakeup_read+0xf4>
c0101b8e:	31 ff                	xor    %edi,%edi
c0101b90:	31 db                	xor    %ebx,%ebx
c0101b92:	eb 11                	jmp    c0101ba5 <canonic_wakeup_read+0x55>
c0101b94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0101b98:	80 b8 00 5c 10 c0 00 	cmpb   $0x0,-0x3fefa400(%eax)
c0101b9f:	0f 84 a3 00 00 00    	je     c0101c48 <canonic_wakeup_read+0xf8>
			copy_from_kernel(fetch_pcb(top->pid),
c0101ba5:	8b 02                	mov    (%edx),%eax
c0101ba7:	81 c6 00 5c 10 c0    	add    $0xc0105c00,%esi
					top->buf + i, input_pool + f, 1);
			f = (f + 1) % NR_INPUT_POOL;
			nread ++;
c0101bad:	83 c3 01             	add    $0x1,%ebx
	int i, nread = 0;
	static struct Message m;

	if (top != NULL && f != r) {
		for (i = 0; i < top->length && input_pool[f] != 0; i ++) {
			copy_from_kernel(fetch_pcb(top->pid),
c0101bb0:	03 7a 04             	add    0x4(%edx),%edi
c0101bb3:	89 04 24             	mov    %eax,(%esp)
c0101bb6:	e8 05 f3 ff ff       	call   c0100ec0 <fetch_pcb>
c0101bbb:	89 74 24 08          	mov    %esi,0x8(%esp)
c0101bbf:	89 7c 24 04          	mov    %edi,0x4(%esp)
canonic_wakeup_read(void) {
	int i, nread = 0;
	static struct Message m;

	if (top != NULL && f != r) {
		for (i = 0; i < top->length && input_pool[f] != 0; i ++) {
c0101bc3:	89 df                	mov    %ebx,%edi
			copy_from_kernel(fetch_pcb(top->pid),
c0101bc5:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
c0101bcc:	00 
c0101bcd:	89 04 24             	mov    %eax,(%esp)
c0101bd0:	e8 fb f2 ff ff       	call   c0100ed0 <copy_from_kernel>
					top->buf + i, input_pool + f, 1);
			f = (f + 1) % NR_INPUT_POOL;
c0101bd5:	a1 00 60 10 c0       	mov    0xc0106000,%eax
c0101bda:	83 c0 01             	add    $0x1,%eax
c0101bdd:	89 c2                	mov    %eax,%edx
c0101bdf:	c1 fa 1f             	sar    $0x1f,%edx
c0101be2:	c1 ea 16             	shr    $0x16,%edx
c0101be5:	01 d0                	add    %edx,%eax
c0101be7:	25 ff 03 00 00       	and    $0x3ff,%eax
c0101bec:	29 d0                	sub    %edx,%eax
canonic_wakeup_read(void) {
	int i, nread = 0;
	static struct Message m;

	if (top != NULL && f != r) {
		for (i = 0; i < top->length && input_pool[f] != 0; i ++) {
c0101bee:	8b 15 64 59 10 c0    	mov    0xc0105964,%edx
			copy_from_kernel(fetch_pcb(top->pid),
					top->buf + i, input_pool + f, 1);
			f = (f + 1) % NR_INPUT_POOL;
c0101bf4:	89 c6                	mov    %eax,%esi
c0101bf6:	a3 00 60 10 c0       	mov    %eax,0xc0106000
canonic_wakeup_read(void) {
	int i, nread = 0;
	static struct Message m;

	if (top != NULL && f != r) {
		for (i = 0; i < top->length && input_pool[f] != 0; i ++) {
c0101bfb:	3b 5a 08             	cmp    0x8(%edx),%ebx
c0101bfe:	72 98                	jb     c0101b98 <canonic_wakeup_read+0x48>
			copy_from_kernel(fetch_pcb(top->pid),
					top->buf + i, input_pool + f, 1);
			f = (f + 1) % NR_INPUT_POOL;
			nread ++;
		}
		if (input_pool[f] == 0) {
c0101c00:	80 be 00 5c 10 c0 00 	cmpb   $0x0,-0x3fefa400(%esi)
c0101c07:	74 3f                	je     c0101c48 <canonic_wakeup_read+0xf8>
			f = (f + 1) % NR_INPUT_POOL;
		}
		m.int_msg.p1 = nread;
c0101c09:	89 1d 10 60 10 c0    	mov    %ebx,0xc0106010
		send(top->pid, &m);
c0101c0f:	c7 44 24 04 04 60 10 	movl   $0xc0106004,0x4(%esp)
c0101c16:	c0 
c0101c17:	8b 02                	mov    (%edx),%eax
c0101c19:	89 04 24             	mov    %eax,(%esp)
c0101c1c:	e8 cf fa ff ff       	call   c01016f0 <send>
		read_stack_pop(top);
c0101c21:	a1 64 59 10 c0       	mov    0xc0105964,%eax
	top->buf = buf;
	top->length = length;
}
static void
read_stack_pop(struct ReadStack *ptr) {
	top = top->next;
c0101c26:	8b 50 0c             	mov    0xc(%eax),%edx
c0101c29:	89 15 64 59 10 c0    	mov    %edx,0xc0105964
	ptr->next = free;
c0101c2f:	8b 15 60 59 10 c0    	mov    0xc0105960,%edx
	free = ptr;
c0101c35:	a3 60 59 10 c0       	mov    %eax,0xc0105960
	top->length = length;
}
static void
read_stack_pop(struct ReadStack *ptr) {
	top = top->next;
	ptr->next = free;
c0101c3a:	89 50 0c             	mov    %edx,0xc(%eax)
		}
		m.int_msg.p1 = nread;
		send(top->pid, &m);
		read_stack_pop(top);
	}
}
c0101c3d:	83 c4 10             	add    $0x10,%esp
c0101c40:	5b                   	pop    %ebx
c0101c41:	5e                   	pop    %esi
c0101c42:	5f                   	pop    %edi
c0101c43:	c3                   	ret    
canonic_wakeup_read(void) {
	int i, nread = 0;
	static struct Message m;

	if (top != NULL && f != r) {
		for (i = 0; i < top->length && input_pool[f] != 0; i ++) {
c0101c44:	31 db                	xor    %ebx,%ebx
c0101c46:	66 90                	xchg   %ax,%ax
					top->buf + i, input_pool + f, 1);
			f = (f + 1) % NR_INPUT_POOL;
			nread ++;
		}
		if (input_pool[f] == 0) {
			f = (f + 1) % NR_INPUT_POOL;
c0101c48:	83 c6 01             	add    $0x1,%esi
c0101c4b:	89 f0                	mov    %esi,%eax
c0101c4d:	c1 f8 1f             	sar    $0x1f,%eax
c0101c50:	c1 e8 16             	shr    $0x16,%eax
c0101c53:	01 c6                	add    %eax,%esi
c0101c55:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
c0101c5b:	29 c6                	sub    %eax,%esi
c0101c5d:	89 35 00 60 10 c0    	mov    %esi,0xc0106000
c0101c63:	eb a4                	jmp    c0101c09 <canonic_wakeup_read+0xb9>
canonic_wakeup_read(void) {
	int i, nread = 0;
	static struct Message m;

	if (top != NULL && f != r) {
		for (i = 0; i < top->length && input_pool[f] != 0; i ++) {
c0101c65:	31 db                	xor    %ebx,%ebx
c0101c67:	eb 97                	jmp    c0101c00 <canonic_wakeup_read+0xb0>
c0101c69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

c0101c70 <tty_driver_initialize>:
static void canonic_mode_getch(uint_32);
static void canonic_mode_write(struct PCB *, void *, uint_32);
static void canonic_wakeup_read(void);


void tty_driver_initialize(void) {
c0101c70:	83 ec 1c             	sub    $0x1c,%esp

	add_irq_handle(1, keyboard_intr);
c0101c73:	c7 44 24 04 30 1b 10 	movl   $0xc0101b30,0x4(%esp)
c0101c7a:	c0 
c0101c7b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c0101c82:	e8 c9 ef ff ff       	call   c0100c50 <add_irq_handle>
c0101c87:	b8 01 00 00 00       	mov    $0x1,%eax
c0101c8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void canonic_mode_getch(uint_32);
static void canonic_mode_write(struct PCB *, void *, uint_32);
static void canonic_wakeup_read(void);


void tty_driver_initialize(void) {
c0101c90:	89 c2                	mov    %eax,%edx

static void
init_read_stack(void) {
	int i;
	for (i = 0; i < NR_PROCESS - 1; i ++) {
		read_pool[i].next = &read_pool[i + 1];
c0101c92:	83 c0 01             	add    $0x1,%eax
static void canonic_mode_getch(uint_32);
static void canonic_mode_write(struct PCB *, void *, uint_32);
static void canonic_wakeup_read(void);


void tty_driver_initialize(void) {
c0101c95:	c1 e2 04             	shl    $0x4,%edx
}

static void
init_read_stack(void) {
	int i;
	for (i = 0; i < NR_PROCESS - 1; i ++) {
c0101c98:	83 f8 20             	cmp    $0x20,%eax
		read_pool[i].next = &read_pool[i + 1];
c0101c9b:	8d 8a 60 57 10 c0    	lea    -0x3fefa8a0(%edx),%ecx
c0101ca1:	89 8a 5c 57 10 c0    	mov    %ecx,-0x3fefa8a4(%edx)
}

static void
init_read_stack(void) {
	int i;
	for (i = 0; i < NR_PROCESS - 1; i ++) {
c0101ca7:	75 e7                	jne    c0101c90 <tty_driver_initialize+0x20>
		read_pool[i].next = &read_pool[i + 1];
	}
	read_pool[i].next = NULL;
c0101ca9:	c7 05 5c 59 10 c0 00 	movl   $0x0,0xc010595c
c0101cb0:	00 00 00 
	free = read_pool;
c0101cb3:	c7 05 60 59 10 c0 60 	movl   $0xc0105760,0xc0105960
c0101cba:	57 10 c0 
	top = NULL;
c0101cbd:	c7 05 64 59 10 c0 00 	movl   $0x0,0xc0105964
c0101cc4:	00 00 00 

void tty_driver_initialize(void) {

	add_irq_handle(1, keyboard_intr);
	init_read_stack();
}
c0101cc7:	83 c4 1c             	add    $0x1c,%esp
c0101cca:	c3                   	ret    
c0101ccb:	90                   	nop
c0101ccc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c0101cd0 <tty_driver_thread>:
	

void
tty_driver_thread(void) {
c0101cd0:	55                   	push   %ebp
c0101cd1:	57                   	push   %edi
c0101cd2:	56                   	push   %esi
c0101cd3:	53                   	push   %ebx
c0101cd4:	83 ec 2c             	sub    $0x2c,%esp
c0101cd7:	90                   	nop
	static struct Message m;

	while (TRUE) {
		receive(ANY, &m);
c0101cd8:	c7 44 24 04 68 59 10 	movl   $0xc0105968,0x4(%esp)
c0101cdf:	c0 
c0101ce0:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0101ce7:	e8 04 fb ff ff       	call   c01017f0 <receive>
		if (m.src == MSG_HARD_INTR) {
c0101cec:	83 3d 68 59 10 c0 80 	cmpl   $0xffffff80,0xc0105968
c0101cf3:	0f 84 d7 00 00 00    	je     c0101dd0 <tty_driver_thread+0x100>

			if (mode == MODE_CANONIC) {
				canonic_mode_getch(code);
			}
		} else {
			switch (m.type) {
c0101cf9:	a1 70 59 10 c0       	mov    0xc0105970,%eax
c0101cfe:	83 f8 0c             	cmp    $0xc,%eax
c0101d01:	0f 84 09 02 00 00    	je     c0101f10 <tty_driver_thread+0x240>
c0101d07:	83 f8 0d             	cmp    $0xd,%eax
c0101d0a:	75 cc                	jne    c0101cd8 <tty_driver_thread+0x8>
					read_stack_push(m.dev_io.pid, m.dev_io.buf, m.dev_io.length);
					canonic_wakeup_read();
					break;
				case DEV_WRITE:
					if (mode == MODE_CANONIC) {
						struct PCB *pcb = fetch_pcb(m.dev_io.pid);
c0101d0c:	a1 74 59 10 c0       	mov    0xc0105974,%eax
c0101d11:	89 04 24             	mov    %eax,(%esp)
c0101d14:	e8 a7 f1 ff ff       	call   c0100ec0 <fetch_pcb>
						canonic_mode_write(pcb, m.dev_io.buf, m.dev_io.length);
c0101d19:	8b 2d 80 59 10 c0    	mov    0xc0105980,%ebp
static void
canonic_mode_write(struct PCB *pcb, void *buf, uint_32 length) {
	uint_32 i, j, count;
	static struct Message m;

	for (i = 0; i < length; i += NR_OUTPUT_BUF) {
c0101d1f:	85 ed                	test   %ebp,%ebp
					read_stack_push(m.dev_io.pid, m.dev_io.buf, m.dev_io.length);
					canonic_wakeup_read();
					break;
				case DEV_WRITE:
					if (mode == MODE_CANONIC) {
						struct PCB *pcb = fetch_pcb(m.dev_io.pid);
c0101d21:	89 44 24 18          	mov    %eax,0x18(%esp)
						canonic_mode_write(pcb, m.dev_io.buf, m.dev_io.length);
c0101d25:	a1 78 59 10 c0       	mov    0xc0105978,%eax
c0101d2a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
static void
canonic_mode_write(struct PCB *pcb, void *buf, uint_32 length) {
	uint_32 i, j, count;
	static struct Message m;

	for (i = 0; i < length; i += NR_OUTPUT_BUF) {
c0101d2e:	74 68                	je     c0101d98 <tty_driver_thread+0xc8>
c0101d30:	31 ff                	xor    %edi,%edi
c0101d32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	init_read_stack();
}
	

void
tty_driver_thread(void) {
c0101d38:	8b 44 24 1c          	mov    0x1c(%esp),%eax
canonic_mode_write(struct PCB *pcb, void *buf, uint_32 length) {
	uint_32 i, j, count;
	static struct Message m;

	for (i = 0; i < length; i += NR_OUTPUT_BUF) {
		count = (length - i >= NR_OUTPUT_BUF) ? NR_OUTPUT_BUF : length - i;
c0101d3c:	89 ee                	mov    %ebp,%esi
c0101d3e:	ba 00 01 00 00       	mov    $0x100,%edx
c0101d43:	29 fe                	sub    %edi,%esi
c0101d45:	81 fe 00 01 00 00    	cmp    $0x100,%esi
c0101d4b:	0f 47 f2             	cmova  %edx,%esi
	init_read_stack();
}
	

void
tty_driver_thread(void) {
c0101d4e:	01 f8                	add    %edi,%eax
	uint_32 i, j, count;
	static struct Message m;

	for (i = 0; i < length; i += NR_OUTPUT_BUF) {
		count = (length - i >= NR_OUTPUT_BUF) ? NR_OUTPUT_BUF : length - i;
		copy_to_kernel(pcb, output_buffer, buf + i, count);
c0101d50:	89 44 24 08          	mov    %eax,0x8(%esp)
c0101d54:	8b 44 24 18          	mov    0x18(%esp),%eax
c0101d58:	89 74 24 0c          	mov    %esi,0xc(%esp)
c0101d5c:	c7 44 24 04 a0 59 10 	movl   $0xc01059a0,0x4(%esp)
c0101d63:	c0 
c0101d64:	89 04 24             	mov    %eax,(%esp)
c0101d67:	e8 24 f2 ff ff       	call   c0100f90 <copy_to_kernel>
		for (j = 0; j < count; j ++) {
c0101d6c:	85 f6                	test   %esi,%esi
c0101d6e:	74 1e                	je     c0101d8e <tty_driver_thread+0xbe>
c0101d70:	31 db                	xor    %ebx,%ebx
c0101d72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			console_printc( ((char*)output_buffer)[j] );
c0101d78:	0f be 83 a0 59 10 c0 	movsbl -0x3fefa660(%ebx),%eax
	static struct Message m;

	for (i = 0; i < length; i += NR_OUTPUT_BUF) {
		count = (length - i >= NR_OUTPUT_BUF) ? NR_OUTPUT_BUF : length - i;
		copy_to_kernel(pcb, output_buffer, buf + i, count);
		for (j = 0; j < count; j ++) {
c0101d7f:	83 c3 01             	add    $0x1,%ebx
			console_printc( ((char*)output_buffer)[j] );
c0101d82:	89 04 24             	mov    %eax,(%esp)
c0101d85:	e8 d6 e5 ff ff       	call   c0100360 <console_printc>
	static struct Message m;

	for (i = 0; i < length; i += NR_OUTPUT_BUF) {
		count = (length - i >= NR_OUTPUT_BUF) ? NR_OUTPUT_BUF : length - i;
		copy_to_kernel(pcb, output_buffer, buf + i, count);
		for (j = 0; j < count; j ++) {
c0101d8a:	39 f3                	cmp    %esi,%ebx
c0101d8c:	75 ea                	jne    c0101d78 <tty_driver_thread+0xa8>
static void
canonic_mode_write(struct PCB *pcb, void *buf, uint_32 length) {
	uint_32 i, j, count;
	static struct Message m;

	for (i = 0; i < length; i += NR_OUTPUT_BUF) {
c0101d8e:	81 c7 00 01 00 00    	add    $0x100,%edi
c0101d94:	39 fd                	cmp    %edi,%ebp
c0101d96:	77 a0                	ja     c0101d38 <tty_driver_thread+0x68>
		copy_to_kernel(pcb, output_buffer, buf + i, count);
		for (j = 0; j < count; j ++) {
			console_printc( ((char*)output_buffer)[j] );
		}
	}
	if (input_length != 0) {
c0101d98:	8b 15 a0 5a 10 c0    	mov    0xc0105aa0,%edx
c0101d9e:	85 d2                	test   %edx,%edx
c0101da0:	74 07                	je     c0101da9 <tty_driver_thread+0xd9>
		dirty = TRUE;
c0101da2:	c6 05 a4 5a 10 c0 01 	movb   $0x1,0xc0105aa4
	}

	m.int_msg.p1 = length;
	send(pcb->pid, &m);
c0101da9:	8b 54 24 18          	mov    0x18(%esp),%edx
c0101dad:	c7 44 24 04 a8 5a 10 	movl   $0xc0105aa8,0x4(%esp)
c0101db4:	c0 
	}
	if (input_length != 0) {
		dirty = TRUE;
	}

	m.int_msg.p1 = length;
c0101db5:	89 2d b4 5a 10 c0    	mov    %ebp,0xc0105ab4
	send(pcb->pid, &m);
c0101dbb:	8b 82 1c 20 00 00    	mov    0x201c(%edx),%eax
c0101dc1:	89 04 24             	mov    %eax,(%esp)
c0101dc4:	e8 27 f9 ff ff       	call   c01016f0 <send>
c0101dc9:	e9 0a ff ff ff       	jmp    c0101cd8 <tty_driver_thread+0x8>
c0101dce:	66 90                	xchg   %ax,%ax
//#include "kernel.h"

static inline uint_8
in_byte(uint_16 port) {
	uint_8 data;
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
c0101dd0:	ba 60 00 00 00       	mov    $0x60,%edx
c0101dd5:	ec                   	in     (%dx),%al
c0101dd6:	89 c3                	mov    %eax,%ebx
c0101dd8:	b2 61                	mov    $0x61,%dl
c0101dda:	ec                   	in     (%dx),%al
c0101ddb:	89 c1                	mov    %eax,%ecx
	while (TRUE) {
		receive(ANY, &m);
		if (m.src == MSG_HARD_INTR) {
			uint_32 code = in_byte(0x60);
			uint_32 val  = in_byte(0x61);
			out_byte(0x61, val | 0x80);
c0101ddd:	83 c8 80             	or     $0xffffff80,%eax
	return data;
}

static inline void
out_byte(uint_16 port, uint_8 data) {
	asm volatile("out %%al, %%dx" : : "a"(data), "d"(port));
c0101de0:	ee                   	out    %al,(%dx)
c0101de1:	89 c8                	mov    %ecx,%eax
c0101de3:	ee                   	out    %al,(%dx)
	static struct Message m;

	while (TRUE) {
		receive(ANY, &m);
		if (m.src == MSG_HARD_INTR) {
			uint_32 code = in_byte(0x60);
c0101de4:	0f b6 c3             	movzbl %bl,%eax

static char
get_ascii(int code) {
	int index;

	switch (code) {
c0101de7:	83 f8 3a             	cmp    $0x3a,%eax
c0101dea:	0f 84 e0 02 00 00    	je     c01020d0 <tty_driver_thread+0x400>
c0101df0:	0f 8f 5a 01 00 00    	jg     c0101f50 <tty_driver_thread+0x280>
c0101df6:	83 f8 2a             	cmp    $0x2a,%eax
c0101df9:	0f 84 df 02 00 00    	je     c01020de <tty_driver_thread+0x40e>
c0101dff:	83 f8 36             	cmp    $0x36,%eax
c0101e02:	0f 84 d6 02 00 00    	je     c01020de <tty_driver_thread+0x40e>
		case CAPS_OFF:
			caps_on = FALSE;
			return 0;
	}

	index = shift_level > 0;
c0101e08:	8b 0d c4 5a 10 c0    	mov    0xc0105ac4,%ecx
c0101e0e:	31 d2                	xor    %edx,%edx
c0101e10:	85 c9                	test   %ecx,%ecx
	if (key_maps[0][code] >= 'a' && key_maps[0][code] <= 'z') {
c0101e12:	8b 0c 85 e0 35 10 c0 	mov    -0x3fefca20(,%eax,4),%ecx
		case CAPS_OFF:
			caps_on = FALSE;
			return 0;
	}

	index = shift_level > 0;
c0101e19:	0f 9f c2             	setg   %dl
	if (key_maps[0][code] >= 'a' && key_maps[0][code] <= 'z') {
c0101e1c:	83 e9 61             	sub    $0x61,%ecx
c0101e1f:	83 f9 19             	cmp    $0x19,%ecx
c0101e22:	77 09                	ja     c0101e2d <tty_driver_thread+0x15d>
		index ^= caps_on;
c0101e24:	0f b6 0d c8 5a 10 c0 	movzbl 0xc0105ac8,%ecx
c0101e2b:	31 ca                	xor    %ecx,%edx
	}
	return key_maps[index][code];
c0101e2d:	c1 e2 08             	shl    $0x8,%edx
c0101e30:	01 d0                	add    %edx,%eax
c0101e32:	0f b6 2c 85 e0 35 10 	movzbl -0x3fefca20(,%eax,4),%ebp
c0101e39:	c0 
}

static void
update_input(void) {
	int i;
	if (dirty == TRUE) {
c0101e3a:	80 3d a4 5a 10 c0 01 	cmpb   $0x1,0xc0105aa4
c0101e41:	0f 84 3c 01 00 00    	je     c0101f83 <tty_driver_thread+0x2b3>
canonic_mode_getch(uint_32 code) {
	char ch = get_ascii(code);
	int i;

	update_input();
	if (ch != 0) {
c0101e47:	89 ea                	mov    %ebp,%edx
c0101e49:	84 d2                	test   %dl,%dl
c0101e4b:	0f 85 b2 01 00 00    	jne    c0102003 <tty_driver_thread+0x333>
		for (i = cursor_pos; i < input_length; i ++) {
			console_printc(input_buffer[i]);
		}
		cursor_left(input_length - cursor_pos);
	} else {
		switch (code) {
c0101e51:	80 fb 1c             	cmp    $0x1c,%bl
c0101e54:	0f 84 c6 02 00 00    	je     c0102120 <tty_driver_thread+0x450>
c0101e5a:	0f 87 36 02 00 00    	ja     c0102096 <tty_driver_thread+0x3c6>
c0101e60:	80 fb 0e             	cmp    $0xe,%bl
c0101e63:	0f 85 6f fe ff ff    	jne    c0101cd8 <tty_driver_thread+0x8>
			case BACK:
				if (cursor_pos > 0) {
c0101e69:	a1 e0 5b 10 c0       	mov    0xc0105be0,%eax
c0101e6e:	85 c0                	test   %eax,%eax
c0101e70:	0f 8e 62 fe ff ff    	jle    c0101cd8 <tty_driver_thread+0x8>
					for (i = cursor_pos - 1; i < input_length; i ++) {
c0101e76:	8b 1d a0 5a 10 c0    	mov    0xc0105aa0,%ebx
c0101e7c:	8d 70 ff             	lea    -0x1(%eax),%esi
c0101e7f:	39 f3                	cmp    %esi,%ebx
c0101e81:	7e 1a                	jle    c0101e9d <tty_driver_thread+0x1cd>
	init_read_stack();
}
	

void
tty_driver_thread(void) {
c0101e83:	05 e0 5a 10 c0       	add    $0xc0105ae0,%eax
c0101e88:	8d 8b e1 5a 10 c0    	lea    -0x3fefa51f(%ebx),%ecx
c0101e8e:	66 90                	xchg   %ax,%ax
	} else {
		switch (code) {
			case BACK:
				if (cursor_pos > 0) {
					for (i = cursor_pos - 1; i < input_length; i ++) {
						input_buffer[i] = input_buffer[i + 1];
c0101e90:	0f b6 10             	movzbl (%eax),%edx
c0101e93:	88 50 ff             	mov    %dl,-0x1(%eax)
c0101e96:	83 c0 01             	add    $0x1,%eax
		cursor_left(input_length - cursor_pos);
	} else {
		switch (code) {
			case BACK:
				if (cursor_pos > 0) {
					for (i = cursor_pos - 1; i < input_length; i ++) {
c0101e99:	39 c8                	cmp    %ecx,%eax
c0101e9b:	75 f3                	jne    c0101e90 <tty_driver_thread+0x1c0>
						input_buffer[i] = input_buffer[i + 1];
					}
					input_length --;
c0101e9d:	83 eb 01             	sub    $0x1,%ebx
					cursor_pos --;
					cursor_left(1);
c0101ea0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
			case BACK:
				if (cursor_pos > 0) {
					for (i = cursor_pos - 1; i < input_length; i ++) {
						input_buffer[i] = input_buffer[i + 1];
					}
					input_length --;
c0101ea7:	89 1d a0 5a 10 c0    	mov    %ebx,0xc0105aa0
					cursor_pos --;
c0101ead:	89 35 e0 5b 10 c0    	mov    %esi,0xc0105be0
					cursor_left(1);
c0101eb3:	e8 48 e2 ff ff       	call   c0100100 <cursor_left>
					for (i = cursor_pos; i < input_length; i ++) {
c0101eb8:	8b 1d e0 5b 10 c0    	mov    0xc0105be0,%ebx
c0101ebe:	39 1d a0 5a 10 c0    	cmp    %ebx,0xc0105aa0
c0101ec4:	7e 1c                	jle    c0101ee2 <tty_driver_thread+0x212>
c0101ec6:	66 90                	xchg   %ax,%ax
						console_printc(input_buffer[i]);
c0101ec8:	0f be 83 e0 5a 10 c0 	movsbl -0x3fefa520(%ebx),%eax
						input_buffer[i] = input_buffer[i + 1];
					}
					input_length --;
					cursor_pos --;
					cursor_left(1);
					for (i = cursor_pos; i < input_length; i ++) {
c0101ecf:	83 c3 01             	add    $0x1,%ebx
						console_printc(input_buffer[i]);
c0101ed2:	89 04 24             	mov    %eax,(%esp)
c0101ed5:	e8 86 e4 ff ff       	call   c0100360 <console_printc>
						input_buffer[i] = input_buffer[i + 1];
					}
					input_length --;
					cursor_pos --;
					cursor_left(1);
					for (i = cursor_pos; i < input_length; i ++) {
c0101eda:	3b 1d a0 5a 10 c0    	cmp    0xc0105aa0,%ebx
c0101ee0:	7c e6                	jl     c0101ec8 <tty_driver_thread+0x1f8>
						console_printc(input_buffer[i]);
					}
					console_printc(' ');
c0101ee2:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c0101ee9:	e8 72 e4 ff ff       	call   c0100360 <console_printc>
					cursor_left(input_length - cursor_pos + 1);
c0101eee:	a1 a0 5a 10 c0       	mov    0xc0105aa0,%eax
c0101ef3:	2b 05 e0 5b 10 c0    	sub    0xc0105be0,%eax
c0101ef9:	83 c0 01             	add    $0x1,%eax
c0101efc:	89 04 24             	mov    %eax,(%esp)
c0101eff:	e8 fc e1 ff ff       	call   c0100100 <cursor_left>
c0101f04:	e9 cf fd ff ff       	jmp    c0101cd8 <tty_driver_thread+0x8>
c0101f09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	top = NULL;
}

static void
read_stack_push(pid_t pid, void *buf, uint_32 length) {
	struct ReadStack *ptr = free;
c0101f10:	a1 60 59 10 c0       	mov    0xc0105960,%eax
				canonic_mode_getch(code);
			}
		} else {
			switch (m.type) {
				case DEV_READ:
					read_stack_push(m.dev_io.pid, m.dev_io.buf, m.dev_io.length);
c0101f15:	8b 15 80 59 10 c0    	mov    0xc0105980,%edx
c0101f1b:	8b 0d 78 59 10 c0    	mov    0xc0105978,%ecx
c0101f21:	8b 1d 74 59 10 c0    	mov    0xc0105974,%ebx
}

static void
read_stack_push(pid_t pid, void *buf, uint_32 length) {
	struct ReadStack *ptr = free;
	free = free->next;
c0101f27:	8b 70 0c             	mov    0xc(%eax),%esi
	ptr->next = top;
	top = ptr;
	top->pid = pid;
	top->buf = buf;
	top->length = length;
c0101f2a:	89 50 08             	mov    %edx,0x8(%eax)
	struct ReadStack *ptr = free;
	free = free->next;
	ptr->next = top;
	top = ptr;
	top->pid = pid;
	top->buf = buf;
c0101f2d:	89 48 04             	mov    %ecx,0x4(%eax)
read_stack_push(pid_t pid, void *buf, uint_32 length) {
	struct ReadStack *ptr = free;
	free = free->next;
	ptr->next = top;
	top = ptr;
	top->pid = pid;
c0101f30:	89 18                	mov    %ebx,(%eax)
}

static void
read_stack_push(pid_t pid, void *buf, uint_32 length) {
	struct ReadStack *ptr = free;
	free = free->next;
c0101f32:	89 35 60 59 10 c0    	mov    %esi,0xc0105960
	ptr->next = top;
c0101f38:	8b 35 64 59 10 c0    	mov    0xc0105964,%esi
	top = ptr;
c0101f3e:	a3 64 59 10 c0       	mov    %eax,0xc0105964

static void
read_stack_push(pid_t pid, void *buf, uint_32 length) {
	struct ReadStack *ptr = free;
	free = free->next;
	ptr->next = top;
c0101f43:	89 70 0c             	mov    %esi,0xc(%eax)
			}
		} else {
			switch (m.type) {
				case DEV_READ:
					read_stack_push(m.dev_io.pid, m.dev_io.buf, m.dev_io.length);
					canonic_wakeup_read();
c0101f46:	e8 05 fc ff ff       	call   c0101b50 <canonic_wakeup_read>
					break;
c0101f4b:	e9 88 fd ff ff       	jmp    c0101cd8 <tty_driver_thread+0x8>

static char
get_ascii(int code) {
	int index;

	switch (code) {
c0101f50:	3d b6 00 00 00       	cmp    $0xb6,%eax
c0101f55:	74 16                	je     c0101f6d <tty_driver_thread+0x29d>
c0101f57:	3d ba 00 00 00       	cmp    $0xba,%eax
c0101f5c:	0f 84 8a 01 00 00    	je     c01020ec <tty_driver_thread+0x41c>
c0101f62:	3d aa 00 00 00       	cmp    $0xaa,%eax
c0101f67:	0f 85 9b fe ff ff    	jne    c0101e08 <tty_driver_thread+0x138>
		case LSHIFT_DOWN: case RSHIFT_DOWN:
			shift_level ++;
			return 0;
		case LSHIFT_UP: case RSHIFT_UP:
			shift_level --;
c0101f6d:	83 2d c4 5a 10 c0 01 	subl   $0x1,0xc0105ac4
			return 0;
c0101f74:	31 ed                	xor    %ebp,%ebp
}

static void
update_input(void) {
	int i;
	if (dirty == TRUE) {
c0101f76:	80 3d a4 5a 10 c0 01 	cmpb   $0x1,0xc0105aa4
c0101f7d:	0f 85 c4 fe ff ff    	jne    c0101e47 <tty_driver_thread+0x177>
		dirty = FALSE;
		console_printc('\n');
c0101f83:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)

static void
update_input(void) {
	int i;
	if (dirty == TRUE) {
		dirty = FALSE;
c0101f8a:	c6 05 a4 5a 10 c0 00 	movb   $0x0,0xc0105aa4
		console_printc('\n');
c0101f91:	e8 ca e3 ff ff       	call   c0100360 <console_printc>
		for (i = 0; i < cursor_pos; i ++) {
c0101f96:	8b 35 e0 5b 10 c0    	mov    0xc0105be0,%esi
c0101f9c:	85 f6                	test   %esi,%esi
c0101f9e:	7e 42                	jle    c0101fe2 <tty_driver_thread+0x312>
c0101fa0:	31 ff                	xor    %edi,%edi
c0101fa2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			console_printc(input_buffer[i]);
c0101fa8:	0f be 87 e0 5a 10 c0 	movsbl -0x3fefa520(%edi),%eax
update_input(void) {
	int i;
	if (dirty == TRUE) {
		dirty = FALSE;
		console_printc('\n');
		for (i = 0; i < cursor_pos; i ++) {
c0101faf:	83 c7 01             	add    $0x1,%edi
			console_printc(input_buffer[i]);
c0101fb2:	89 04 24             	mov    %eax,(%esp)
c0101fb5:	e8 a6 e3 ff ff       	call   c0100360 <console_printc>
update_input(void) {
	int i;
	if (dirty == TRUE) {
		dirty = FALSE;
		console_printc('\n');
		for (i = 0; i < cursor_pos; i ++) {
c0101fba:	8b 35 e0 5b 10 c0    	mov    0xc0105be0,%esi
c0101fc0:	39 f7                	cmp    %esi,%edi
c0101fc2:	7c e4                	jl     c0101fa8 <tty_driver_thread+0x2d8>
			console_printc(input_buffer[i]);
		}
		for (i = cursor_pos; i < input_length; i ++) {
c0101fc4:	a1 a0 5a 10 c0       	mov    0xc0105aa0,%eax
c0101fc9:	39 c6                	cmp    %eax,%esi
c0101fcb:	7d 1e                	jge    c0101feb <tty_driver_thread+0x31b>
c0101fcd:	8d 76 00             	lea    0x0(%esi),%esi
			console_printc(input_buffer[i]);
c0101fd0:	0f be 86 e0 5a 10 c0 	movsbl -0x3fefa520(%esi),%eax
		dirty = FALSE;
		console_printc('\n');
		for (i = 0; i < cursor_pos; i ++) {
			console_printc(input_buffer[i]);
		}
		for (i = cursor_pos; i < input_length; i ++) {
c0101fd7:	83 c6 01             	add    $0x1,%esi
			console_printc(input_buffer[i]);
c0101fda:	89 04 24             	mov    %eax,(%esp)
c0101fdd:	e8 7e e3 ff ff       	call   c0100360 <console_printc>
		dirty = FALSE;
		console_printc('\n');
		for (i = 0; i < cursor_pos; i ++) {
			console_printc(input_buffer[i]);
		}
		for (i = cursor_pos; i < input_length; i ++) {
c0101fe2:	a1 a0 5a 10 c0       	mov    0xc0105aa0,%eax
c0101fe7:	39 c6                	cmp    %eax,%esi
c0101fe9:	7c e5                	jl     c0101fd0 <tty_driver_thread+0x300>
			console_printc(input_buffer[i]);
		}
		cursor_left(input_length - cursor_pos);
c0101feb:	2b 05 e0 5b 10 c0    	sub    0xc0105be0,%eax
c0101ff1:	89 04 24             	mov    %eax,(%esp)
c0101ff4:	e8 07 e1 ff ff       	call   c0100100 <cursor_left>
canonic_mode_getch(uint_32 code) {
	char ch = get_ascii(code);
	int i;

	update_input();
	if (ch != 0) {
c0101ff9:	89 ea                	mov    %ebp,%edx
c0101ffb:	84 d2                	test   %dl,%dl
c0101ffd:	0f 84 4e fe ff ff    	je     c0101e51 <tty_driver_thread+0x181>
		console_printc(ch);
c0102003:	0f be c2             	movsbl %dl,%eax
c0102006:	89 04 24             	mov    %eax,(%esp)
c0102009:	e8 52 e3 ff ff       	call   c0100360 <console_printc>
		for (i = input_length; i > cursor_pos; i --) {
c010200e:	8b 35 a0 5a 10 c0    	mov    0xc0105aa0,%esi
c0102014:	8b 1d e0 5b 10 c0    	mov    0xc0105be0,%ebx
c010201a:	39 de                	cmp    %ebx,%esi
c010201c:	7e 1f                	jle    c010203d <tty_driver_thread+0x36d>
	init_read_stack();
}
	

void
tty_driver_thread(void) {
c010201e:	8d 86 df 5a 10 c0    	lea    -0x3fefa521(%esi),%eax
c0102024:	8d 8b df 5a 10 c0    	lea    -0x3fefa521(%ebx),%ecx
c010202a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	update_input();
	if (ch != 0) {
		console_printc(ch);
		for (i = input_length; i > cursor_pos; i --) {
			input_buffer[i] = input_buffer[i - 1];
c0102030:	0f b6 10             	movzbl (%eax),%edx
c0102033:	88 50 01             	mov    %dl,0x1(%eax)
c0102036:	83 e8 01             	sub    $0x1,%eax
	int i;

	update_input();
	if (ch != 0) {
		console_printc(ch);
		for (i = input_length; i > cursor_pos; i --) {
c0102039:	39 c8                	cmp    %ecx,%eax
c010203b:	75 f3                	jne    c0102030 <tty_driver_thread+0x360>
			input_buffer[i] = input_buffer[i - 1];
		}
		input_buffer[++ input_length] = 0;
c010203d:	8d 46 01             	lea    0x1(%esi),%eax
		input_buffer[cursor_pos ++] = ch;
c0102040:	89 ea                	mov    %ebp,%edx
	if (ch != 0) {
		console_printc(ch);
		for (i = input_length; i > cursor_pos; i --) {
			input_buffer[i] = input_buffer[i - 1];
		}
		input_buffer[++ input_length] = 0;
c0102042:	c6 80 e0 5a 10 c0 00 	movb   $0x0,-0x3fefa520(%eax)
		input_buffer[cursor_pos ++] = ch;
c0102049:	88 93 e0 5a 10 c0    	mov    %dl,-0x3fefa520(%ebx)
c010204f:	83 c3 01             	add    $0x1,%ebx
		for (i = cursor_pos; i < input_length; i ++) {
c0102052:	39 d8                	cmp    %ebx,%eax
	if (ch != 0) {
		console_printc(ch);
		for (i = input_length; i > cursor_pos; i --) {
			input_buffer[i] = input_buffer[i - 1];
		}
		input_buffer[++ input_length] = 0;
c0102054:	a3 a0 5a 10 c0       	mov    %eax,0xc0105aa0
		input_buffer[cursor_pos ++] = ch;
c0102059:	89 1d e0 5b 10 c0    	mov    %ebx,0xc0105be0
		for (i = cursor_pos; i < input_length; i ++) {
c010205f:	7e 22                	jle    c0102083 <tty_driver_thread+0x3b3>
c0102061:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			console_printc(input_buffer[i]);
c0102068:	0f be 83 e0 5a 10 c0 	movsbl -0x3fefa520(%ebx),%eax
		for (i = input_length; i > cursor_pos; i --) {
			input_buffer[i] = input_buffer[i - 1];
		}
		input_buffer[++ input_length] = 0;
		input_buffer[cursor_pos ++] = ch;
		for (i = cursor_pos; i < input_length; i ++) {
c010206f:	83 c3 01             	add    $0x1,%ebx
			console_printc(input_buffer[i]);
c0102072:	89 04 24             	mov    %eax,(%esp)
c0102075:	e8 e6 e2 ff ff       	call   c0100360 <console_printc>
		for (i = input_length; i > cursor_pos; i --) {
			input_buffer[i] = input_buffer[i - 1];
		}
		input_buffer[++ input_length] = 0;
		input_buffer[cursor_pos ++] = ch;
		for (i = cursor_pos; i < input_length; i ++) {
c010207a:	a1 a0 5a 10 c0       	mov    0xc0105aa0,%eax
c010207f:	39 c3                	cmp    %eax,%ebx
c0102081:	7c e5                	jl     c0102068 <tty_driver_thread+0x398>
			console_printc(input_buffer[i]);
		}
		cursor_left(input_length - cursor_pos);
c0102083:	2b 05 e0 5b 10 c0    	sub    0xc0105be0,%eax
c0102089:	89 04 24             	mov    %eax,(%esp)
c010208c:	e8 6f e0 ff ff       	call   c0100100 <cursor_left>
c0102091:	e9 42 fc ff ff       	jmp    c0101cd8 <tty_driver_thread+0x8>
	} else {
		switch (code) {
c0102096:	80 fb 4b             	cmp    $0x4b,%bl
c0102099:	74 5f                	je     c01020fa <tty_driver_thread+0x42a>
c010209b:	80 fb 4d             	cmp    $0x4d,%bl
c010209e:	66 90                	xchg   %ax,%ax
c01020a0:	0f 85 32 fc ff ff    	jne    c0101cd8 <tty_driver_thread+0x8>
					cursor_pos --;
					cursor_left(1);
				}
				break;
			case KEY_RIGHT:
				if (cursor_pos < input_length) {
c01020a6:	a1 e0 5b 10 c0       	mov    0xc0105be0,%eax
c01020ab:	3b 05 a0 5a 10 c0    	cmp    0xc0105aa0,%eax
c01020b1:	0f 8d 21 fc ff ff    	jge    c0101cd8 <tty_driver_thread+0x8>
					cursor_pos ++;
c01020b7:	83 c0 01             	add    $0x1,%eax
					cursor_right(1);
c01020ba:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
					cursor_left(1);
				}
				break;
			case KEY_RIGHT:
				if (cursor_pos < input_length) {
					cursor_pos ++;
c01020c1:	a3 e0 5b 10 c0       	mov    %eax,0xc0105be0
					cursor_right(1);
c01020c6:	e8 d5 e0 ff ff       	call   c01001a0 <cursor_right>
c01020cb:	e9 08 fc ff ff       	jmp    c0101cd8 <tty_driver_thread+0x8>
			return 0;
		case LSHIFT_UP: case RSHIFT_UP:
			shift_level --;
			return 0;
		case CAPS_ON:
			caps_on = TRUE;
c01020d0:	c6 05 c8 5a 10 c0 01 	movb   $0x1,0xc0105ac8
			return 0;
c01020d7:	31 ed                	xor    %ebp,%ebp
c01020d9:	e9 5c fd ff ff       	jmp    c0101e3a <tty_driver_thread+0x16a>
get_ascii(int code) {
	int index;

	switch (code) {
		case LSHIFT_DOWN: case RSHIFT_DOWN:
			shift_level ++;
c01020de:	83 05 c4 5a 10 c0 01 	addl   $0x1,0xc0105ac4
			return 0;
c01020e5:	31 ed                	xor    %ebp,%ebp
c01020e7:	e9 4e fd ff ff       	jmp    c0101e3a <tty_driver_thread+0x16a>
			return 0;
		case CAPS_ON:
			caps_on = TRUE;
			return 0;
		case CAPS_OFF:
			caps_on = FALSE;
c01020ec:	c6 05 c8 5a 10 c0 00 	movb   $0x0,0xc0105ac8
			return 0;
c01020f3:	31 ed                	xor    %ebp,%ebp
c01020f5:	e9 40 fd ff ff       	jmp    c0101e3a <tty_driver_thread+0x16a>
					console_printc(' ');
					cursor_left(input_length - cursor_pos + 1);
				}
				break;
			case KEY_LEFT:
				if (cursor_pos > 0) {
c01020fa:	a1 e0 5b 10 c0       	mov    0xc0105be0,%eax
c01020ff:	85 c0                	test   %eax,%eax
c0102101:	0f 8e d1 fb ff ff    	jle    c0101cd8 <tty_driver_thread+0x8>
					cursor_pos --;
c0102107:	83 e8 01             	sub    $0x1,%eax
					cursor_left(1);
c010210a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
					cursor_left(input_length - cursor_pos + 1);
				}
				break;
			case KEY_LEFT:
				if (cursor_pos > 0) {
					cursor_pos --;
c0102111:	a3 e0 5b 10 c0       	mov    %eax,0xc0105be0
					cursor_left(1);
c0102116:	e8 e5 df ff ff       	call   c0100100 <cursor_left>
c010211b:	e9 b8 fb ff ff       	jmp    c0101cd8 <tty_driver_thread+0x8>
					cursor_pos ++;
					cursor_right(1);
				}
				break;
			case ENTER:
				input_buffer[input_length] = '\n';
c0102120:	8b 1d a0 5a 10 c0    	mov    0xc0105aa0,%ebx
				input_buffer[++ input_length] = 0;
c0102126:	8d 43 01             	lea    0x1(%ebx),%eax
				for (i = 0; i <= input_length; i ++) {
c0102129:	85 c0                	test   %eax,%eax
					cursor_pos ++;
					cursor_right(1);
				}
				break;
			case ENTER:
				input_buffer[input_length] = '\n';
c010212b:	c6 83 e0 5a 10 c0 0a 	movb   $0xa,-0x3fefa520(%ebx)
				input_buffer[++ input_length] = 0;
c0102132:	a3 a0 5a 10 c0       	mov    %eax,0xc0105aa0
c0102137:	c6 83 e1 5a 10 c0 00 	movb   $0x0,-0x3fefa51f(%ebx)
				for (i = 0; i <= input_length; i ++) {
c010213e:	78 3d                	js     c010217d <tty_driver_thread+0x4ad>
c0102140:	a1 e4 5b 10 c0       	mov    0xc0105be4,%eax
	init_read_stack();
}
	

void
tty_driver_thread(void) {
c0102145:	83 c3 02             	add    $0x2,%ebx
				}
				break;
			case ENTER:
				input_buffer[input_length] = '\n';
				input_buffer[++ input_length] = 0;
				for (i = 0; i <= input_length; i ++) {
c0102148:	31 c9                	xor    %ecx,%ecx
c010214a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					input_pool[r ++] = input_buffer[i];
c0102150:	0f b6 91 e0 5a 10 c0 	movzbl -0x3fefa520(%ecx),%edx
				}
				break;
			case ENTER:
				input_buffer[input_length] = '\n';
				input_buffer[++ input_length] = 0;
				for (i = 0; i <= input_length; i ++) {
c0102157:	83 c1 01             	add    $0x1,%ecx
					input_pool[r ++] = input_buffer[i];
c010215a:	88 90 00 5c 10 c0    	mov    %dl,-0x3fefa400(%eax)
c0102160:	83 c0 01             	add    $0x1,%eax
					r %= NR_INPUT_POOL;
c0102163:	89 c2                	mov    %eax,%edx
c0102165:	c1 fa 1f             	sar    $0x1f,%edx
c0102168:	c1 ea 16             	shr    $0x16,%edx
c010216b:	01 d0                	add    %edx,%eax
c010216d:	25 ff 03 00 00       	and    $0x3ff,%eax
c0102172:	29 d0                	sub    %edx,%eax
				}
				break;
			case ENTER:
				input_buffer[input_length] = '\n';
				input_buffer[++ input_length] = 0;
				for (i = 0; i <= input_length; i ++) {
c0102174:	39 d9                	cmp    %ebx,%ecx
c0102176:	75 d8                	jne    c0102150 <tty_driver_thread+0x480>
c0102178:	a3 e4 5b 10 c0       	mov    %eax,0xc0105be4
					input_pool[r ++] = input_buffer[i];
					r %= NR_INPUT_POOL;
				}
				canonic_wakeup_read();
c010217d:	e8 ce f9 ff ff       	call   c0101b50 <canonic_wakeup_read>
				console_printc('\n');
c0102182:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0102189:	e8 d2 e1 ff ff       	call   c0100360 <console_printc>
				input_buffer[cursor_pos = 0] = 0;
c010218e:	c7 05 e0 5b 10 c0 00 	movl   $0x0,0xc0105be0
c0102195:	00 00 00 
c0102198:	c6 05 e0 5a 10 c0 00 	movb   $0x0,0xc0105ae0
				input_length = 0;
c010219f:	c7 05 a0 5a 10 c0 00 	movl   $0x0,0xc0105aa0
c01021a6:	00 00 00 
c01021a9:	e9 2a fb ff ff       	jmp    c0101cd8 <tty_driver_thread+0x8>
c01021ae:	90                   	nop
c01021af:	90                   	nop

c01021b0 <do_write>:
		*(((uint_32*)buf) + i) = in_long(IDE_PORT_BASE);
	}
}

static void
do_write(void *buf) {
c01021b0:	53                   	push   %ebx
c01021b1:	ba f7 01 00 00       	mov    $0x1f7,%edx
c01021b6:	89 c3                	mov    %eax,%ebx
c01021b8:	83 ec 18             	sub    $0x18,%esp
c01021bb:	b8 30 00 00 00       	mov    $0x30,%eax
c01021c0:	ee                   	out    %al,(%dx)
	int i;
	static struct Message m;
	out_byte(IDE_PORT_BASE + 7, 0x30);
	for (i = 0; i < 512 / sizeof(uint_32); i ++) {
c01021c1:	31 c0                	xor    %eax,%eax
c01021c3:	31 c9                	xor    %ecx,%ecx
}

static inline void
out_long(uint_16 port, uint_32 data) {
	asm volatile("out %%eax, %%dx" : : "a"(data), "d"(port));
c01021c5:	b2 f0                	mov    $0xf0,%dl
c01021c7:	90                   	nop
c01021c8:	8b 04 83             	mov    (%ebx,%eax,4),%eax
c01021cb:	ef                   	out    %eax,(%dx)
c01021cc:	83 c1 01             	add    $0x1,%ecx
c01021cf:	81 f9 80 00 00 00    	cmp    $0x80,%ecx
c01021d5:	89 c8                	mov    %ecx,%eax
c01021d7:	75 ef                	jne    c01021c8 <do_write+0x18>
c01021d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		out_long(IDE_PORT_BASE, *(((uint_32*)buf) + i));
	}
	do {
		receive(MSG_HARD_INTR, &m);
c01021e0:	c7 44 24 04 90 62 11 	movl   $0xc0116290,0x4(%esp)
c01021e7:	c0 
c01021e8:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c01021ef:	e8 fc f5 ff ff       	call   c01017f0 <receive>
	} while (m.type != IDE_READY);
c01021f4:	83 3d 98 62 11 c0 01 	cmpl   $0x1,0xc0116298
c01021fb:	75 e3                	jne    c01021e0 <do_write+0x30>
}
c01021fd:	83 c4 18             	add    $0x18,%esp
c0102200:	5b                   	pop    %ebx
c0102201:	c3                   	ret    
c0102202:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
c0102209:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0102210 <ide_intr>:
	}
}


static void
ide_intr(void) {
c0102210:	83 ec 1c             	sub    $0x1c,%esp
	static struct Message m;
	m.type = IDE_READY;
	send(IDE, &m);
c0102213:	a1 c8 a6 1d c0       	mov    0xc01da6c8,%eax
c0102218:	c7 44 24 04 58 62 11 	movl   $0xc0116258,0x4(%esp)
c010221f:	c0 


static void
ide_intr(void) {
	static struct Message m;
	m.type = IDE_READY;
c0102220:	c7 05 60 62 11 c0 01 	movl   $0x1,0xc0116260
c0102227:	00 00 00 
	send(IDE, &m);
c010222a:	89 04 24             	mov    %eax,(%esp)
c010222d:	e8 be f4 ff ff       	call   c01016f0 <send>
}
c0102232:	83 c4 1c             	add    $0x1c,%esp
c0102235:	c3                   	ret    
c0102236:	8d 76 00             	lea    0x0(%esi),%esi
c0102239:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0102240 <time_intr>:


static void
time_intr(void) {
c0102240:	83 ec 1c             	sub    $0x1c,%esp
	static struct Message m;
	static uint_32 counter = 0;
	counter = (counter + 1) % WRITEBACK_TIME;
c0102243:	8b 0d 38 62 11 c0    	mov    0xc0116238,%ecx
c0102249:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c010224e:	83 c1 01             	add    $0x1,%ecx
c0102251:	89 c8                	mov    %ecx,%eax
c0102253:	f7 e2                	mul    %edx
c0102255:	c1 ea 05             	shr    $0x5,%edx
c0102258:	6b d2 64             	imul   $0x64,%edx,%edx
c010225b:	29 d1                	sub    %edx,%ecx
	if (counter == 0) {
c010225d:	85 c9                	test   %ecx,%ecx

static void
time_intr(void) {
	static struct Message m;
	static uint_32 counter = 0;
	counter = (counter + 1) % WRITEBACK_TIME;
c010225f:	89 0d 38 62 11 c0    	mov    %ecx,0xc0116238
	if (counter == 0) {
c0102265:	75 1f                	jne    c0102286 <time_intr+0x46>
		m.type = IDE_WRITEBACK;
		send(IDE, &m);
c0102267:	a1 c8 a6 1d c0       	mov    0xc01da6c8,%eax
c010226c:	c7 44 24 04 3c 62 11 	movl   $0xc011623c,0x4(%esp)
c0102273:	c0 
time_intr(void) {
	static struct Message m;
	static uint_32 counter = 0;
	counter = (counter + 1) % WRITEBACK_TIME;
	if (counter == 0) {
		m.type = IDE_WRITEBACK;
c0102274:	c7 05 44 62 11 c0 02 	movl   $0x2,0xc0116244
c010227b:	00 00 00 
		send(IDE, &m);
c010227e:	89 04 24             	mov    %eax,(%esp)
c0102281:	e8 6a f4 ff ff       	call   c01016f0 <send>
	}
}
c0102286:	83 c4 1c             	add    $0x1c,%esp
c0102289:	c3                   	ret    
c010228a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

c0102290 <cache_fetch>:
		cache[i].used = FALSE;
	}
}

static struct SectorCache *
cache_fetch(uint_32 sector) {
c0102290:	55                   	push   %ebp
	struct SectorCache *ptr = &cache[sector % NR_SEC_CACHE];
c0102291:	ba 11 08 04 02       	mov    $0x2040811,%edx
		cache[i].used = FALSE;
	}
}

static struct SectorCache *
cache_fetch(uint_32 sector) {
c0102296:	57                   	push   %edi
c0102297:	89 c7                	mov    %eax,%edi
	struct SectorCache *ptr = &cache[sector % NR_SEC_CACHE];
c0102299:	f7 e2                	mul    %edx
c010229b:	89 f8                	mov    %edi,%eax
		cache[i].used = FALSE;
	}
}

static struct SectorCache *
cache_fetch(uint_32 sector) {
c010229d:	56                   	push   %esi
c010229e:	53                   	push   %ebx
c010229f:	83 ec 2c             	sub    $0x2c,%esp
	struct SectorCache *ptr = &cache[sector % NR_SEC_CACHE];
c01022a2:	29 d0                	sub    %edx,%eax
c01022a4:	d1 e8                	shr    %eax
c01022a6:	01 c2                	add    %eax,%edx
c01022a8:	c1 ea 06             	shr    $0x6,%edx
c01022ab:	89 d0                	mov    %edx,%eax
c01022ad:	c1 e0 07             	shl    $0x7,%eax
c01022b0:	29 d0                	sub    %edx,%eax
c01022b2:	89 fa                	mov    %edi,%edx
c01022b4:	29 c2                	sub    %eax,%edx
c01022b6:	89 d0                	mov    %edx,%eax
c01022b8:	c1 e2 09             	shl    $0x9,%edx
c01022bb:	8d 14 c2             	lea    (%edx,%eax,8),%edx
c01022be:	89 d5                	mov    %edx,%ebp
c01022c0:	81 c5 40 60 10 c0    	add    $0xc0106040,%ebp

	if (ptr->used == TRUE && ptr->sector == sector) {
c01022c6:	80 7d 04 01          	cmpb   $0x1,0x4(%ebp)
	}
}

static struct SectorCache *
cache_fetch(uint_32 sector) {
	struct SectorCache *ptr = &cache[sector % NR_SEC_CACHE];
c01022ca:	89 54 24 1c          	mov    %edx,0x1c(%esp)

	if (ptr->used == TRUE && ptr->sector == sector) {
c01022ce:	0f 84 c1 00 00 00    	je     c0102395 <cache_fetch+0x105>
		/* cache hit, do nothing */
	} else {
		if (ptr->used == TRUE && ptr->dirty == TRUE) {
c01022d4:	66 81 7d 04 01 01    	cmpw   $0x101,0x4(%ebp)
c01022da:	8d 75 06             	lea    0x6(%ebp),%esi
c01022dd:	0f 84 c9 00 00 00    	je     c01023ac <cache_fetch+0x11c>
//#include "kernel.h"

static inline uint_8
in_byte(uint_16 port) {
	uint_8 data;
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
c01022e3:	ba f7 01 00 00       	mov    $0x1f7,%edx
c01022e8:	ec                   	in     (%dx),%al

static inline void
ide_prepare(uint_32 sector) {
	int r;
	r = in_byte(IDE_PORT_BASE + 7);
	if ( (r & (0x80 | 0x40)) != 0x40)
c01022e9:	25 c0 00 00 00       	and    $0xc0,%eax
c01022ee:	83 f8 40             	cmp    $0x40,%eax
c01022f1:	74 0c                	je     c01022ff <cache_fetch+0x6f>
		panic("IDE NOT READY");
c01022f3:	c7 04 24 e0 3d 10 c0 	movl   $0xc0103de0,(%esp)
c01022fa:	e8 c1 e0 ff ff       	call   c01003c0 <panic>
	return data;
}

static inline void
out_byte(uint_16 port, uint_8 data) {
	asm volatile("out %%al, %%dx" : : "a"(data), "d"(port));
c01022ff:	ba f6 03 00 00       	mov    $0x3f6,%edx
c0102304:	31 c0                	xor    %eax,%eax
c0102306:	ee                   	out    %al,(%dx)
c0102307:	ba f2 01 00 00       	mov    $0x1f2,%edx
c010230c:	b8 01 00 00 00       	mov    $0x1,%eax
c0102311:	ee                   	out    %al,(%dx)
c0102312:	b2 f3                	mov    $0xf3,%dl
c0102314:	89 f8                	mov    %edi,%eax
c0102316:	ee                   	out    %al,(%dx)

	out_byte(IDE_PORT_CTRL, 0);
	out_byte(IDE_PORT_BASE + 2, 1);
	out_byte(IDE_PORT_BASE + 3, sector & 0xFF);
	out_byte(IDE_PORT_BASE + 4, (sector >> 8) & 0xFF);
c0102317:	89 f8                	mov    %edi,%eax
c0102319:	b2 f4                	mov    $0xf4,%dl
c010231b:	c1 e8 08             	shr    $0x8,%eax
c010231e:	ee                   	out    %al,(%dx)
	out_byte(IDE_PORT_BASE + 5, (sector >> 16) & 0xFF);
c010231f:	89 f8                	mov    %edi,%eax
c0102321:	b2 f5                	mov    $0xf5,%dl
c0102323:	c1 e8 10             	shr    $0x10,%eax
c0102326:	ee                   	out    %al,(%dx)
	out_byte(IDE_PORT_BASE + 6, 0xE0 | ((sector >> 24) & 0xFF));
c0102327:	89 f8                	mov    %edi,%eax
c0102329:	b2 f6                	mov    $0xf6,%dl
c010232b:	c1 e8 18             	shr    $0x18,%eax
c010232e:	83 c8 e0             	or     $0xffffffe0,%eax
c0102331:	ee                   	out    %al,(%dx)
c0102332:	b8 20 00 00 00       	mov    $0x20,%eax
c0102337:	b2 f7                	mov    $0xf7,%dl
c0102339:	ee                   	out    %al,(%dx)
c010233a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
static void
do_read(void *buf) {
	int i;
	static struct Message m;
	do {
		receive(MSG_HARD_INTR, &m);
c0102340:	c7 44 24 04 ac 62 11 	movl   $0xc01162ac,0x4(%esp)
c0102347:	c0 
c0102348:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c010234f:	e8 9c f4 ff ff       	call   c01017f0 <receive>
	} while (m.type != IDE_READY);
c0102354:	83 3d b4 62 11 c0 01 	cmpl   $0x1,0xc01162b4
c010235b:	75 e3                	jne    c0102340 <cache_fetch+0xb0>
c010235d:	31 db                	xor    %ebx,%ebx
c010235f:	31 c9                	xor    %ecx,%ecx
}

static inline uint_32
in_long(uint_16 port) {
	uint_32 data;
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
c0102361:	ba f0 01 00 00       	mov    $0x1f0,%edx
c0102366:	66 90                	xchg   %ax,%ax
c0102368:	ed                   	in     (%dx),%eax

	for (i = 0; i < 512 / sizeof(uint_32); i ++) {
c0102369:	83 c1 01             	add    $0x1,%ecx
c010236c:	81 f9 80 00 00 00    	cmp    $0x80,%ecx
		*(((uint_32*)buf) + i) = in_long(IDE_PORT_BASE);
c0102372:	89 04 9e             	mov    %eax,(%esi,%ebx,4)
	static struct Message m;
	do {
		receive(MSG_HARD_INTR, &m);
	} while (m.type != IDE_READY);

	for (i = 0; i < 512 / sizeof(uint_32); i ++) {
c0102375:	89 cb                	mov    %ecx,%ebx
c0102377:	75 ef                	jne    c0102368 <cache_fetch+0xd8>
		/* issue a read command */
		ide_prepare(sector);
		issue_read();
		do_read(&ptr->content);
		ptr->used = TRUE;
		ptr->sector = sector;
c0102379:	8b 54 24 1c          	mov    0x1c(%esp),%edx
		}
		/* issue a read command */
		ide_prepare(sector);
		issue_read();
		do_read(&ptr->content);
		ptr->used = TRUE;
c010237d:	c6 45 04 01          	movb   $0x1,0x4(%ebp)
		ptr->sector = sector;
c0102381:	89 ba 40 60 10 c0    	mov    %edi,-0x3fef9fc0(%edx)
		ptr->dirty = FALSE;
c0102387:	c6 45 05 00          	movb   $0x0,0x5(%ebp)
	}
	return ptr;
}
c010238b:	83 c4 2c             	add    $0x2c,%esp
c010238e:	89 e8                	mov    %ebp,%eax
c0102390:	5b                   	pop    %ebx
c0102391:	5e                   	pop    %esi
c0102392:	5f                   	pop    %edi
c0102393:	5d                   	pop    %ebp
c0102394:	c3                   	ret    

static struct SectorCache *
cache_fetch(uint_32 sector) {
	struct SectorCache *ptr = &cache[sector % NR_SEC_CACHE];

	if (ptr->used == TRUE && ptr->sector == sector) {
c0102395:	39 ba 40 60 10 c0    	cmp    %edi,-0x3fef9fc0(%edx)
c010239b:	74 ee                	je     c010238b <cache_fetch+0xfb>
		/* cache hit, do nothing */
	} else {
		if (ptr->used == TRUE && ptr->dirty == TRUE) {
c010239d:	66 81 7d 04 01 01    	cmpw   $0x101,0x4(%ebp)
c01023a3:	8d 75 06             	lea    0x6(%ebp),%esi
c01023a6:	0f 85 37 ff ff ff    	jne    c01022e3 <cache_fetch+0x53>
			/* write back */
			ide_prepare(ptr->sector);
c01023ac:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c01023b0:	8b 98 40 60 10 c0    	mov    -0x3fef9fc0(%eax),%ebx
//#include "kernel.h"

static inline uint_8
in_byte(uint_16 port) {
	uint_8 data;
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
c01023b6:	b8 f7 01 00 00       	mov    $0x1f7,%eax
c01023bb:	89 c2                	mov    %eax,%edx
c01023bd:	ec                   	in     (%dx),%al

static inline void
ide_prepare(uint_32 sector) {
	int r;
	r = in_byte(IDE_PORT_BASE + 7);
	if ( (r & (0x80 | 0x40)) != 0x40)
c01023be:	25 c0 00 00 00       	and    $0xc0,%eax
c01023c3:	83 f8 40             	cmp    $0x40,%eax
c01023c6:	74 0c                	je     c01023d4 <cache_fetch+0x144>
		panic("IDE NOT READY");
c01023c8:	c7 04 24 e0 3d 10 c0 	movl   $0xc0103de0,(%esp)
c01023cf:	e8 ec df ff ff       	call   c01003c0 <panic>
	return data;
}

static inline void
out_byte(uint_16 port, uint_8 data) {
	asm volatile("out %%al, %%dx" : : "a"(data), "d"(port));
c01023d4:	ba f6 03 00 00       	mov    $0x3f6,%edx
c01023d9:	31 c0                	xor    %eax,%eax
c01023db:	ee                   	out    %al,(%dx)
c01023dc:	ba f2 01 00 00       	mov    $0x1f2,%edx
c01023e1:	b8 01 00 00 00       	mov    $0x1,%eax
c01023e6:	ee                   	out    %al,(%dx)
c01023e7:	b2 f3                	mov    $0xf3,%dl
c01023e9:	89 d8                	mov    %ebx,%eax
c01023eb:	ee                   	out    %al,(%dx)

	out_byte(IDE_PORT_CTRL, 0);
	out_byte(IDE_PORT_BASE + 2, 1);
	out_byte(IDE_PORT_BASE + 3, sector & 0xFF);
	out_byte(IDE_PORT_BASE + 4, (sector >> 8) & 0xFF);
c01023ec:	89 d8                	mov    %ebx,%eax
c01023ee:	b2 f4                	mov    $0xf4,%dl
c01023f0:	c1 e8 08             	shr    $0x8,%eax
c01023f3:	ee                   	out    %al,(%dx)
	out_byte(IDE_PORT_BASE + 5, (sector >> 16) & 0xFF);
c01023f4:	89 d8                	mov    %ebx,%eax
c01023f6:	b2 f5                	mov    $0xf5,%dl
c01023f8:	c1 e8 10             	shr    $0x10,%eax
c01023fb:	ee                   	out    %al,(%dx)
	out_byte(IDE_PORT_BASE + 6, 0xE0 | ((sector >> 24) & 0xFF));
c01023fc:	89 d8                	mov    %ebx,%eax
c01023fe:	b2 f6                	mov    $0xf6,%dl
c0102400:	c1 e8 18             	shr    $0x18,%eax
c0102403:	83 c8 e0             	or     $0xffffffe0,%eax
c0102406:	ee                   	out    %al,(%dx)
		/* cache hit, do nothing */
	} else {
		if (ptr->used == TRUE && ptr->dirty == TRUE) {
			/* write back */
			ide_prepare(ptr->sector);
			do_write(&ptr->content);
c0102407:	8d 75 06             	lea    0x6(%ebp),%esi
c010240a:	89 f0                	mov    %esi,%eax
c010240c:	e8 9f fd ff ff       	call   c01021b0 <do_write>
c0102411:	e9 cd fe ff ff       	jmp    c01022e3 <cache_fetch+0x53>
c0102416:	8d 76 00             	lea    0x0(%esi),%esi
c0102419:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0102420 <ide_driver_initialize>:
};
static struct SectorCache cache[NR_SEC_CACHE];
static inline void cache_init(void);


void ide_driver_initialize(void) {
c0102420:	83 ec 1c             	sub    $0x1c,%esp
	
	add_irq_handle(14, ide_intr);
c0102423:	c7 44 24 04 10 22 10 	movl   $0xc0102210,0x4(%esp)
c010242a:	c0 
c010242b:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
c0102432:	e8 19 e8 ff ff       	call   c0100c50 <add_irq_handle>
	add_irq_handle(0 , time_intr);
c0102437:	c7 44 24 04 40 22 10 	movl   $0xc0102240,0x4(%esp)
c010243e:	c0 
c010243f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0102446:	e8 05 e8 ff ff       	call   c0100c50 <add_irq_handle>
c010244b:	b8 44 60 10 c0       	mov    $0xc0106044,%eax

static inline void
cache_init(void) {
	int i;
	for (i = 0; i < NR_SEC_CACHE; i ++) {
		cache[i].used = FALSE;
c0102450:	c6 00 00             	movb   $0x0,(%eax)
c0102453:	05 08 02 00 00       	add    $0x208,%eax
}

static inline void
cache_init(void) {
	int i;
	for (i = 0; i < NR_SEC_CACHE; i ++) {
c0102458:	3d 3c 62 11 c0       	cmp    $0xc011623c,%eax
c010245d:	75 f1                	jne    c0102450 <ide_driver_initialize+0x30>
void ide_driver_initialize(void) {
	
	add_irq_handle(14, ide_intr);
	add_irq_handle(0 , time_intr);
	cache_init();
}
c010245f:	83 c4 1c             	add    $0x1c,%esp
c0102462:	c3                   	ret    
c0102463:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
c0102469:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0102470 <ide_driver_thread>:


void
ide_driver_thread(void) {
c0102470:	55                   	push   %ebp
c0102471:	57                   	push   %edi
c0102472:	56                   	push   %esi
c0102473:	53                   	push   %ebx
c0102474:	83 ec 3c             	sub    $0x3c,%esp
c0102477:	8d 6c 24 2c          	lea    0x2c(%esp),%ebp
c010247b:	90                   	nop
c010247c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	static struct Message m;

	while (TRUE) {
		receive(ANY, &m);
c0102480:	c7 44 24 04 74 62 11 	movl   $0xc0116274,0x4(%esp)
c0102487:	c0 
c0102488:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c010248f:	e8 5c f3 ff ff       	call   c01017f0 <receive>
		if (m.src == MSG_HARD_INTR) {
c0102494:	a1 74 62 11 c0       	mov    0xc0116274,%eax
c0102499:	83 f8 80             	cmp    $0xffffff80,%eax
c010249c:	0f 84 ae 00 00 00    	je     c0102550 <ide_driver_thread+0xe0>
					}
				}
			} else {
				panic("IDE interrupt is leaking");
			}
		} else if (m.type == DEV_READ) {
c01024a2:	8b 15 7c 62 11 c0    	mov    0xc011627c,%edx
c01024a8:	83 fa 0c             	cmp    $0xc,%edx
c01024ab:	0f 84 48 01 00 00    	je     c01025f9 <ide_driver_thread+0x189>
			}
			m.type = -1;
			m.int_msg.p1 = i;
			send(m.src, &m);
			//printk("ss\n");
		} else if (m.type == DEV_WRITE) {
c01024b1:	83 fa 0d             	cmp    $0xd,%edx
c01024b4:	75 ca                	jne    c0102480 <ide_driver_thread+0x10>
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
c01024b6:	89 04 24             	mov    %eax,(%esp)
			for (i = 0; i < m.dev_io.length; i ++) {
c01024b9:	31 db                	xor    %ebx,%ebx
			m.int_msg.p1 = i;
			send(m.src, &m);
			//printk("ss\n");
		} else if (m.type == DEV_WRITE) {
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
c01024bb:	e8 00 ea ff ff       	call   c0100ec0 <fetch_pcb>
c01024c0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
			for (i = 0; i < m.dev_io.length; i ++) {
c01024c4:	a1 8c 62 11 c0       	mov    0xc011628c,%eax
c01024c9:	85 c0                	test   %eax,%eax
c01024cb:	74 57                	je     c0102524 <ide_driver_thread+0xb4>
c01024cd:	8d 76 00             	lea    0x0(%esi),%esi
				copy_to_kernel(pcb, &data, m.dev_io.buf + i, 1);
c01024d0:	a1 84 62 11 c0       	mov    0xc0116284,%eax
c01024d5:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
c01024dc:	00 
c01024dd:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c01024e1:	01 d8                	add    %ebx,%eax
c01024e3:	89 44 24 08          	mov    %eax,0x8(%esp)
c01024e7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c01024eb:	89 04 24             	mov    %eax,(%esp)
c01024ee:	e8 9d ea ff ff       	call   c0100f90 <copy_to_kernel>
				write_byte(m.dev_io.offset + i, data);
c01024f3:	8b 35 88 62 11 c0    	mov    0xc0116288,%esi
c01024f9:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c01024fd:	01 de                	add    %ebx,%esi
			send(m.src, &m);
			//printk("ss\n");
		} else if (m.type == DEV_WRITE) {
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
			for (i = 0; i < m.dev_io.length; i ++) {
c01024ff:	83 c3 01             	add    $0x1,%ebx
	struct SectorCache *ptr = cache_fetch(sector);
	return ptr->content[offset & 511];
}
static void
write_byte(uint_32 offset, uint_8 data) {
	uint_32 sector = offset >> 9;
c0102502:	89 f0                	mov    %esi,%eax
	struct SectorCache *ptr = cache_fetch(sector);
	ptr->content[offset & 511] = data;
c0102504:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
	struct SectorCache *ptr = cache_fetch(sector);
	return ptr->content[offset & 511];
}
static void
write_byte(uint_32 offset, uint_8 data) {
	uint_32 sector = offset >> 9;
c010250a:	c1 e8 09             	shr    $0x9,%eax
	struct SectorCache *ptr = cache_fetch(sector);
c010250d:	e8 7e fd ff ff       	call   c0102290 <cache_fetch>
	ptr->content[offset & 511] = data;
c0102512:	89 fa                	mov    %edi,%edx
c0102514:	88 54 30 06          	mov    %dl,0x6(%eax,%esi,1)
	ptr->dirty = TRUE;
c0102518:	c6 40 05 01          	movb   $0x1,0x5(%eax)
			send(m.src, &m);
			//printk("ss\n");
		} else if (m.type == DEV_WRITE) {
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
			for (i = 0; i < m.dev_io.length; i ++) {
c010251c:	39 1d 8c 62 11 c0    	cmp    %ebx,0xc011628c
c0102522:	77 ac                	ja     c01024d0 <ide_driver_thread+0x60>
				copy_to_kernel(pcb, &data, m.dev_io.buf + i, 1);
				write_byte(m.dev_io.offset + i, data);
			}
			m.type = -1;
			m.int_msg.p1 = i;
			send(m.src, &m);
c0102524:	a1 74 62 11 c0       	mov    0xc0116274,%eax
c0102529:	c7 44 24 04 74 62 11 	movl   $0xc0116274,0x4(%esp)
c0102530:	c0 
			for (i = 0; i < m.dev_io.length; i ++) {
				copy_to_kernel(pcb, &data, m.dev_io.buf + i, 1);
				write_byte(m.dev_io.offset + i, data);
			}
			m.type = -1;
			m.int_msg.p1 = i;
c0102531:	89 1d 80 62 11 c0    	mov    %ebx,0xc0116280
			struct PCB *pcb = fetch_pcb(m.src);
			for (i = 0; i < m.dev_io.length; i ++) {
				copy_to_kernel(pcb, &data, m.dev_io.buf + i, 1);
				write_byte(m.dev_io.offset + i, data);
			}
			m.type = -1;
c0102537:	c7 05 7c 62 11 c0 ff 	movl   $0xffffffff,0xc011627c
c010253e:	ff ff ff 
			m.int_msg.p1 = i;
			send(m.src, &m);
c0102541:	89 04 24             	mov    %eax,(%esp)
c0102544:	e8 a7 f1 ff ff       	call   c01016f0 <send>
c0102549:	e9 32 ff ff ff       	jmp    c0102480 <ide_driver_thread+0x10>
c010254e:	66 90                	xchg   %ax,%ax
	static struct Message m;

	while (TRUE) {
		receive(ANY, &m);
		if (m.src == MSG_HARD_INTR) {
			if (m.type == IDE_WRITEBACK) {
c0102550:	83 3d 7c 62 11 c0 02 	cmpl   $0x2,0xc011627c
c0102557:	0f 85 8b 00 00 00    	jne    c01025e8 <ide_driver_thread+0x178>
c010255d:	be 45 60 10 c0       	mov    $0xc0106045,%esi
c0102562:	31 db                	xor    %ebx,%ebx
c0102564:	eb 14                	jmp    c010257a <ide_driver_thread+0x10a>
c0102566:	66 90                	xchg   %ax,%ax
				int i;
				for (i = 0; i < NR_SEC_CACHE; i ++) {
c0102568:	83 c3 01             	add    $0x1,%ebx
c010256b:	81 c6 08 02 00 00    	add    $0x208,%esi
c0102571:	83 fb 7f             	cmp    $0x7f,%ebx
c0102574:	0f 84 06 ff ff ff    	je     c0102480 <ide_driver_thread+0x10>
					if (cache[i].dirty == TRUE) {
c010257a:	80 3e 01             	cmpb   $0x1,(%esi)
c010257d:	75 e9                	jne    c0102568 <ide_driver_thread+0xf8>
						ide_prepare(cache[i].sector);
c010257f:	8b 7e fb             	mov    -0x5(%esi),%edi
//#include "kernel.h"

static inline uint_8
in_byte(uint_16 port) {
	uint_8 data;
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
c0102582:	ba f7 01 00 00       	mov    $0x1f7,%edx
c0102587:	ec                   	in     (%dx),%al

static inline void
ide_prepare(uint_32 sector) {
	int r;
	r = in_byte(IDE_PORT_BASE + 7);
	if ( (r & (0x80 | 0x40)) != 0x40)
c0102588:	25 c0 00 00 00       	and    $0xc0,%eax
c010258d:	83 f8 40             	cmp    $0x40,%eax
c0102590:	74 0c                	je     c010259e <ide_driver_thread+0x12e>
		panic("IDE NOT READY");
c0102592:	c7 04 24 e0 3d 10 c0 	movl   $0xc0103de0,(%esp)
c0102599:	e8 22 de ff ff       	call   c01003c0 <panic>
	return data;
}

static inline void
out_byte(uint_16 port, uint_8 data) {
	asm volatile("out %%al, %%dx" : : "a"(data), "d"(port));
c010259e:	ba f6 03 00 00       	mov    $0x3f6,%edx
c01025a3:	31 c0                	xor    %eax,%eax
c01025a5:	ee                   	out    %al,(%dx)
c01025a6:	ba f2 01 00 00       	mov    $0x1f2,%edx
c01025ab:	b8 01 00 00 00       	mov    $0x1,%eax
c01025b0:	ee                   	out    %al,(%dx)
c01025b1:	b2 f3                	mov    $0xf3,%dl
c01025b3:	89 f8                	mov    %edi,%eax
c01025b5:	ee                   	out    %al,(%dx)

	out_byte(IDE_PORT_CTRL, 0);
	out_byte(IDE_PORT_BASE + 2, 1);
	out_byte(IDE_PORT_BASE + 3, sector & 0xFF);
	out_byte(IDE_PORT_BASE + 4, (sector >> 8) & 0xFF);
c01025b6:	89 f8                	mov    %edi,%eax
c01025b8:	b2 f4                	mov    $0xf4,%dl
c01025ba:	c1 e8 08             	shr    $0x8,%eax
c01025bd:	ee                   	out    %al,(%dx)
	out_byte(IDE_PORT_BASE + 5, (sector >> 16) & 0xFF);
c01025be:	89 f8                	mov    %edi,%eax
c01025c0:	b2 f5                	mov    $0xf5,%dl
c01025c2:	c1 e8 10             	shr    $0x10,%eax
c01025c5:	ee                   	out    %al,(%dx)
	out_byte(IDE_PORT_BASE + 6, 0xE0 | ((sector >> 24) & 0xFF));
c01025c6:	c1 ef 18             	shr    $0x18,%edi
c01025c9:	b2 f6                	mov    $0xf6,%dl
c01025cb:	89 f8                	mov    %edi,%eax
c01025cd:	83 c8 e0             	or     $0xffffffe0,%eax
c01025d0:	ee                   	out    %al,(%dx)
			if (m.type == IDE_WRITEBACK) {
				int i;
				for (i = 0; i < NR_SEC_CACHE; i ++) {
					if (cache[i].dirty == TRUE) {
						ide_prepare(cache[i].sector);
						do_write(&cache[i].content);
c01025d1:	89 d8                	mov    %ebx,%eax
c01025d3:	c1 e0 09             	shl    $0x9,%eax
c01025d6:	8d 84 d8 46 60 10 c0 	lea    -0x3fef9fba(%eax,%ebx,8),%eax
c01025dd:	e8 ce fb ff ff       	call   c01021b0 <do_write>
						cache[i].dirty = FALSE;
c01025e2:	c6 06 00             	movb   $0x0,(%esi)
c01025e5:	eb 81                	jmp    c0102568 <ide_driver_thread+0xf8>
c01025e7:	90                   	nop
					}
				}
			} else {
				panic("IDE interrupt is leaking");
c01025e8:	c7 04 24 ee 3d 10 c0 	movl   $0xc0103dee,(%esp)
c01025ef:	e8 cc dd ff ff       	call   c01003c0 <panic>
c01025f4:	e9 87 fe ff ff       	jmp    c0102480 <ide_driver_thread+0x10>
			}
		} else if (m.type == DEV_READ) {
			//printk("IDE driver receive request!\n");
			//printk("rr\n");
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
c01025f9:	89 04 24             	mov    %eax,(%esp)
			for (i = 0; i < m.dev_io.length; i ++) {
c01025fc:	31 db                	xor    %ebx,%ebx
			}
		} else if (m.type == DEV_READ) {
			//printk("IDE driver receive request!\n");
			//printk("rr\n");
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
c01025fe:	e8 bd e8 ff ff       	call   c0100ec0 <fetch_pcb>
			for (i = 0; i < m.dev_io.length; i ++) {
c0102603:	8b 15 8c 62 11 c0    	mov    0xc011628c,%edx
c0102609:	85 d2                	test   %edx,%edx
			}
		} else if (m.type == DEV_READ) {
			//printk("IDE driver receive request!\n");
			//printk("rr\n");
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
c010260b:	89 c7                	mov    %eax,%edi
			for (i = 0; i < m.dev_io.length; i ++) {
c010260d:	0f 84 11 ff ff ff    	je     c0102524 <ide_driver_thread+0xb4>
c0102613:	90                   	nop
c0102614:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				data = read_byte(m.dev_io.offset + i);
c0102618:	8b 35 88 62 11 c0    	mov    0xc0116288,%esi
c010261e:	01 de                	add    %ebx,%esi
	return ptr;
}

static uint_8
read_byte(uint_32 offset) {
	uint_32 sector = offset >> 9;
c0102620:	89 f0                	mov    %esi,%eax
	struct SectorCache *ptr = cache_fetch(sector);
	return ptr->content[offset & 511];
c0102622:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
	return ptr;
}

static uint_8
read_byte(uint_32 offset) {
	uint_32 sector = offset >> 9;
c0102628:	c1 e8 09             	shr    $0x9,%eax
	struct SectorCache *ptr = cache_fetch(sector);
c010262b:	e8 60 fc ff ff       	call   c0102290 <cache_fetch>
			//printk("IDE driver receive request!\n");
			//printk("rr\n");
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
			for (i = 0; i < m.dev_io.length; i ++) {
				data = read_byte(m.dev_io.offset + i);
c0102630:	0f b6 44 30 06       	movzbl 0x6(%eax,%esi,1),%eax
				copy_from_kernel(pcb, m.dev_io.buf + i, &data, 1);
c0102635:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
c010263c:	00 
c010263d:	89 6c 24 08          	mov    %ebp,0x8(%esp)
c0102641:	89 3c 24             	mov    %edi,(%esp)
			//printk("IDE driver receive request!\n");
			//printk("rr\n");
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
			for (i = 0; i < m.dev_io.length; i ++) {
				data = read_byte(m.dev_io.offset + i);
c0102644:	89 44 24 2c          	mov    %eax,0x2c(%esp)
				copy_from_kernel(pcb, m.dev_io.buf + i, &data, 1);
c0102648:	a1 84 62 11 c0       	mov    0xc0116284,%eax
c010264d:	01 d8                	add    %ebx,%eax
		} else if (m.type == DEV_READ) {
			//printk("IDE driver receive request!\n");
			//printk("rr\n");
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
			for (i = 0; i < m.dev_io.length; i ++) {
c010264f:	83 c3 01             	add    $0x1,%ebx
				data = read_byte(m.dev_io.offset + i);
				copy_from_kernel(pcb, m.dev_io.buf + i, &data, 1);
c0102652:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102656:	e8 75 e8 ff ff       	call   c0100ed0 <copy_from_kernel>
		} else if (m.type == DEV_READ) {
			//printk("IDE driver receive request!\n");
			//printk("rr\n");
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
			for (i = 0; i < m.dev_io.length; i ++) {
c010265b:	39 1d 8c 62 11 c0    	cmp    %ebx,0xc011628c
c0102661:	77 b5                	ja     c0102618 <ide_driver_thread+0x1a8>
c0102663:	e9 bc fe ff ff       	jmp    c0102524 <ide_driver_thread+0xb4>
c0102668:	90                   	nop
c0102669:	90                   	nop
c010266a:	90                   	nop
c010266b:	90                   	nop
c010266c:	90                   	nop
c010266d:	90                   	nop
c010266e:	90                   	nop
c010266f:	90                   	nop

c0102670 <init_drivers>:
#include "kernel.h"

void init_drivers(void) {
c0102670:	83 ec 0c             	sub    $0xc,%esp

	timer_driver_initialize();
c0102673:	e8 a8 f3 ff ff       	call   c0101a20 <timer_driver_initialize>
	tty_driver_initialize();
c0102678:	e8 f3 f5 ff ff       	call   c0101c70 <tty_driver_initialize>
	ide_driver_initialize();
}
c010267d:	83 c4 0c             	add    $0xc,%esp

void init_drivers(void) {

	timer_driver_initialize();
	tty_driver_initialize();
	ide_driver_initialize();
c0102680:	e9 9b fd ff ff       	jmp    c0102420 <ide_driver_initialize>
c0102685:	90                   	nop
c0102686:	90                   	nop
c0102687:	90                   	nop
c0102688:	90                   	nop
c0102689:	90                   	nop
c010268a:	90                   	nop
c010268b:	90                   	nop
c010268c:	90                   	nop
c010268d:	90                   	nop
c010268e:	90                   	nop
c010268f:	90                   	nop

c0102690 <FileManagement>:

pid_t	FM;

static uint_32 do_read(uint_32 file_name, char *buffer, uint_32 offset, uint_32 length);

void FileManagement(void) {
c0102690:	83 ec 1c             	sub    $0x1c,%esp
c0102693:	90                   	nop
c0102694:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	static struct Message m;
	static uint_32 read_size;

	while (TRUE) {
		receive(ANY, &m);
c0102698:	c7 44 24 04 c8 62 11 	movl   $0xc01162c8,0x4(%esp)
c010269f:	c0 
c01026a0:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c01026a7:	e8 44 f1 ff ff       	call   c01017f0 <receive>
		if (m.type == FM_READ)
c01026ac:	83 3d d0 62 11 c0 0e 	cmpl   $0xe,0xc01162d0
c01026b3:	75 e3                	jne    c0102698 <FileManagement+0x8>
static uint_32 do_read(uint_32 file_name, char *buffer, uint_32 offset, uint_32 length) {

	static struct Message m;

	m.type = DEV_READ;
	m.dev_io.pid = current_pcb -> pid;
c01026b5:	8b 15 04 90 1d c0    	mov    0xc01d9004,%edx

	while (TRUE) {
		receive(ANY, &m);
		if (m.type == FM_READ)
		{
			read_size = do_read(m.fm_msg.file_name, m.fm_msg.buf, m.fm_msg.offset, m.fm_msg.length);
c01026bb:	a1 d4 62 11 c0       	mov    0xc01162d4,%eax

static uint_32 do_read(uint_32 file_name, char *buffer, uint_32 offset, uint_32 length) {

	static struct Message m;

	m.type = DEV_READ;
c01026c0:	c7 05 ec 62 11 c0 0c 	movl   $0xc,0xc01162ec
c01026c7:	00 00 00 
	m.dev_io.pid = current_pcb -> pid;
c01026ca:	8b 92 1c 20 00 00    	mov    0x201c(%edx),%edx
	m.dev_io.buf = buffer;
	m.dev_io.offset = offset + Kernel_Size + (file_name - 1) * File_Size;
c01026d0:	c1 e0 10             	shl    $0x10,%eax
	m.dev_io.length = length;

	send(IDE, &m);
c01026d3:	c7 44 24 04 e4 62 11 	movl   $0xc01162e4,0x4(%esp)
c01026da:	c0 
static uint_32 do_read(uint_32 file_name, char *buffer, uint_32 offset, uint_32 length) {

	static struct Message m;

	m.type = DEV_READ;
	m.dev_io.pid = current_pcb -> pid;
c01026db:	89 15 f0 62 11 c0    	mov    %edx,0xc01162f0
	m.dev_io.buf = buffer;
c01026e1:	8b 15 d8 62 11 c0    	mov    0xc01162d8,%edx
c01026e7:	89 15 f4 62 11 c0    	mov    %edx,0xc01162f4
	m.dev_io.offset = offset + Kernel_Size + (file_name - 1) * File_Size;
c01026ed:	8b 15 dc 62 11 c0    	mov    0xc01162dc,%edx
c01026f3:	8d 84 02 00 00 0f 00 	lea    0xf0000(%edx,%eax,1),%eax
c01026fa:	a3 f8 62 11 c0       	mov    %eax,0xc01162f8
	m.dev_io.length = length;
c01026ff:	a1 e0 62 11 c0       	mov    0xc01162e0,%eax
c0102704:	a3 fc 62 11 c0       	mov    %eax,0xc01162fc

	send(IDE, &m);
c0102709:	a1 c8 a6 1d c0       	mov    0xc01da6c8,%eax
c010270e:	89 04 24             	mov    %eax,(%esp)
c0102711:	e8 da ef ff ff       	call   c01016f0 <send>
	receive(IDE, &m);
c0102716:	a1 c8 a6 1d c0       	mov    0xc01da6c8,%eax
c010271b:	c7 44 24 04 e4 62 11 	movl   $0xc01162e4,0x4(%esp)
c0102722:	c0 
c0102723:	89 04 24             	mov    %eax,(%esp)
c0102726:	e8 c5 f0 ff ff       	call   c01017f0 <receive>

	return m.int_msg.p1;
c010272b:	a1 f0 62 11 c0       	mov    0xc01162f0,%eax
		{
			read_size = do_read(m.fm_msg.file_name, m.fm_msg.buf, m.fm_msg.offset, m.fm_msg.length);
	//	panic("notify!\n");
			m.type = -1;
			m.int_msg.p1 = read_size;
			send(m.src, &m);
c0102730:	c7 44 24 04 c8 62 11 	movl   $0xc01162c8,0x4(%esp)
c0102737:	c0 
		receive(ANY, &m);
		if (m.type == FM_READ)
		{
			read_size = do_read(m.fm_msg.file_name, m.fm_msg.buf, m.fm_msg.offset, m.fm_msg.length);
	//	panic("notify!\n");
			m.type = -1;
c0102738:	c7 05 d0 62 11 c0 ff 	movl   $0xffffffff,0xc01162d0
c010273f:	ff ff ff 

	while (TRUE) {
		receive(ANY, &m);
		if (m.type == FM_READ)
		{
			read_size = do_read(m.fm_msg.file_name, m.fm_msg.buf, m.fm_msg.offset, m.fm_msg.length);
c0102742:	a3 00 63 11 c0       	mov    %eax,0xc0116300
	//	panic("notify!\n");
			m.type = -1;
			m.int_msg.p1 = read_size;
c0102747:	a3 d4 62 11 c0       	mov    %eax,0xc01162d4
			send(m.src, &m);
c010274c:	a1 c8 62 11 c0       	mov    0xc01162c8,%eax
c0102751:	89 04 24             	mov    %eax,(%esp)
c0102754:	e8 97 ef ff ff       	call   c01016f0 <send>
			printk("send to %d\n", m.src);
c0102759:	a1 c8 62 11 c0       	mov    0xc01162c8,%eax
c010275e:	c7 04 24 07 3e 10 c0 	movl   $0xc0103e07,(%esp)
c0102765:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102769:	e8 22 dc ff ff       	call   c0100390 <printk>
c010276e:	e9 25 ff ff ff       	jmp    c0102698 <FileManagement+0x8>
c0102773:	90                   	nop
c0102774:	90                   	nop
c0102775:	90                   	nop
c0102776:	90                   	nop
c0102777:	90                   	nop
c0102778:	90                   	nop
c0102779:	90                   	nop
c010277a:	90                   	nop
c010277b:	90                   	nop
c010277c:	90                   	nop
c010277d:	90                   	nop
c010277e:	90                   	nop
c010277f:	90                   	nop

c0102780 <init_mm>:

}

void init_mm(void) {
	int i;
	for (i = 0; i < NR_PPAGE_ENTRY; ++ i)
c0102780:	31 c0                	xor    %eax,%eax
c0102782:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		Ppage_flag[i] = TRUE;
c0102788:	c6 80 00 a7 1d c0 01 	movb   $0x1,-0x3fe25900(%eax)

}

void init_mm(void) {
	int i;
	for (i = 0; i < NR_PPAGE_ENTRY; ++ i)
c010278f:	83 c0 01             	add    $0x1,%eax
c0102792:	3d 00 70 00 00       	cmp    $0x7000,%eax
c0102797:	75 ef                	jne    c0102788 <init_mm+0x8>
		Ppage_flag[i] = TRUE;

}
c0102799:	f3 c3                	repz ret 
c010279b:	90                   	nop
c010279c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c01027a0 <allocate_page>:
	return ((ptr -> present == 0) ? TRUE : FALSE);
}


//length:	unit = 4KB
void allocate_page(struct PCB *pcb, void *start, uint_32 length) {
c01027a0:	55                   	push   %ebp
c01027a1:	57                   	push   %edi
c01027a2:	56                   	push   %esi
c01027a3:	53                   	push   %ebx
c01027a4:	83 ec 2c             	sub    $0x2c,%esp
c01027a7:	8b 74 24 48          	mov    0x48(%esp),%esi
c01027ab:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c01027af:	8b 44 24 44          	mov    0x44(%esp),%eax

	void				*addr;

	int i;
	
	while (length != 0)
c01027b3:	85 f6                	test   %esi,%esi
c01027b5:	0f 84 50 01 00 00    	je     c010290b <allocate_page+0x16b>
	*/
	
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent, *init_ptr;

	uint_32 pde = ((uint_32)start) >> 22;
c01027bb:	89 c7                	mov    %eax,%edi
c01027bd:	c1 ef 16             	shr    $0x16,%edi
	uint_32 pte = (((uint_32)start) >> 12) & 0x3FF;
c01027c0:	c1 e8 0c             	shr    $0xc,%eax
c01027c3:	25 ff 03 00 00       	and    $0x3ff,%eax

	int i;
	
	while (length != 0)
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
c01027c8:	8d 9c bd 00 40 00 00 	lea    0x4000(%ebp,%edi,4),%ebx
	
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent, *init_ptr;

	uint_32 pde = ((uint_32)start) >> 22;
	uint_32 pte = (((uint_32)start) >> 12) & 0x3FF;
c01027cf:	89 44 24 14          	mov    %eax,0x14(%esp)

	int i;
	
	while (length != 0)
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
c01027d3:	f6 03 01             	testb  $0x1,(%ebx)
c01027d6:	0f 84 8c 00 00 00    	je     c0102868 <allocate_page+0xc8>
				make_invalid_pte(init_ptr);
				++ init_ptr;
			}
		}
		else
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c01027dc:	8b 03                	mov    (%ebx),%eax
c01027de:	25 00 f0 ff ff       	and    $0xfffff000,%eax
		
		pent = pent + pte;
c01027e3:	8b 54 24 14          	mov    0x14(%esp),%edx
c01027e7:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
c01027ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

		for (i = pte; i < NR_PTE_ENTRY; ++ i)
		{
			if (Page_Table_Fault(pent) == FALSE)
c01027f0:	f6 03 01             	testb  $0x1,(%ebx)
c01027f3:	0f 85 e7 00 00 00    	jne    c01028e0 <allocate_page+0x140>

//allocate physical memory, exclude kernel space, 16MB --> 128MB
//need better algorithm!
static inline void * allocate_memory(void) {
	int i;
	for (i = 0; i < NR_PPAGE_ENTRY; ++ i)
c01027f9:	31 c0                	xor    %eax,%eax
c01027fb:	eb 11                	jmp    c010280e <allocate_page+0x6e>
c01027fd:	8d 76 00             	lea    0x0(%esi),%esi
c0102800:	83 c0 01             	add    $0x1,%eax
c0102803:	3d 00 70 00 00       	cmp    $0x7000,%eax
c0102808:	0f 84 ea 00 00 00    	je     c01028f8 <allocate_page+0x158>
		if (Ppage_flag[i] == TRUE)
c010280e:	80 b8 00 a7 1d c0 01 	cmpb   $0x1,-0x3fe25900(%eax)
c0102815:	75 e9                	jne    c0102800 <allocate_page+0x60>
		{
			Ppage_flag[i] = FALSE;
c0102817:	c6 80 00 a7 1d c0 00 	movb   $0x0,-0x3fe25900(%eax)
}


//return Physical Address
static inline uint_32 id_to_pa(uint_32 id) {
	return (USER_MEM_LOW + id * PAGE_SIZE);
c010281e:	05 00 10 00 00       	add    $0x1000,%eax
c0102823:	c1 e0 0c             	shl    $0xc,%eax
		for (i = pte; i < NR_PTE_ENTRY; ++ i)
		{
			if (Page_Table_Fault(pent) == FALSE)
				panic("Virtual Page Overlap!\n");

			make_pte(pent, allocate_memory());
c0102826:	89 44 24 04          	mov    %eax,0x4(%esp)
c010282a:	89 1c 24             	mov    %ebx,(%esp)
c010282d:	e8 6e df ff ff       	call   c01007a0 <make_pte>
			-- length;
			if (length == 0) break;
c0102832:	83 ee 01             	sub    $0x1,%esi
c0102835:	0f 84 d0 00 00 00    	je     c010290b <allocate_page+0x16b>
		else
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
		
		pent = pent + pte;

		for (i = pte; i < NR_PTE_ENTRY; ++ i)
c010283b:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
				panic("Virtual Page Overlap!\n");

			make_pte(pent, allocate_memory());
			-- length;
			if (length == 0) break;
			++ pent;
c0102840:	83 c3 04             	add    $0x4,%ebx
		else
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
		
		pent = pent + pte;

		for (i = pte; i < NR_PTE_ENTRY; ++ i)
c0102843:	81 7c 24 14 00 04 00 	cmpl   $0x400,0x14(%esp)
c010284a:	00 
c010284b:	75 a3                	jne    c01027f0 <allocate_page+0x50>
			make_pte(pent, allocate_memory());
			-- length;
			if (length == 0) break;
			++ pent;
		}
		++ pde;
c010284d:	83 c7 01             	add    $0x1,%edi

	int i;
	
	while (length != 0)
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
c0102850:	8d 9c bd 00 40 00 00 	lea    0x4000(%ebp,%edi,4),%ebx
			-- length;
			if (length == 0) break;
			++ pent;
		}
		++ pde;
		pte = 0;
c0102857:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c010285e:	00 

	int i;
	
	while (length != 0)
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
c010285f:	f6 03 01             	testb  $0x1,(%ebx)
c0102862:	0f 85 74 ff ff ff    	jne    c01027dc <allocate_page+0x3c>
c0102868:	31 c0                	xor    %eax,%eax
c010286a:	eb 12                	jmp    c010287e <allocate_page+0xde>
c010286c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

//allocate physical memory, exclude kernel space, 16MB --> 128MB
//need better algorithm!
static inline void * allocate_memory(void) {
	int i;
	for (i = 0; i < NR_PPAGE_ENTRY; ++ i)
c0102870:	83 c0 01             	add    $0x1,%eax
c0102873:	3d 00 70 00 00       	cmp    $0x7000,%eax
c0102878:	0f 84 95 00 00 00    	je     c0102913 <allocate_page+0x173>
		if (Ppage_flag[i] == TRUE)
c010287e:	80 b8 00 a7 1d c0 01 	cmpb   $0x1,-0x3fe25900(%eax)
c0102885:	75 e9                	jne    c0102870 <allocate_page+0xd0>
		{
			Ppage_flag[i] = FALSE;
c0102887:	c6 80 00 a7 1d c0 00 	movb   $0x0,-0x3fe25900(%eax)
}


//return Physical Address
static inline uint_32 id_to_pa(uint_32 id) {
	return (USER_MEM_LOW + id * PAGE_SIZE);
c010288e:	05 00 10 00 00       	add    $0x1000,%eax
c0102893:	c1 e0 0c             	shl    $0xc,%eax
c0102896:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	while (length != 0)
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
		{
			addr = allocate_memory();
			make_pde(pdir + pde, addr);
c010289a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c010289e:	89 1c 24             	mov    %ebx,(%esp)
c01028a1:	89 44 24 04          	mov    %eax,0x4(%esp)
c01028a5:	e8 d6 de ff ff       	call   c0100780 <make_pde>
	return ((ptr -> present == 0) ? TRUE : FALSE);
}


//length:	unit = 4KB
void allocate_page(struct PCB *pcb, void *start, uint_32 length) {
c01028aa:	8b 54 24 1c          	mov    0x1c(%esp),%edx
		{
			addr = allocate_memory();
			make_pde(pdir + pde, addr);
			pent = (struct PageTableEntry *)addr;

			init_ptr = pent;
c01028ae:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
	return ((ptr -> present == 0) ? TRUE : FALSE);
}


//length:	unit = 4KB
void allocate_page(struct PCB *pcb, void *start, uint_32 length) {
c01028b2:	81 c2 00 10 00 00    	add    $0x1000,%edx
c01028b8:	89 54 24 18          	mov    %edx,0x18(%esp)
c01028bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			pent = (struct PageTableEntry *)addr;

			init_ptr = pent;
			for (i = 0; i < NR_PTE_ENTRY; ++ i)
			{
				make_invalid_pte(init_ptr);
c01028c0:	89 1c 24             	mov    %ebx,(%esp)
				++ init_ptr;
c01028c3:	83 c3 04             	add    $0x4,%ebx
			pent = (struct PageTableEntry *)addr;

			init_ptr = pent;
			for (i = 0; i < NR_PTE_ENTRY; ++ i)
			{
				make_invalid_pte(init_ptr);
c01028c6:	e8 a5 de ff ff       	call   c0100770 <make_invalid_pte>
			addr = allocate_memory();
			make_pde(pdir + pde, addr);
			pent = (struct PageTableEntry *)addr;

			init_ptr = pent;
			for (i = 0; i < NR_PTE_ENTRY; ++ i)
c01028cb:	3b 5c 24 18          	cmp    0x18(%esp),%ebx
c01028cf:	75 ef                	jne    c01028c0 <allocate_page+0x120>
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
		{
			addr = allocate_memory();
			make_pde(pdir + pde, addr);
			pent = (struct PageTableEntry *)addr;
c01028d1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c01028d5:	e9 09 ff ff ff       	jmp    c01027e3 <allocate_page+0x43>
c01028da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		pent = pent + pte;

		for (i = pte; i < NR_PTE_ENTRY; ++ i)
		{
			if (Page_Table_Fault(pent) == FALSE)
				panic("Virtual Page Overlap!\n");
c01028e0:	c7 04 24 2b 3e 10 c0 	movl   $0xc0103e2b,(%esp)
c01028e7:	e8 d4 da ff ff       	call   c01003c0 <panic>
c01028ec:	e9 08 ff ff ff       	jmp    c01027f9 <allocate_page+0x59>
c01028f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (Ppage_flag[i] == TRUE)
		{
			Ppage_flag[i] = FALSE;
			return (void *)id_to_pa(i);
		}
	panic("Physical Page is full!\n");
c01028f8:	c7 04 24 13 3e 10 c0 	movl   $0xc0103e13,(%esp)
c01028ff:	e8 bc da ff ff       	call   c01003c0 <panic>
	return (void *)0;	//just for compile
c0102904:	31 c0                	xor    %eax,%eax
c0102906:	e9 1b ff ff ff       	jmp    c0102826 <allocate_page+0x86>
		}
		++ pde;
		pte = 0;
	}
	
}
c010290b:	83 c4 2c             	add    $0x2c,%esp
c010290e:	5b                   	pop    %ebx
c010290f:	5e                   	pop    %esi
c0102910:	5f                   	pop    %edi
c0102911:	5d                   	pop    %ebp
c0102912:	c3                   	ret    
		if (Ppage_flag[i] == TRUE)
		{
			Ppage_flag[i] = FALSE;
			return (void *)id_to_pa(i);
		}
	panic("Physical Page is full!\n");
c0102913:	c7 04 24 13 3e 10 c0 	movl   $0xc0103e13,(%esp)
c010291a:	e8 a1 da ff ff       	call   c01003c0 <panic>
	return (void *)0;	//just for compile
c010291f:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c0102926:	00 
c0102927:	e9 6e ff ff ff       	jmp    c010289a <allocate_page+0xfa>
c010292c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c0102930 <free_page>:
	
}


//length:	unit = 4KB
void free_page(struct PCB *pcb, void *start, uint_32 length) {
c0102930:	55                   	push   %ebp
c0102931:	57                   	push   %edi
c0102932:	56                   	push   %esi
c0102933:	53                   	push   %ebx
c0102934:	83 ec 2c             	sub    $0x2c,%esp
c0102937:	8b 7c 24 48          	mov    0x48(%esp),%edi
c010293b:	8b 74 24 44          	mov    0x44(%esp),%esi
	pdir = (struct PageDirectoryEntry *)(pcb -> pagedir);

	boolean clean_pd;
	int i;
	
	while (length != 0)
c010293f:	85 ff                	test   %edi,%edi
c0102941:	0f 84 71 01 00 00    	je     c0102ab8 <free_page+0x188>
	*/
	
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent;

	uint_32 pde = ((uint_32)start) >> 22;
c0102947:	89 f0                	mov    %esi,%eax
c0102949:	c1 e8 16             	shr    $0x16,%eax
	uint_32 pte = (((uint_32)start) >> 12) & 0x3FF;
c010294c:	c1 ee 0c             	shr    $0xc,%esi
	*/
	
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent;

	uint_32 pde = ((uint_32)start) >> 22;
c010294f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	uint_32 pte = (((uint_32)start) >> 12) & 0x3FF;
c0102953:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
c0102959:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	boolean clean_pd;
	int i;
	
	while (length != 0)
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
c0102960:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0102964:	8b 44 24 40          	mov    0x40(%esp),%eax
c0102968:	8d 94 90 00 40 00 00 	lea    0x4000(%eax,%edx,4),%edx
c010296f:	89 54 24 18          	mov    %edx,0x18(%esp)
c0102973:	f6 02 01             	testb  $0x1,(%edx)
c0102976:	0f 84 fc 00 00 00    	je     c0102a78 <free_page+0x148>
			panic("Free Unused Page!\n");
		pent = (struct PageTableEntry *)((pdir + pde) -> page_frame << 12);
c010297c:	8b 44 24 18          	mov    0x18(%esp),%eax
c0102980:	8b 28                	mov    (%eax),%ebp

		clean_pd = TRUE;
c0102982:	c6 44 24 17 01       	movb   $0x1,0x17(%esp)
	
	while (length != 0)
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
			panic("Free Unused Page!\n");
		pent = (struct PageTableEntry *)((pdir + pde) -> page_frame << 12);
c0102987:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp

		clean_pd = TRUE;
		for (i = 0; i < pte; ++ i)
c010298d:	85 f6                	test   %esi,%esi
c010298f:	74 32                	je     c01029c3 <free_page+0x93>
			if (Page_Table_Fault(pent + i) == FALSE)
			{
				clean_pd = FALSE;
c0102991:	c6 44 24 17 00       	movb   $0x0,0x17(%esp)
		if (Page_Directory_Fault(pdir + pde) == TRUE)
			panic("Free Unused Page!\n");
		pent = (struct PageTableEntry *)((pdir + pde) -> page_frame << 12);

		clean_pd = TRUE;
		for (i = 0; i < pte; ++ i)
c0102996:	31 c0                	xor    %eax,%eax
			if (Page_Table_Fault(pent + i) == FALSE)
c0102998:	f6 45 00 01          	testb  $0x1,0x0(%ebp)
c010299c:	8d 55 04             	lea    0x4(%ebp),%edx
c010299f:	74 16                	je     c01029b7 <free_page+0x87>
c01029a1:	eb 20                	jmp    c01029c3 <free_page+0x93>
c01029a3:	90                   	nop
c01029a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return ((ptr -> present == 0) ? TRUE : FALSE);
}


static inline boolean Page_Table_Fault(struct PageTableEntry *ptr) {
	return ((ptr -> present == 0) ? TRUE : FALSE);
c01029a8:	0f b6 0a             	movzbl (%edx),%ecx
c01029ab:	83 c2 04             	add    $0x4,%edx
			panic("Free Unused Page!\n");
		pent = (struct PageTableEntry *)((pdir + pde) -> page_frame << 12);

		clean_pd = TRUE;
		for (i = 0; i < pte; ++ i)
			if (Page_Table_Fault(pent + i) == FALSE)
c01029ae:	83 e1 01             	and    $0x1,%ecx
c01029b1:	0f 85 b1 00 00 00    	jne    c0102a68 <free_page+0x138>
		if (Page_Directory_Fault(pdir + pde) == TRUE)
			panic("Free Unused Page!\n");
		pent = (struct PageTableEntry *)((pdir + pde) -> page_frame << 12);

		clean_pd = TRUE;
		for (i = 0; i < pte; ++ i)
c01029b7:	83 c0 01             	add    $0x1,%eax
c01029ba:	39 f0                	cmp    %esi,%eax
c01029bc:	75 ea                	jne    c01029a8 <free_page+0x78>
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
			panic("Free Unused Page!\n");
		pent = (struct PageTableEntry *)((pdir + pde) -> page_frame << 12);

		clean_pd = TRUE;
c01029be:	c6 44 24 17 01       	movb   $0x1,0x17(%esp)
	
}


//length:	unit = 4KB
void free_page(struct PCB *pcb, void *start, uint_32 length) {
c01029c3:	8d 5c b5 00          	lea    0x0(%ebp,%esi,4),%ebx
c01029c7:	eb 38                	jmp    c0102a01 <free_page+0xd1>
c01029c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

		for (i = pte; i < NR_PTE_ENTRY; ++ i)
		{
			if (Page_Table_Fault(pent + i) == TRUE)
				panic("Free Unused Page!\n");
			free_memory((void *)((pent + i) -> page_frame << 12));
c01029d0:	8b 03                	mov    (%ebx),%eax
			make_invalid_pte(pent + i);
c01029d2:	89 1c 24             	mov    %ebx,(%esp)

		for (i = pte; i < NR_PTE_ENTRY; ++ i)
		{
			if (Page_Table_Fault(pent + i) == TRUE)
				panic("Free Unused Page!\n");
			free_memory((void *)((pent + i) -> page_frame << 12));
c01029d5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}


//Physical Address to Physical Memory Flag ID
static inline uint_32 pa_to_id(uint_32 pa) {
	return ((pa - USER_MEM_LOW) / PAGE_SIZE);
c01029da:	2d 00 00 00 01       	sub    $0x1000000,%eax
c01029df:	c1 e8 0c             	shr    $0xc,%eax
}

//free physical memory
//need better algorithm!
static inline void free_memory(void *addr) {
	Ppage_flag[pa_to_id((uint_32)addr)] = TRUE;
c01029e2:	c6 80 00 a7 1d c0 01 	movb   $0x1,-0x3fe25900(%eax)
		for (i = pte; i < NR_PTE_ENTRY; ++ i)
		{
			if (Page_Table_Fault(pent + i) == TRUE)
				panic("Free Unused Page!\n");
			free_memory((void *)((pent + i) -> page_frame << 12));
			make_invalid_pte(pent + i);
c01029e9:	e8 82 dd ff ff       	call   c0100770 <make_invalid_pte>
			-- length;
			if (length == 0) break;
c01029ee:	83 ef 01             	sub    $0x1,%edi
c01029f1:	74 25                	je     c0102a18 <free_page+0xe8>
				clean_pd = FALSE;
				break;
			}


		for (i = pte; i < NR_PTE_ENTRY; ++ i)
c01029f3:	83 c6 01             	add    $0x1,%esi
c01029f6:	83 c3 04             	add    $0x4,%ebx
c01029f9:	81 fe 00 04 00 00    	cmp    $0x400,%esi
c01029ff:	74 4d                	je     c0102a4e <free_page+0x11e>
		{
			if (Page_Table_Fault(pent + i) == TRUE)
c0102a01:	f6 03 01             	testb  $0x1,(%ebx)
c0102a04:	75 ca                	jne    c01029d0 <free_page+0xa0>
				panic("Free Unused Page!\n");
c0102a06:	c7 04 24 42 3e 10 c0 	movl   $0xc0103e42,(%esp)
c0102a0d:	e8 ae d9 ff ff       	call   c01003c0 <panic>
c0102a12:	eb bc                	jmp    c01029d0 <free_page+0xa0>
c0102a14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			-- length;
			if (length == 0) break;
		}
		

		for ( ; i < NR_PTE_ENTRY; ++ i)
c0102a18:	81 fe 00 04 00 00    	cmp    $0x400,%esi
c0102a1e:	74 2e                	je     c0102a4e <free_page+0x11e>
			if (Page_Table_Fault(pent + i) == FALSE)
c0102a20:	f6 03 01             	testb  $0x1,(%ebx)
c0102a23:	0f 85 8f 00 00 00    	jne    c0102ab8 <free_page+0x188>
	
}


//length:	unit = 4KB
void free_page(struct PCB *pcb, void *start, uint_32 length) {
c0102a29:	83 c6 01             	add    $0x1,%esi
			if (length == 0) break;
		}
		

		for ( ; i < NR_PTE_ENTRY; ++ i)
			if (Page_Table_Fault(pent + i) == FALSE)
c0102a2c:	8d 44 b5 00          	lea    0x0(%ebp,%esi,4),%eax
c0102a30:	eb 14                	jmp    c0102a46 <free_page+0x116>
c0102a32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	return ((ptr -> present == 0) ? TRUE : FALSE);
}


static inline boolean Page_Table_Fault(struct PageTableEntry *ptr) {
	return ((ptr -> present == 0) ? TRUE : FALSE);
c0102a38:	0f b6 10             	movzbl (%eax),%edx
c0102a3b:	83 c0 04             	add    $0x4,%eax
			if (length == 0) break;
		}
		

		for ( ; i < NR_PTE_ENTRY; ++ i)
			if (Page_Table_Fault(pent + i) == FALSE)
c0102a3e:	83 e2 01             	and    $0x1,%edx
c0102a41:	75 75                	jne    c0102ab8 <free_page+0x188>
c0102a43:	83 c6 01             	add    $0x1,%esi
			-- length;
			if (length == 0) break;
		}
		

		for ( ; i < NR_PTE_ENTRY; ++ i)
c0102a46:	81 fe 00 04 00 00    	cmp    $0x400,%esi
c0102a4c:	75 ea                	jne    c0102a38 <free_page+0x108>
				clean_pd = FALSE;
				break;
			}


		if (clean_pd == TRUE)
c0102a4e:	80 7c 24 17 01       	cmpb   $0x1,0x17(%esp)
c0102a53:	74 3b                	je     c0102a90 <free_page+0x160>
		{
			free_memory((void *)((pdir + pde) -> page_frame << 12));
			make_invalid_pde(pdir + pde);
		}

		++ pde;
c0102a55:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
	pdir = (struct PageDirectoryEntry *)(pcb -> pagedir);

	boolean clean_pd;
	int i;
	
	while (length != 0)
c0102a5a:	85 ff                	test   %edi,%edi
c0102a5c:	74 5a                	je     c0102ab8 <free_page+0x188>
			free_memory((void *)((pdir + pde) -> page_frame << 12));
			make_invalid_pde(pdir + pde);
		}

		++ pde;
		pte = 0;
c0102a5e:	31 f6                	xor    %esi,%esi
c0102a60:	e9 fb fe ff ff       	jmp    c0102960 <free_page+0x30>
c0102a65:	8d 76 00             	lea    0x0(%esi),%esi

		clean_pd = TRUE;
		for (i = 0; i < pte; ++ i)
			if (Page_Table_Fault(pent + i) == FALSE)
			{
				clean_pd = FALSE;
c0102a68:	c6 44 24 17 00       	movb   $0x0,0x17(%esp)
c0102a6d:	e9 51 ff ff ff       	jmp    c01029c3 <free_page+0x93>
c0102a72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i;
	
	while (length != 0)
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
			panic("Free Unused Page!\n");
c0102a78:	c7 04 24 42 3e 10 c0 	movl   $0xc0103e42,(%esp)
c0102a7f:	e8 3c d9 ff ff       	call   c01003c0 <panic>
c0102a84:	e9 f3 fe ff ff       	jmp    c010297c <free_page+0x4c>
c0102a89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			}


		if (clean_pd == TRUE)
		{
			free_memory((void *)((pdir + pde) -> page_frame << 12));
c0102a90:	8b 54 24 18          	mov    0x18(%esp),%edx
c0102a94:	8b 02                	mov    (%edx),%eax
			make_invalid_pde(pdir + pde);
c0102a96:	89 14 24             	mov    %edx,(%esp)
			}


		if (clean_pd == TRUE)
		{
			free_memory((void *)((pdir + pde) -> page_frame << 12));
c0102a99:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}


//Physical Address to Physical Memory Flag ID
static inline uint_32 pa_to_id(uint_32 pa) {
	return ((pa - USER_MEM_LOW) / PAGE_SIZE);
c0102a9e:	2d 00 00 00 01       	sub    $0x1000000,%eax
c0102aa3:	c1 e8 0c             	shr    $0xc,%eax
}

//free physical memory
//need better algorithm!
static inline void free_memory(void *addr) {
	Ppage_flag[pa_to_id((uint_32)addr)] = TRUE;
c0102aa6:	c6 80 00 a7 1d c0 01 	movb   $0x1,-0x3fe25900(%eax)


		if (clean_pd == TRUE)
		{
			free_memory((void *)((pdir + pde) -> page_frame << 12));
			make_invalid_pde(pdir + pde);
c0102aad:	e8 ae dc ff ff       	call   c0100760 <make_invalid_pde>
c0102ab2:	eb a1                	jmp    c0102a55 <free_page+0x125>
c0102ab4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

		++ pde;
		pte = 0;
	}
	
}
c0102ab8:	83 c4 2c             	add    $0x2c,%esp
c0102abb:	5b                   	pop    %ebx
c0102abc:	5e                   	pop    %esi
c0102abd:	5f                   	pop    %edi
c0102abe:	5d                   	pop    %ebp
c0102abf:	c3                   	ret    

c0102ac0 <MemoryManagement>:

void allocate_page(struct PCB *pcb, void *start, uint_32 length);

void free_page(struct PCB *pcb, void *start, uint_32 length);

void MemoryManagement(void) {
c0102ac0:	83 ec 1c             	sub    $0x1c,%esp
c0102ac3:	90                   	nop
c0102ac4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	static struct Message m;

	while (TRUE) {
		receive(ANY, &m);
c0102ac8:	c7 44 24 04 04 63 11 	movl   $0xc0116304,0x4(%esp)
c0102acf:	c0 
c0102ad0:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0102ad7:	e8 14 ed ff ff       	call   c01017f0 <receive>
		if (m.type == MM_ALLOCATE)
c0102adc:	a1 0c 63 11 c0       	mov    0xc011630c,%eax
c0102ae1:	83 f8 0a             	cmp    $0xa,%eax
c0102ae4:	74 4a                	je     c0102b30 <MemoryManagement+0x70>
		{
			allocate_page(m.mm_msg.target_pcb, (void *)m.mm_msg.start, m.mm_msg.length);
			m.type = -1;
			send(m.src, &m);
		}
		else if (m.type == MM_FREE)
c0102ae6:	83 f8 0b             	cmp    $0xb,%eax
c0102ae9:	75 dd                	jne    c0102ac8 <MemoryManagement+0x8>
		{
			free_page(m.mm_msg.target_pcb, (void *)m.mm_msg.start, m.mm_msg.length);
c0102aeb:	a1 18 63 11 c0       	mov    0xc0116318,%eax
c0102af0:	89 44 24 08          	mov    %eax,0x8(%esp)
c0102af4:	a1 14 63 11 c0       	mov    0xc0116314,%eax
c0102af9:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102afd:	a1 10 63 11 c0       	mov    0xc0116310,%eax
c0102b02:	89 04 24             	mov    %eax,(%esp)
c0102b05:	e8 26 fe ff ff       	call   c0102930 <free_page>
			m.type = -1;
			send(m.src, &m);
c0102b0a:	a1 04 63 11 c0       	mov    0xc0116304,%eax
c0102b0f:	c7 44 24 04 04 63 11 	movl   $0xc0116304,0x4(%esp)
c0102b16:	c0 
			send(m.src, &m);
		}
		else if (m.type == MM_FREE)
		{
			free_page(m.mm_msg.target_pcb, (void *)m.mm_msg.start, m.mm_msg.length);
			m.type = -1;
c0102b17:	c7 05 0c 63 11 c0 ff 	movl   $0xffffffff,0xc011630c
c0102b1e:	ff ff ff 
			send(m.src, &m);
c0102b21:	89 04 24             	mov    %eax,(%esp)
c0102b24:	e8 c7 eb ff ff       	call   c01016f0 <send>
c0102b29:	eb 9d                	jmp    c0102ac8 <MemoryManagement+0x8>
c0102b2b:	90                   	nop
c0102b2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	while (TRUE) {
		receive(ANY, &m);
		if (m.type == MM_ALLOCATE)
		{
			allocate_page(m.mm_msg.target_pcb, (void *)m.mm_msg.start, m.mm_msg.length);
c0102b30:	a1 18 63 11 c0       	mov    0xc0116318,%eax
c0102b35:	89 44 24 08          	mov    %eax,0x8(%esp)
c0102b39:	a1 14 63 11 c0       	mov    0xc0116314,%eax
c0102b3e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102b42:	a1 10 63 11 c0       	mov    0xc0116310,%eax
c0102b47:	89 04 24             	mov    %eax,(%esp)
c0102b4a:	e8 51 fc ff ff       	call   c01027a0 <allocate_page>
c0102b4f:	eb b9                	jmp    c0102b0a <MemoryManagement+0x4a>
c0102b51:	eb 0d                	jmp    c0102b60 <init_user_page>
c0102b53:	90                   	nop
c0102b54:	90                   	nop
c0102b55:	90                   	nop
c0102b56:	90                   	nop
c0102b57:	90                   	nop
c0102b58:	90                   	nop
c0102b59:	90                   	nop
c0102b5a:	90                   	nop
c0102b5b:	90                   	nop
c0102b5c:	90                   	nop
c0102b5d:	90                   	nop
c0102b5e:	90                   	nop
c0102b5f:	90                   	nop

c0102b60 <init_user_page>:
	
}



void init_user_page(struct PCB *pcb) {
c0102b60:	55                   	push   %ebp
c0102b61:	57                   	push   %edi
c0102b62:	56                   	push   %esi
c0102b63:	53                   	push   %ebx
	//PT_offset = (uint_32)va_to_pa(pcb -> pagetable);

	int i, j;

	//initialize page table
	for (i = 0; i < NR_PDE_ENTRY; ++ i)
c0102b64:	31 db                	xor    %ebx,%ebx
	
}



void init_user_page(struct PCB *pcb) {
c0102b66:	83 ec 2c             	sub    $0x2c,%esp
c0102b69:	8b 6c 24 40          	mov    0x40(%esp),%ebp

	void				*addr;

//	uint_32				PT_offset;

	printk("enter init_user_page\n");
c0102b6d:	c7 04 24 55 3e 10 c0 	movl   $0xc0103e55,(%esp)
c0102b74:	e8 17 d8 ff ff       	call   c0100390 <printk>

	pdir = (struct PageDirectoryEntry *)(pcb -> pagedir);
c0102b79:	8d 85 00 40 00 00    	lea    0x4000(%ebp),%eax
c0102b7f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0102b83:	90                   	nop
c0102b84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	int i, j;

	//initialize page table
	for (i = 0; i < NR_PDE_ENTRY; ++ i)
		make_invalid_pde(pdir + i);
c0102b88:	8d 84 9d 00 40 00 00 	lea    0x4000(%ebp,%ebx,4),%eax
	//PT_offset = (uint_32)va_to_pa(pcb -> pagetable);

	int i, j;

	//initialize page table
	for (i = 0; i < NR_PDE_ENTRY; ++ i)
c0102b8f:	83 c3 01             	add    $0x1,%ebx
		make_invalid_pde(pdir + i);
c0102b92:	89 04 24             	mov    %eax,(%esp)
c0102b95:	e8 c6 db ff ff       	call   c0100760 <make_invalid_pde>
	//PT_offset = (uint_32)va_to_pa(pcb -> pagetable);

	int i, j;

	//initialize page table
	for (i = 0; i < NR_PDE_ENTRY; ++ i)
c0102b9a:	81 fb 00 04 00 00    	cmp    $0x400,%ebx
c0102ba0:	75 e6                	jne    c0102b88 <init_user_page+0x28>
		make_invalid_pde(pdir + i);

	printk("initialize page table.................Successful!\n");
c0102ba2:	c7 04 24 6c 3e 10 c0 	movl   $0xc0103e6c,(%esp)
c0102ba9:	e8 e2 d7 ff ff       	call   c0100390 <printk>
	//for kernel space
	for (i = 0; i < USER_MEM_LOW / PD_SIZE; ++ i)
c0102bae:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0102bb5:	00 
	//PT_offset = (uint_32)va_to_pa(pcb -> pagetable);

	int i, j;

	//initialize page table
	for (i = 0; i < NR_PDE_ENTRY; ++ i)
c0102bb6:	31 c0                	xor    %eax,%eax
c0102bb8:	eb 14                	jmp    c0102bce <init_user_page+0x6e>
c0102bba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

//allocate physical memory, exclude kernel space, 16MB --> 128MB
//need better algorithm!
static inline void * allocate_memory(void) {
	int i;
	for (i = 0; i < NR_PPAGE_ENTRY; ++ i)
c0102bc0:	83 c0 01             	add    $0x1,%eax
c0102bc3:	3d 00 70 00 00       	cmp    $0x7000,%eax
c0102bc8:	0f 84 d1 00 00 00    	je     c0102c9f <init_user_page+0x13f>
		if (Ppage_flag[i] == TRUE)
c0102bce:	80 b8 00 a7 1d c0 01 	cmpb   $0x1,-0x3fe25900(%eax)
c0102bd5:	75 e9                	jne    c0102bc0 <init_user_page+0x60>
}


//return Physical Address
static inline uint_32 id_to_pa(uint_32 id) {
	return (USER_MEM_LOW + id * PAGE_SIZE);
c0102bd7:	8d 98 00 10 00 00    	lea    0x1000(%eax),%ebx
static inline void * allocate_memory(void) {
	int i;
	for (i = 0; i < NR_PPAGE_ENTRY; ++ i)
		if (Ppage_flag[i] == TRUE)
		{
			Ppage_flag[i] = FALSE;
c0102bdd:	c6 80 00 a7 1d c0 00 	movb   $0x0,-0x3fe25900(%eax)
}


//return Physical Address
static inline uint_32 id_to_pa(uint_32 id) {
	return (USER_MEM_LOW + id * PAGE_SIZE);
c0102be4:	c1 e3 0c             	shl    $0xc,%ebx
	printk("initialize page table.................Successful!\n");
	//for kernel space
	for (i = 0; i < USER_MEM_LOW / PD_SIZE; ++ i)
	{
		addr = allocate_memory();
		make_pde(pdir + (i + KOFFSET / PD_SIZE), addr);
c0102be7:	8b 54 24 18          	mov    0x18(%esp),%edx
	
}



void init_user_page(struct PCB *pcb) {
c0102beb:	8d bb 00 10 00 00    	lea    0x1000(%ebx),%edi
	printk("initialize page table.................Successful!\n");
	//for kernel space
	for (i = 0; i < USER_MEM_LOW / PD_SIZE; ++ i)
	{
		addr = allocate_memory();
		make_pde(pdir + (i + KOFFSET / PD_SIZE), addr);
c0102bf1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0102bf5:	8d 84 95 00 4c 00 00 	lea    0x4c00(%ebp,%edx,4),%eax
c0102bfc:	89 04 24             	mov    %eax,(%esp)
c0102bff:	e8 7c db ff ff       	call   c0100780 <make_pde>
	
}



void init_user_page(struct PCB *pcb) {
c0102c04:	8b 74 24 18          	mov    0x18(%esp),%esi
c0102c08:	c1 e6 0a             	shl    $0xa,%esi
c0102c0b:	90                   	nop
c0102c0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		addr = allocate_memory();
		make_pde(pdir + (i + KOFFSET / PD_SIZE), addr);
		pent = (struct PageTableEntry *)addr;
		for (j = 0; j < NR_PTE_ENTRY; ++ j)
		{
			make_pte(pent, (void *)((i * NR_PTE_ENTRY + j) << 12));
c0102c10:	89 f0                	mov    %esi,%eax
			++ pent;
c0102c12:	83 c6 01             	add    $0x1,%esi
		addr = allocate_memory();
		make_pde(pdir + (i + KOFFSET / PD_SIZE), addr);
		pent = (struct PageTableEntry *)addr;
		for (j = 0; j < NR_PTE_ENTRY; ++ j)
		{
			make_pte(pent, (void *)((i * NR_PTE_ENTRY + j) << 12));
c0102c15:	c1 e0 0c             	shl    $0xc,%eax
c0102c18:	89 1c 24             	mov    %ebx,(%esp)
			++ pent;
c0102c1b:	83 c3 04             	add    $0x4,%ebx
		addr = allocate_memory();
		make_pde(pdir + (i + KOFFSET / PD_SIZE), addr);
		pent = (struct PageTableEntry *)addr;
		for (j = 0; j < NR_PTE_ENTRY; ++ j)
		{
			make_pte(pent, (void *)((i * NR_PTE_ENTRY + j) << 12));
c0102c1e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102c22:	e8 79 db ff ff       	call   c01007a0 <make_pte>
	for (i = 0; i < USER_MEM_LOW / PD_SIZE; ++ i)
	{
		addr = allocate_memory();
		make_pde(pdir + (i + KOFFSET / PD_SIZE), addr);
		pent = (struct PageTableEntry *)addr;
		for (j = 0; j < NR_PTE_ENTRY; ++ j)
c0102c27:	39 fb                	cmp    %edi,%ebx
c0102c29:	75 e5                	jne    c0102c10 <init_user_page+0xb0>
	for (i = 0; i < NR_PDE_ENTRY; ++ i)
		make_invalid_pde(pdir + i);

	printk("initialize page table.................Successful!\n");
	//for kernel space
	for (i = 0; i < USER_MEM_LOW / PD_SIZE; ++ i)
c0102c2b:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
c0102c30:	83 7c 24 18 04       	cmpl   $0x4,0x18(%esp)
c0102c35:	0f 85 7b ff ff ff    	jne    c0102bb6 <init_user_page+0x56>
			make_pte(pent, (void *)((i * NR_PTE_ENTRY + j) << 12));
			++ pent;
		}
	}

	printk("set kernel space page table...............Successful\n");
c0102c3b:	c7 04 24 a0 3e 10 c0 	movl   $0xc0103ea0,(%esp)
c0102c42:	e8 49 d7 ff ff       	call   c0100390 <printk>

	//for user space
	
	//allocate a user stack, below 0xC0000000, 4KB
	allocate_page(pcb, (void *)0xC0000000 - 1, 1);
c0102c47:	89 2c 24             	mov    %ebp,(%esp)
c0102c4a:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c0102c51:	00 
c0102c52:	c7 44 24 04 ff ff ff 	movl   $0xbfffffff,0x4(%esp)
c0102c59:	bf 
c0102c5a:	e8 41 fb ff ff       	call   c01027a0 <allocate_page>
	
	printk("set user stack page table...............Successful\n");
c0102c5f:	c7 04 24 d8 3e 10 c0 	movl   $0xc0103ed8,(%esp)
c0102c66:	e8 25 d7 ff ff       	call   c0100390 <printk>

	*(uint_32*)&(pcb -> cr3) = 0;
	(pcb -> cr3).page_directory_base = ((uint_32)va_to_pa(pdir)) >> 12;
c0102c6b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0102c6f:	05 00 00 00 40       	add    $0x40000000,%eax
c0102c74:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0102c79:	89 85 18 20 00 00    	mov    %eax,0x2018(%ebp)
	printk("set CR3 register...............Successful\n");
c0102c7f:	c7 04 24 0c 3f 10 c0 	movl   $0xc0103f0c,(%esp)
c0102c86:	e8 05 d7 ff ff       	call   c0100390 <printk>
	printk("exit init_user_page..............Successful\n");
c0102c8b:	c7 44 24 40 38 3f 10 	movl   $0xc0103f38,0x40(%esp)
c0102c92:	c0 
}
c0102c93:	83 c4 2c             	add    $0x2c,%esp
c0102c96:	5b                   	pop    %ebx
c0102c97:	5e                   	pop    %esi
c0102c98:	5f                   	pop    %edi
c0102c99:	5d                   	pop    %ebp
	printk("set user stack page table...............Successful\n");

	*(uint_32*)&(pcb -> cr3) = 0;
	(pcb -> cr3).page_directory_base = ((uint_32)va_to_pa(pdir)) >> 12;
	printk("set CR3 register...............Successful\n");
	printk("exit init_user_page..............Successful\n");
c0102c9a:	e9 f1 d6 ff ff       	jmp    c0100390 <printk>
		if (Ppage_flag[i] == TRUE)
		{
			Ppage_flag[i] = FALSE;
			return (void *)id_to_pa(i);
		}
	panic("Physical Page is full!\n");
c0102c9f:	c7 04 24 13 3e 10 c0 	movl   $0xc0103e13,(%esp)
	return (void *)0;	//just for compile
c0102ca6:	31 db                	xor    %ebx,%ebx
		if (Ppage_flag[i] == TRUE)
		{
			Ppage_flag[i] = FALSE;
			return (void *)id_to_pa(i);
		}
	panic("Physical Page is full!\n");
c0102ca8:	e8 13 d7 ff ff       	call   c01003c0 <panic>
c0102cad:	e9 35 ff ff ff       	jmp    c0102be7 <init_user_page+0x87>
c0102cb2:	90                   	nop
c0102cb3:	90                   	nop
c0102cb4:	90                   	nop
c0102cb5:	90                   	nop
c0102cb6:	90                   	nop
c0102cb7:	90                   	nop
c0102cb8:	90                   	nop
c0102cb9:	90                   	nop
c0102cba:	90                   	nop
c0102cbb:	90                   	nop
c0102cbc:	90                   	nop
c0102cbd:	90                   	nop
c0102cbe:	90                   	nop
c0102cbf:	90                   	nop

c0102cc0 <load_init_proc>:
#include "kernel.h"

pid_t	PM;

void load_init_proc(uint_32 file_name, struct PCB *pcb) {
c0102cc0:	55                   	push   %ebp
c0102cc1:	57                   	push   %edi
c0102cc2:	56                   	push   %esi
c0102cc3:	53                   	push   %ebx
c0102cc4:	81 ec 0c 21 00 00    	sub    $0x210c,%esp
	struct ELFHeader *elf;
	struct ProgramHeader *ph, *eph;

	uint_32	va;

	printk("enter load_init_proc ...........Successful\n");
c0102cca:	c7 04 24 68 3f 10 c0 	movl   $0xc0103f68,(%esp)
#include "kernel.h"

pid_t	PM;

void load_init_proc(uint_32 file_name, struct PCB *pcb) {
c0102cd1:	8b ac 24 20 21 00 00 	mov    0x2120(%esp),%ebp

	printk("enter load_init_proc ...........Successful\n");
	printk("send FM read request ...........Successful\n");
	m.type = FM_READ;
	m.fm_msg.file_name = file_name;
	m.fm_msg.buf = buf;
c0102cd8:	8d 5c 24 2c          	lea    0x2c(%esp),%ebx
#include "kernel.h"

pid_t	PM;

void load_init_proc(uint_32 file_name, struct PCB *pcb) {
c0102cdc:	8b bc 24 24 21 00 00 	mov    0x2124(%esp),%edi
	struct ELFHeader *elf;
	struct ProgramHeader *ph, *eph;

	uint_32	va;

	printk("enter load_init_proc ...........Successful\n");
c0102ce3:	e8 a8 d6 ff ff       	call   c0100390 <printk>
	printk("send FM read request ...........Successful\n");
c0102ce8:	c7 04 24 94 3f 10 c0 	movl   $0xc0103f94,(%esp)
c0102cef:	e8 9c d6 ff ff       	call   c0100390 <printk>
	m.fm_msg.file_name = file_name;
	m.fm_msg.buf = buf;
	m.fm_msg.offset = 0;
	m.fm_msg.length = 4096;

	send(FM, &m);
c0102cf4:	a1 cc a6 1d c0       	mov    0xc01da6cc,%eax
c0102cf9:	c7 44 24 04 20 63 11 	movl   $0xc0116320,0x4(%esp)
c0102d00:	c0 

	printk("enter load_init_proc ...........Successful\n");
	printk("send FM read request ...........Successful\n");
	m.type = FM_READ;
	m.fm_msg.file_name = file_name;
	m.fm_msg.buf = buf;
c0102d01:	89 1d 30 63 11 c0    	mov    %ebx,0xc0116330

	uint_32	va;

	printk("enter load_init_proc ...........Successful\n");
	printk("send FM read request ...........Successful\n");
	m.type = FM_READ;
c0102d07:	c7 05 28 63 11 c0 0e 	movl   $0xe,0xc0116328
c0102d0e:	00 00 00 
	m.fm_msg.file_name = file_name;
	m.fm_msg.buf = buf;
	m.fm_msg.offset = 0;
	m.fm_msg.length = 4096;

	send(FM, &m);
c0102d11:	89 04 24             	mov    %eax,(%esp)
	uint_32	va;

	printk("enter load_init_proc ...........Successful\n");
	printk("send FM read request ...........Successful\n");
	m.type = FM_READ;
	m.fm_msg.file_name = file_name;
c0102d14:	89 2d 2c 63 11 c0    	mov    %ebp,0xc011632c
	m.fm_msg.buf = buf;
	m.fm_msg.offset = 0;
c0102d1a:	c7 05 34 63 11 c0 00 	movl   $0x0,0xc0116334
c0102d21:	00 00 00 
	m.fm_msg.length = 4096;
c0102d24:	c7 05 38 63 11 c0 00 	movl   $0x1000,0xc0116338
c0102d2b:	10 00 00 

	send(FM, &m);
c0102d2e:	e8 bd e9 ff ff       	call   c01016f0 <send>
	receive(FM, &m);
c0102d33:	a1 cc a6 1d c0       	mov    0xc01da6cc,%eax
c0102d38:	c7 44 24 04 20 63 11 	movl   $0xc0116320,0x4(%esp)
c0102d3f:	c0 
c0102d40:	89 04 24             	mov    %eax,(%esp)
c0102d43:	e8 a8 ea ff ff       	call   c01017f0 <receive>
	printk("received ...........Successful\n");
c0102d48:	c7 04 24 c0 3f 10 c0 	movl   $0xc0103fc0,(%esp)
c0102d4f:	e8 3c d6 ff ff       	call   c0100390 <printk>
	//panic("sb\n");
 
	printk("Read ELF header\n"); 
c0102d54:	c7 04 24 f8 40 10 c0 	movl   $0xc01040f8,(%esp)
c0102d5b:	e8 30 d6 ff ff       	call   c0100390 <printk>
	elf = (struct ELFHeader *)buf;

	ph = (struct ProgramHeader *)((char *)elf + elf -> phoff);
	eph = ph + elf -> phnum;
c0102d60:	0f b7 44 24 58       	movzwl 0x58(%esp),%eax
	//panic("sb\n");
 
	printk("Read ELF header\n"); 
	elf = (struct ELFHeader *)buf;

	ph = (struct ProgramHeader *)((char *)elf + elf -> phoff);
c0102d65:	03 5c 24 48          	add    0x48(%esp),%ebx
	eph = ph + elf -> phnum;
	printk("begin %x, end %x\n", ph, eph);
c0102d69:	c7 04 24 09 41 10 c0 	movl   $0xc0104109,(%esp)
 
	printk("Read ELF header\n"); 
	elf = (struct ELFHeader *)buf;

	ph = (struct ProgramHeader *)((char *)elf + elf -> phoff);
	eph = ph + elf -> phnum;
c0102d70:	c1 e0 05             	shl    $0x5,%eax
c0102d73:	01 d8                	add    %ebx,%eax
	printk("begin %x, end %x\n", ph, eph);
c0102d75:	89 44 24 08          	mov    %eax,0x8(%esp)
c0102d79:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 
	printk("Read ELF header\n"); 
	elf = (struct ELFHeader *)buf;

	ph = (struct ProgramHeader *)((char *)elf + elf -> phoff);
	eph = ph + elf -> phnum;
c0102d7d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	printk("begin %x, end %x\n", ph, eph);
c0102d81:	e8 0a d6 ff ff       	call   c0100390 <printk>
	for (; ph < eph; ++ ph) {
c0102d86:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
c0102d8a:	0f 83 53 01 00 00    	jae    c0102ee3 <load_init_proc+0x223>
		printk("****************************\n");
c0102d90:	c7 04 24 1b 41 10 c0 	movl   $0xc010411b,(%esp)
c0102d97:	e8 f4 d5 ff ff       	call   c0100390 <printk>
		printk("current: %x\n", ph);
c0102d9c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0102da0:	c7 04 24 39 41 10 c0 	movl   $0xc0104139,(%esp)
c0102da7:	e8 e4 d5 ff ff       	call   c0100390 <printk>
		va = (uint_32)ph -> vaddr;
c0102dac:	8b 73 08             	mov    0x8(%ebx),%esi

		printk("virtual address: %x\n", va);
c0102daf:	c7 04 24 46 41 10 c0 	movl   $0xc0104146,(%esp)
c0102db6:	89 74 24 04          	mov    %esi,0x4(%esp)
c0102dba:	e8 d1 d5 ff ff       	call   c0100390 <printk>
		m.type = FM_READ;
		m.fm_msg.file_name = file_name;
		m.fm_msg.buf = segment_buf;
c0102dbf:	8d 84 24 94 10 00 00 	lea    0x1094(%esp),%eax
		m.fm_msg.offset = ph -> off;
		m.fm_msg.length = ph -> filesz;
c0102dc6:	8b 53 10             	mov    0x10(%ebx),%edx
		va = (uint_32)ph -> vaddr;

		printk("virtual address: %x\n", va);
		m.type = FM_READ;
		m.fm_msg.file_name = file_name;
		m.fm_msg.buf = segment_buf;
c0102dc9:	a3 30 63 11 c0       	mov    %eax,0xc0116330
		m.fm_msg.offset = ph -> off;
c0102dce:	8b 43 04             	mov    0x4(%ebx),%eax
		m.fm_msg.length = ph -> filesz;

		printk("send FM read request, file name = %d, offset = %d, length = %d\n", file_name, ph -> off, ph -> filesz);
c0102dd1:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0102dd5:	c7 04 24 e0 3f 10 c0 	movl   $0xc0103fe0,(%esp)
c0102ddc:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0102de0:	89 44 24 08          	mov    %eax,0x8(%esp)
		printk("virtual address: %x\n", va);
		m.type = FM_READ;
		m.fm_msg.file_name = file_name;
		m.fm_msg.buf = segment_buf;
		m.fm_msg.offset = ph -> off;
		m.fm_msg.length = ph -> filesz;
c0102de4:	89 15 38 63 11 c0    	mov    %edx,0xc0116338

		printk("virtual address: %x\n", va);
		m.type = FM_READ;
		m.fm_msg.file_name = file_name;
		m.fm_msg.buf = segment_buf;
		m.fm_msg.offset = ph -> off;
c0102dea:	a3 34 63 11 c0       	mov    %eax,0xc0116334
		printk("****************************\n");
		printk("current: %x\n", ph);
		va = (uint_32)ph -> vaddr;

		printk("virtual address: %x\n", va);
		m.type = FM_READ;
c0102def:	c7 05 28 63 11 c0 0e 	movl   $0xe,0xc0116328
c0102df6:	00 00 00 
		m.fm_msg.file_name = file_name;
c0102df9:	89 2d 2c 63 11 c0    	mov    %ebp,0xc011632c
		m.fm_msg.buf = segment_buf;
		m.fm_msg.offset = ph -> off;
		m.fm_msg.length = ph -> filesz;

		printk("send FM read request, file name = %d, offset = %d, length = %d\n", file_name, ph -> off, ph -> filesz);
c0102dff:	e8 8c d5 ff ff       	call   c0100390 <printk>
		send(FM, &m);
c0102e04:	a1 cc a6 1d c0       	mov    0xc01da6cc,%eax
c0102e09:	c7 44 24 04 20 63 11 	movl   $0xc0116320,0x4(%esp)
c0102e10:	c0 
c0102e11:	89 04 24             	mov    %eax,(%esp)
c0102e14:	e8 d7 e8 ff ff       	call   c01016f0 <send>
		receive(FM, &m);
c0102e19:	a1 cc a6 1d c0       	mov    0xc01da6cc,%eax
c0102e1e:	c7 44 24 04 20 63 11 	movl   $0xc0116320,0x4(%esp)
c0102e25:	c0 
c0102e26:	89 04 24             	mov    %eax,(%esp)
c0102e29:	e8 c2 e9 ff ff       	call   c01017f0 <receive>

		printk("received from FM ...........Successful\n");
c0102e2e:	c7 04 24 20 40 10 c0 	movl   $0xc0104020,(%esp)
c0102e35:	e8 56 d5 ff ff       	call   c0100390 <printk>

		m.type = MM_ALLOCATE;
		m.mm_msg.target_pcb = pcb;
		m.mm_msg.start = va;
		m.mm_msg.length = ph -> memsz;
c0102e3a:	8b 43 14             	mov    0x14(%ebx),%eax

		printk("send MM read request, target_pcb = %d, va = %d, length = %d\n", pcb -> pid, va,  ph -> memsz);
c0102e3d:	89 74 24 08          	mov    %esi,0x8(%esp)
		send(FM, &m);
		receive(FM, &m);

		printk("received from FM ...........Successful\n");

		m.type = MM_ALLOCATE;
c0102e41:	c7 05 28 63 11 c0 0a 	movl   $0xa,0xc0116328
c0102e48:	00 00 00 
		m.mm_msg.target_pcb = pcb;
c0102e4b:	89 3d 2c 63 11 c0    	mov    %edi,0xc011632c
		m.mm_msg.start = va;
		m.mm_msg.length = ph -> memsz;
c0102e51:	a3 34 63 11 c0       	mov    %eax,0xc0116334

		printk("send MM read request, target_pcb = %d, va = %d, length = %d\n", pcb -> pid, va,  ph -> memsz);
c0102e56:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0102e5a:	8b 87 1c 20 00 00    	mov    0x201c(%edi),%eax
c0102e60:	c7 04 24 48 40 10 c0 	movl   $0xc0104048,(%esp)

		printk("received from FM ...........Successful\n");

		m.type = MM_ALLOCATE;
		m.mm_msg.target_pcb = pcb;
		m.mm_msg.start = va;
c0102e67:	89 35 30 63 11 c0    	mov    %esi,0xc0116330
		m.mm_msg.length = ph -> memsz;

		printk("send MM read request, target_pcb = %d, va = %d, length = %d\n", pcb -> pid, va,  ph -> memsz);
c0102e6d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102e71:	e8 1a d5 ff ff       	call   c0100390 <printk>

		send(MM, &m);
c0102e76:	a1 e0 a6 1d c0       	mov    0xc01da6e0,%eax
c0102e7b:	c7 44 24 04 20 63 11 	movl   $0xc0116320,0x4(%esp)
c0102e82:	c0 
c0102e83:	89 04 24             	mov    %eax,(%esp)
c0102e86:	e8 65 e8 ff ff       	call   c01016f0 <send>
		receive(MM, &m);
c0102e8b:	a1 e0 a6 1d c0       	mov    0xc01da6e0,%eax
c0102e90:	c7 44 24 04 20 63 11 	movl   $0xc0116320,0x4(%esp)
c0102e97:	c0 
c0102e98:	89 04 24             	mov    %eax,(%esp)
c0102e9b:	e8 50 e9 ff ff       	call   c01017f0 <receive>

		printk("received from MM .........Successful\n");
c0102ea0:	c7 04 24 88 40 10 c0 	movl   $0xc0104088,(%esp)
c0102ea7:	e8 e4 d4 ff ff       	call   c0100390 <printk>
		copy_from_kernel(pcb, (void *)va, segment_buf, ph -> filesz);
c0102eac:	8b 43 10             	mov    0x10(%ebx),%eax
	elf = (struct ELFHeader *)buf;

	ph = (struct ProgramHeader *)((char *)elf + elf -> phoff);
	eph = ph + elf -> phnum;
	printk("begin %x, end %x\n", ph, eph);
	for (; ph < eph; ++ ph) {
c0102eaf:	83 c3 20             	add    $0x20,%ebx

		send(MM, &m);
		receive(MM, &m);

		printk("received from MM .........Successful\n");
		copy_from_kernel(pcb, (void *)va, segment_buf, ph -> filesz);
c0102eb2:	89 74 24 04          	mov    %esi,0x4(%esp)
c0102eb6:	89 3c 24             	mov    %edi,(%esp)
c0102eb9:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0102ebd:	8d 84 24 94 10 00 00 	lea    0x1094(%esp),%eax
c0102ec4:	89 44 24 08          	mov    %eax,0x8(%esp)
c0102ec8:	e8 03 e0 ff ff       	call   c0100ed0 <copy_from_kernel>
		printk("copy program segments from kernel to user space.............Successful\n");
c0102ecd:	c7 04 24 b0 40 10 c0 	movl   $0xc01040b0,(%esp)
c0102ed4:	e8 b7 d4 ff ff       	call   c0100390 <printk>
	elf = (struct ELFHeader *)buf;

	ph = (struct ProgramHeader *)((char *)elf + elf -> phoff);
	eph = ph + elf -> phnum;
	printk("begin %x, end %x\n", ph, eph);
	for (; ph < eph; ++ ph) {
c0102ed9:	39 5c 24 1c          	cmp    %ebx,0x1c(%esp)
c0102edd:	0f 87 ad fe ff ff    	ja     c0102d90 <load_init_proc+0xd0>
	uint_32	stack_ptr = 0xC0000000 - 4;
	uint_32 key;

	//eflags
	key = (1 << 9);
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0102ee3:	8d b4 24 fc 20 00 00 	lea    0x20fc(%esp),%esi
	stack_ptr -= 4;

	//%eip
	key = elf -> entry;
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
	stack_ptr -= 4;
c0102eea:	bb f0 ff ff bf       	mov    $0xbffffff0,%ebx
		printk("received from MM .........Successful\n");
		copy_from_kernel(pcb, (void *)va, segment_buf, ph -> filesz);
		printk("copy program segments from kernel to user space.............Successful\n");
	}

	printk("Finish analyse ELF header\n");
c0102eef:	c7 04 24 5b 41 10 c0 	movl   $0xc010415b,(%esp)
c0102ef6:	e8 95 d4 ff ff       	call   c0100390 <printk>
	uint_32	stack_ptr = 0xC0000000 - 4;
	uint_32 key;

	//eflags
	key = (1 << 9);
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0102efb:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c0102f02:	00 
c0102f03:	89 74 24 08          	mov    %esi,0x8(%esp)
c0102f07:	c7 44 24 04 fc ff ff 	movl   $0xbffffffc,0x4(%esp)
c0102f0e:	bf 
c0102f0f:	89 3c 24             	mov    %edi,(%esp)
	//initialize user stack
	uint_32	stack_ptr = 0xC0000000 - 4;
	uint_32 key;

	//eflags
	key = (1 << 9);
c0102f12:	c7 84 24 fc 20 00 00 	movl   $0x200,0x20fc(%esp)
c0102f19:	00 02 00 00 
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0102f1d:	e8 ae df ff ff       	call   c0100ed0 <copy_from_kernel>
	stack_ptr -= 4;

	//%cs	
	key = 8;
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0102f22:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c0102f29:	00 
c0102f2a:	89 74 24 08          	mov    %esi,0x8(%esp)
c0102f2e:	c7 44 24 04 f8 ff ff 	movl   $0xbffffff8,0x4(%esp)
c0102f35:	bf 
c0102f36:	89 3c 24             	mov    %edi,(%esp)
	key = (1 << 9);
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
	stack_ptr -= 4;

	//%cs	
	key = 8;
c0102f39:	c7 84 24 fc 20 00 00 	movl   $0x8,0x20fc(%esp)
c0102f40:	08 00 00 00 
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0102f44:	e8 87 df ff ff       	call   c0100ed0 <copy_from_kernel>
	stack_ptr -= 4;

	//%eip
	key = elf -> entry;
c0102f49:	8b 44 24 44          	mov    0x44(%esp),%eax
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0102f4d:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c0102f54:	00 
c0102f55:	89 74 24 08          	mov    %esi,0x8(%esp)
c0102f59:	c7 44 24 04 f4 ff ff 	movl   $0xbffffff4,0x4(%esp)
c0102f60:	bf 
c0102f61:	89 3c 24             	mov    %edi,(%esp)
	key = 8;
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
	stack_ptr -= 4;

	//%eip
	key = elf -> entry;
c0102f64:	89 84 24 fc 20 00 00 	mov    %eax,0x20fc(%esp)
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0102f6b:	e8 60 df ff ff       	call   c0100ed0 <copy_from_kernel>
	stack_ptr -= 4;

	//TrapFrame
	uint_32 i;
	key = 0;
c0102f70:	c7 84 24 fc 20 00 00 	movl   $0x0,0x20fc(%esp)
c0102f77:	00 00 00 00 
c0102f7b:	90                   	nop
c0102f7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	for (i = 0; i < 9; ++ i)
	{
		copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0102f80:	89 5c 24 04          	mov    %ebx,0x4(%esp)
		stack_ptr -= 4;
c0102f84:	83 eb 04             	sub    $0x4,%ebx
	//TrapFrame
	uint_32 i;
	key = 0;
	for (i = 0; i < 9; ++ i)
	{
		copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0102f87:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c0102f8e:	00 
c0102f8f:	89 74 24 08          	mov    %esi,0x8(%esp)
c0102f93:	89 3c 24             	mov    %edi,(%esp)
c0102f96:	e8 35 df ff ff       	call   c0100ed0 <copy_from_kernel>
	stack_ptr -= 4;

	//TrapFrame
	uint_32 i;
	key = 0;
	for (i = 0; i < 9; ++ i)
c0102f9b:	81 fb cc ff ff bf    	cmp    $0xbfffffcc,%ebx
c0102fa1:	75 dd                	jne    c0102f80 <load_init_proc+0x2c0>
		copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
		stack_ptr -= 4;
	}

	//Initialize current_pcb -> esp
	pcb -> esp = (void *)stack_ptr;
c0102fa3:	c7 07 cc ff ff bf    	movl   $0xbfffffcc,(%edi)

	key = stack_ptr + 4;
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0102fa9:	89 74 24 08          	mov    %esi,0x8(%esp)
c0102fad:	89 3c 24             	mov    %edi,(%esp)
c0102fb0:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c0102fb7:	00 
c0102fb8:	c7 44 24 04 cc ff ff 	movl   $0xbfffffcc,0x4(%esp)
c0102fbf:	bf 
	}

	//Initialize current_pcb -> esp
	pcb -> esp = (void *)stack_ptr;

	key = stack_ptr + 4;
c0102fc0:	c7 84 24 fc 20 00 00 	movl   $0xbfffffd0,0x20fc(%esp)
c0102fc7:	d0 ff ff bf 
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0102fcb:	e8 00 df ff ff       	call   c0100ed0 <copy_from_kernel>
	stack_ptr -= 4;
}
c0102fd0:	81 c4 0c 21 00 00    	add    $0x210c,%esp
c0102fd6:	5b                   	pop    %ebx
c0102fd7:	5e                   	pop    %esi
c0102fd8:	5f                   	pop    %edi
c0102fd9:	5d                   	pop    %ebp
c0102fda:	c3                   	ret    
c0102fdb:	90                   	nop
c0102fdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

c0102fe0 <Create_uthread>:

void Create_uthread(uint_32 file_name) {
c0102fe0:	56                   	push   %esi
c0102fe1:	53                   	push   %ebx
c0102fe2:	83 ec 24             	sub    $0x24,%esp
c0102fe5:	8b 5c 24 30          	mov    0x30(%esp),%ebx

	lock();
c0102fe9:	e8 c2 e5 ff ff       	call   c01015b0 <lock>
	int new = Find_Empty_PCB();
c0102fee:	e8 8d de ff ff       	call   c0100e80 <Find_Empty_PCB>
	if (new == PROC_FULL)
c0102ff3:	83 f8 ff             	cmp    $0xffffffff,%eax
c0102ff6:	0f 84 ac 00 00 00    	je     c01030a8 <Create_uthread+0xc8>
		panic("Process Table is Full!\n");

	struct PCB *new_pcb = Proc + new;
c0102ffc:	8d 34 80             	lea    (%eax,%eax,4),%esi
c0102fff:	c1 e6 0c             	shl    $0xc,%esi

	new_pcb -> pid = new;
c0103002:	89 86 1c b0 13 c0    	mov    %eax,-0x3fec4fe4(%esi)
	new_pcb -> flag = FALSE;
c0103008:	c6 86 10 b0 13 c0 00 	movb   $0x0,-0x3fec4ff0(%esi)

	new_pcb -> time_elapsed = 0;
c010300f:	c7 86 f8 c4 13 c0 00 	movl   $0x0,-0x3fec3b08(%esi)
c0103016:	00 00 00 
	lock();
	int new = Find_Empty_PCB();
	if (new == PROC_FULL)
		panic("Process Table is Full!\n");

	struct PCB *new_pcb = Proc + new;
c0103019:	81 c6 00 90 13 c0    	add    $0xc0139000,%esi
	new_pcb -> pid = new;
	new_pcb -> flag = FALSE;

	new_pcb -> time_elapsed = 0;

	init_message_pool(new_pcb);
c010301f:	89 34 24             	mov    %esi,(%esp)
c0103022:	e8 29 e0 ff ff       	call   c0101050 <init_message_pool>

	printk("New pid = %d\n", new_pcb -> pid);
c0103027:	8b 86 1c 20 00 00    	mov    0x201c(%esi),%eax
c010302d:	c7 04 24 76 41 10 c0 	movl   $0xc0104176,(%esp)
c0103034:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103038:	e8 53 d3 ff ff       	call   c0100390 <printk>


	init_user_page(new_pcb);
c010303d:	89 34 24             	mov    %esi,(%esp)
c0103040:	e8 1b fb ff ff       	call   c0102b60 <init_user_page>

	unlock();
c0103045:	e8 86 e5 ff ff       	call   c01015d0 <unlock>

	load_init_proc(file_name, new_pcb);
c010304a:	89 74 24 04          	mov    %esi,0x4(%esp)
c010304e:	89 1c 24             	mov    %ebx,(%esp)
c0103051:	e8 6a fc ff ff       	call   c0102cc0 <load_init_proc>

	//initialize kernel stack
	new_pcb -> kstack_top = (void *)((uint_32)(new_pcb -> kstack) + STACK_SIZE - 4);
c0103056:	8d 86 04 20 00 00    	lea    0x2004(%esi),%eax
c010305c:	89 46 04             	mov    %eax,0x4(%esi)
	
	//initialize user stack
	//	Completed in load_init_proc

	//Ready to Schedule
	lock();
c010305f:	e8 4c e5 ff ff       	call   c01015b0 <lock>

	new_pcb -> next = init;
c0103064:	a1 00 90 1d c0       	mov    0xc01d9000,%eax
c0103069:	89 86 08 20 00 00    	mov    %eax,0x2008(%esi)
	new_pcb -> prev = init -> prev;
c010306f:	8b 90 0c 20 00 00    	mov    0x200c(%eax),%edx
c0103075:	89 96 0c 20 00 00    	mov    %edx,0x200c(%esi)
	init -> prev -> next = new_pcb;
c010307b:	8b 90 0c 20 00 00    	mov    0x200c(%eax),%edx
c0103081:	89 b2 08 20 00 00    	mov    %esi,0x2008(%edx)
	init -> prev = new_pcb;
c0103087:	89 b0 0c 20 00 00    	mov    %esi,0x200c(%eax)
	new_pcb -> status = STATUS_WAITING;
c010308d:	c7 86 14 20 00 00 00 	movl   $0x0,0x2014(%esi)
c0103094:	00 00 00 

	unlock();
}
c0103097:	83 c4 24             	add    $0x24,%esp
c010309a:	5b                   	pop    %ebx
c010309b:	5e                   	pop    %esi
	new_pcb -> prev = init -> prev;
	init -> prev -> next = new_pcb;
	init -> prev = new_pcb;
	new_pcb -> status = STATUS_WAITING;

	unlock();
c010309c:	e9 2f e5 ff ff       	jmp    c01015d0 <unlock>
c01030a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
void Create_uthread(uint_32 file_name) {

	lock();
	int new = Find_Empty_PCB();
	if (new == PROC_FULL)
		panic("Process Table is Full!\n");
c01030a8:	c7 04 24 1d 35 10 c0 	movl   $0xc010351d,(%esp)
c01030af:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c01030b3:	e8 08 d3 ff ff       	call   c01003c0 <panic>
c01030b8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c01030bc:	e9 3b ff ff ff       	jmp    c0102ffc <Create_uthread+0x1c>
c01030c1:	eb 0d                	jmp    c01030d0 <ProcessManagement>
c01030c3:	90                   	nop
c01030c4:	90                   	nop
c01030c5:	90                   	nop
c01030c6:	90                   	nop
c01030c7:	90                   	nop
c01030c8:	90                   	nop
c01030c9:	90                   	nop
c01030ca:	90                   	nop
c01030cb:	90                   	nop
c01030cc:	90                   	nop
c01030cd:	90                   	nop
c01030ce:	90                   	nop
c01030cf:	90                   	nop

c01030d0 <ProcessManagement>:

	unlock();
}


void ProcessManagement(void) {
c01030d0:	83 ec 1c             	sub    $0x1c,%esp
c01030d3:	90                   	nop
c01030d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	static struct Message m;		

	while (TRUE) {
		receive(ANY, &m);
c01030d8:	c7 44 24 04 3c 63 11 	movl   $0xc011633c,0x4(%esp)
c01030df:	c0 
c01030e0:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c01030e7:	e8 04 e7 ff ff       	call   c01017f0 <receive>
		if (m.type == PM_LOAD_PROC)
c01030ec:	81 3d 44 63 11 c0 aa 	cmpl   $0xaa,0xc0116344
c01030f3:	00 00 00 
c01030f6:	75 e0                	jne    c01030d8 <ProcessManagement+0x8>
		{
			Create_uthread(m.pm_msg.file_name);			
c01030f8:	a1 48 63 11 c0       	mov    0xc0116348,%eax
c01030fd:	89 04 24             	mov    %eax,(%esp)
c0103100:	e8 db fe ff ff       	call   c0102fe0 <Create_uthread>
			m.type = -1;
			send(m.src, &m);
c0103105:	a1 3c 63 11 c0       	mov    0xc011633c,%eax
c010310a:	c7 44 24 04 3c 63 11 	movl   $0xc011633c,0x4(%esp)
c0103111:	c0 
	while (TRUE) {
		receive(ANY, &m);
		if (m.type == PM_LOAD_PROC)
		{
			Create_uthread(m.pm_msg.file_name);			
			m.type = -1;
c0103112:	c7 05 44 63 11 c0 ff 	movl   $0xffffffff,0xc0116344
c0103119:	ff ff ff 
			send(m.src, &m);
c010311c:	89 04 24             	mov    %eax,(%esp)
c010311f:	e8 cc e5 ff ff       	call   c01016f0 <send>
c0103124:	eb b2                	jmp    c01030d8 <ProcessManagement+0x8>
c0103126:	90                   	nop
c0103127:	90                   	nop
c0103128:	90                   	nop
c0103129:	90                   	nop
c010312a:	90                   	nop
c010312b:	90                   	nop
c010312c:	90                   	nop
c010312d:	90                   	nop
c010312e:	90                   	nop
c010312f:	90                   	nop

c0103130 <test_timer_f>:
#include "kernel.h"

void test_timer_f(void) {
c0103130:	53                   	push   %ebx
c0103131:	83 ec 38             	sub    $0x38,%esp
c0103134:	8d 5c 24 14          	lea    0x14(%esp),%ebx
c0103138:	eb 16                	jmp    c0103150 <test_timer_f+0x20>
c010313a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		receive(MSG_HARD_INTR, &m);

		if (m.type == TIMER_ALRM_FIRE)
			printk("F");

		send(4, &m);
c0103140:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0103144:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c010314b:	e8 a0 e5 ff ff       	call   c01016f0 <send>
	struct Message m;

	while (1)
	{
		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c0103150:	a1 04 90 1d c0       	mov    0xc01d9004,%eax

	struct Message m;

	while (1)
	{
		m.type = TIMER_SET_ALRM;
c0103155:	c7 44 24 1c 0a 00 00 	movl   $0xa,0x1c(%esp)
c010315c:	00 
		m.int_msg.p1 = current_pcb -> pid;
		m.int_msg.p2 = 4;
c010315d:	c7 44 24 24 04 00 00 	movl   $0x4,0x24(%esp)
c0103164:	00 
	struct Message m;

	while (1)
	{
		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c0103165:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
		m.int_msg.p2 = 4;

		send(TIMER, &m);
c010316b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
	struct Message m;

	while (1)
	{
		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c010316f:	89 44 24 20          	mov    %eax,0x20(%esp)
		m.int_msg.p2 = 4;

		send(TIMER, &m);
c0103173:	a1 c0 a6 1d c0       	mov    0xc01da6c0,%eax
c0103178:	89 04 24             	mov    %eax,(%esp)
c010317b:	e8 70 e5 ff ff       	call   c01016f0 <send>

		receive(MSG_HARD_INTR, &m);
c0103180:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0103184:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c010318b:	e8 60 e6 ff ff       	call   c01017f0 <receive>

		if (m.type == TIMER_ALRM_FIRE)
c0103190:	83 7c 24 1c 0b       	cmpl   $0xb,0x1c(%esp)
c0103195:	75 a9                	jne    c0103140 <test_timer_f+0x10>
			printk("F");
c0103197:	c7 04 24 84 41 10 c0 	movl   $0xc0104184,(%esp)
c010319e:	e8 ed d1 ff ff       	call   c0100390 <printk>
c01031a3:	eb 9b                	jmp    c0103140 <test_timer_f+0x10>
c01031a5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c01031a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c01031b0 <test_timer_u>:

	}
}


void test_timer_u(void) {
c01031b0:	53                   	push   %ebx
c01031b1:	83 ec 38             	sub    $0x38,%esp
c01031b4:	8d 5c 24 14          	lea    0x14(%esp),%ebx
c01031b8:	eb 16                	jmp    c01031d0 <test_timer_u+0x20>
c01031ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		receive(MSG_HARD_INTR, &m);

		if (m.type == TIMER_ALRM_FIRE)
			printk("U");

		send(5, &m);
c01031c0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c01031c4:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c01031cb:	e8 20 e5 ff ff       	call   c01016f0 <send>

	struct Message m;

	while (1)
	{
		receive(3, &m);
c01031d0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c01031d4:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c01031db:	e8 10 e6 ff ff       	call   c01017f0 <receive>

		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c01031e0:	a1 04 90 1d c0       	mov    0xc01d9004,%eax

	while (1)
	{
		receive(3, &m);

		m.type = TIMER_SET_ALRM;
c01031e5:	c7 44 24 1c 0a 00 00 	movl   $0xa,0x1c(%esp)
c01031ec:	00 
		m.int_msg.p1 = current_pcb -> pid;
		m.int_msg.p2 = 1;
c01031ed:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%esp)
c01031f4:	00 
	while (1)
	{
		receive(3, &m);

		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c01031f5:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
		m.int_msg.p2 = 1;

		send(TIMER, &m);
c01031fb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
	while (1)
	{
		receive(3, &m);

		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c01031ff:	89 44 24 20          	mov    %eax,0x20(%esp)
		m.int_msg.p2 = 1;

		send(TIMER, &m);
c0103203:	a1 c0 a6 1d c0       	mov    0xc01da6c0,%eax
c0103208:	89 04 24             	mov    %eax,(%esp)
c010320b:	e8 e0 e4 ff ff       	call   c01016f0 <send>

		receive(MSG_HARD_INTR, &m);
c0103210:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0103214:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c010321b:	e8 d0 e5 ff ff       	call   c01017f0 <receive>

		if (m.type == TIMER_ALRM_FIRE)
c0103220:	83 7c 24 1c 0b       	cmpl   $0xb,0x1c(%esp)
c0103225:	75 99                	jne    c01031c0 <test_timer_u+0x10>
			printk("U");
c0103227:	c7 04 24 86 41 10 c0 	movl   $0xc0104186,(%esp)
c010322e:	e8 5d d1 ff ff       	call   c0100390 <printk>
c0103233:	eb 8b                	jmp    c01031c0 <test_timer_u+0x10>
c0103235:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c0103239:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c0103240 <test_timer_c>:
	}
}



void test_timer_c(void) {
c0103240:	53                   	push   %ebx
c0103241:	83 ec 38             	sub    $0x38,%esp
c0103244:	8d 5c 24 14          	lea    0x14(%esp),%ebx
c0103248:	eb 16                	jmp    c0103260 <test_timer_c+0x20>
c010324a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		receive(MSG_HARD_INTR, &m);

		if (m.type == TIMER_ALRM_FIRE)
			printk("C");

		send(6, &m);
c0103250:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0103254:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
c010325b:	e8 90 e4 ff ff       	call   c01016f0 <send>

	struct Message m;

	while (1)
	{
		receive(4, &m);
c0103260:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c0103264:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c010326b:	e8 80 e5 ff ff       	call   c01017f0 <receive>

		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c0103270:	a1 04 90 1d c0       	mov    0xc01d9004,%eax

	while (1)
	{
		receive(4, &m);

		m.type = TIMER_SET_ALRM;
c0103275:	c7 44 24 1c 0a 00 00 	movl   $0xa,0x1c(%esp)
c010327c:	00 
		m.int_msg.p1 = current_pcb -> pid;
		m.int_msg.p2 = 1;
c010327d:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%esp)
c0103284:	00 
	while (1)
	{
		receive(4, &m);

		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c0103285:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
		m.int_msg.p2 = 1;

		send(TIMER, &m);
c010328b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
	while (1)
	{
		receive(4, &m);

		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c010328f:	89 44 24 20          	mov    %eax,0x20(%esp)
		m.int_msg.p2 = 1;

		send(TIMER, &m);
c0103293:	a1 c0 a6 1d c0       	mov    0xc01da6c0,%eax
c0103298:	89 04 24             	mov    %eax,(%esp)
c010329b:	e8 50 e4 ff ff       	call   c01016f0 <send>

		receive(MSG_HARD_INTR, &m);
c01032a0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c01032a4:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c01032ab:	e8 40 e5 ff ff       	call   c01017f0 <receive>

		if (m.type == TIMER_ALRM_FIRE)
c01032b0:	83 7c 24 1c 0b       	cmpl   $0xb,0x1c(%esp)
c01032b5:	75 99                	jne    c0103250 <test_timer_c+0x10>
			printk("C");
c01032b7:	c7 04 24 87 35 10 c0 	movl   $0xc0103587,(%esp)
c01032be:	e8 cd d0 ff ff       	call   c0100390 <printk>
c01032c3:	eb 8b                	jmp    c0103250 <test_timer_c+0x10>
c01032c5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
c01032c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

c01032d0 <test_timer_k>:

	}
}


void test_timer_k(void) {
c01032d0:	53                   	push   %ebx
c01032d1:	83 ec 38             	sub    $0x38,%esp
c01032d4:	8d 5c 24 14          	lea    0x14(%esp),%ebx

	struct Message m;

	while (1)
	{
		receive(5, &m);
c01032d8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c01032dc:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c01032e3:	e8 08 e5 ff ff       	call   c01017f0 <receive>

		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c01032e8:	a1 04 90 1d c0       	mov    0xc01d9004,%eax

	while (1)
	{
		receive(5, &m);

		m.type = TIMER_SET_ALRM;
c01032ed:	c7 44 24 1c 0a 00 00 	movl   $0xa,0x1c(%esp)
c01032f4:	00 
		m.int_msg.p1 = current_pcb -> pid;
		m.int_msg.p2 = 1;
c01032f5:	c7 44 24 24 01 00 00 	movl   $0x1,0x24(%esp)
c01032fc:	00 
	while (1)
	{
		receive(5, &m);

		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c01032fd:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
		m.int_msg.p2 = 1;

		send(TIMER, &m);
c0103303:	89 5c 24 04          	mov    %ebx,0x4(%esp)
	while (1)
	{
		receive(5, &m);

		m.type = TIMER_SET_ALRM;
		m.int_msg.p1 = current_pcb -> pid;
c0103307:	89 44 24 20          	mov    %eax,0x20(%esp)
		m.int_msg.p2 = 1;

		send(TIMER, &m);
c010330b:	a1 c0 a6 1d c0       	mov    0xc01da6c0,%eax
c0103310:	89 04 24             	mov    %eax,(%esp)
c0103313:	e8 d8 e3 ff ff       	call   c01016f0 <send>

		receive(MSG_HARD_INTR, &m);
c0103318:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c010331c:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c0103323:	e8 c8 e4 ff ff       	call   c01017f0 <receive>

		if (m.type == TIMER_ALRM_FIRE)
c0103328:	83 7c 24 1c 0b       	cmpl   $0xb,0x1c(%esp)
c010332d:	75 a9                	jne    c01032d8 <test_timer_k+0x8>
			printk("K");
c010332f:	c7 04 24 88 41 10 c0 	movl   $0xc0104188,(%esp)
c0103336:	e8 55 d0 ff ff       	call   c0100390 <printk>
c010333b:	eb 9b                	jmp    c01032d8 <test_timer_k+0x8>
c010333d:	90                   	nop
c010333e:	90                   	nop
c010333f:	90                   	nop

c0103340 <test_tty>:
#include "kernel.h"

#define Buffer_Size	128

void test_tty(void) {
c0103340:	55                   	push   %ebp
c0103341:	57                   	push   %edi
c0103342:	56                   	push   %esi
c0103343:	53                   	push   %ebx
c0103344:	81 ec bc 00 00 00    	sub    $0xbc,%esp
c010334a:	8d 7c 24 14          	lea    0x14(%esp),%edi
c010334e:	8d b4 24 94 00 00 00 	lea    0x94(%esp),%esi
c0103355:	8d 76 00             	lea    0x0(%esi),%esi
	int i;
	
	while (1) {

		m.type = DEV_READ;
		m.dev_io.pid = current_pcb -> pid;
c0103358:	a1 04 90 1d c0       	mov    0xc01d9004,%eax
	char buf[Buffer_Size];
	int i;
	
	while (1) {

		m.type = DEV_READ;
c010335d:	c7 84 24 9c 00 00 00 	movl   $0xc,0x9c(%esp)
c0103364:	0c 00 00 00 
		m.dev_io.pid = current_pcb -> pid;
		m.dev_io.length = Buffer_Size;// - 1;
c0103368:	c7 84 24 ac 00 00 00 	movl   $0x80,0xac(%esp)
c010336f:	80 00 00 00 
		m.dev_io.buf = buf;
c0103373:	89 bc 24 a4 00 00 00 	mov    %edi,0xa4(%esp)
	int i;
	
	while (1) {

		m.type = DEV_READ;
		m.dev_io.pid = current_pcb -> pid;
c010337a:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
		m.dev_io.length = Buffer_Size;// - 1;
		m.dev_io.buf = buf;
		

		send(TTY, &m);
c0103380:	89 74 24 04          	mov    %esi,0x4(%esp)
	int i;
	
	while (1) {

		m.type = DEV_READ;
		m.dev_io.pid = current_pcb -> pid;
c0103384:	89 84 24 a0 00 00 00 	mov    %eax,0xa0(%esp)
		m.dev_io.length = Buffer_Size;// - 1;
		m.dev_io.buf = buf;
		

		send(TTY, &m);
c010338b:	a1 c4 a6 1d c0       	mov    0xc01da6c4,%eax
c0103390:	89 04 24             	mov    %eax,(%esp)
c0103393:	e8 58 e3 ff ff       	call   c01016f0 <send>
		receive(TTY, &m);
c0103398:	a1 c4 a6 1d c0       	mov    0xc01da6c4,%eax
c010339d:	89 74 24 04          	mov    %esi,0x4(%esp)
c01033a1:	89 04 24             	mov    %eax,(%esp)
c01033a4:	e8 47 e4 ff ff       	call   c01017f0 <receive>

		for (i = 0; i < m.int_msg.p1; ++ i)
c01033a9:	8b ac 24 a0 00 00 00 	mov    0xa0(%esp),%ebp
c01033b0:	85 ed                	test   %ebp,%ebp
c01033b2:	7e 75                	jle    c0103429 <test_tty+0xe9>
c01033b4:	89 f8                	mov    %edi,%eax
#include "kernel.h"

#define Buffer_Size	128

void test_tty(void) {
c01033b6:	8d 1c 2f             	lea    (%edi,%ebp,1),%ebx
c01033b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

		send(TTY, &m);
		receive(TTY, &m);

		for (i = 0; i < m.int_msg.p1; ++ i)
			if ('a' <= buf[i] && buf[i] <= 'z')
c01033c0:	0f b6 10             	movzbl (%eax),%edx
c01033c3:	8d 4a 9f             	lea    -0x61(%edx),%ecx
c01033c6:	80 f9 19             	cmp    $0x19,%cl
c01033c9:	77 05                	ja     c01033d0 <test_tty+0x90>
				buf[i] = buf[i] - 'a' + 'A';
c01033cb:	83 ea 20             	sub    $0x20,%edx
c01033ce:	88 10                	mov    %dl,(%eax)
c01033d0:	83 c0 01             	add    $0x1,%eax
		

		send(TTY, &m);
		receive(TTY, &m);

		for (i = 0; i < m.int_msg.p1; ++ i)
c01033d3:	39 d8                	cmp    %ebx,%eax
c01033d5:	75 e9                	jne    c01033c0 <test_tty+0x80>
			if ('a' <= buf[i] && buf[i] <= 'z')
				buf[i] = buf[i] - 'a' + 'A';

		m.type = DEV_WRITE;
		m.dev_io.pid = current_pcb -> pid;
c01033d7:	a1 04 90 1d c0       	mov    0xc01d9004,%eax

		for (i = 0; i < m.int_msg.p1; ++ i)
			if ('a' <= buf[i] && buf[i] <= 'z')
				buf[i] = buf[i] - 'a' + 'A';

		m.type = DEV_WRITE;
c01033dc:	c7 84 24 9c 00 00 00 	movl   $0xd,0x9c(%esp)
c01033e3:	0d 00 00 00 
		m.dev_io.pid = current_pcb -> pid;
		m.dev_io.length = i;
c01033e7:	89 ac 24 ac 00 00 00 	mov    %ebp,0xac(%esp)
		m.dev_io.buf = buf;
c01033ee:	89 bc 24 a4 00 00 00 	mov    %edi,0xa4(%esp)
		for (i = 0; i < m.int_msg.p1; ++ i)
			if ('a' <= buf[i] && buf[i] <= 'z')
				buf[i] = buf[i] - 'a' + 'A';

		m.type = DEV_WRITE;
		m.dev_io.pid = current_pcb -> pid;
c01033f5:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
		m.dev_io.length = i;
		m.dev_io.buf = buf;

		send(TTY, &m);
c01033fb:	89 74 24 04          	mov    %esi,0x4(%esp)
		for (i = 0; i < m.int_msg.p1; ++ i)
			if ('a' <= buf[i] && buf[i] <= 'z')
				buf[i] = buf[i] - 'a' + 'A';

		m.type = DEV_WRITE;
		m.dev_io.pid = current_pcb -> pid;
c01033ff:	89 84 24 a0 00 00 00 	mov    %eax,0xa0(%esp)
		m.dev_io.length = i;
		m.dev_io.buf = buf;

		send(TTY, &m);
c0103406:	a1 c4 a6 1d c0       	mov    0xc01da6c4,%eax
c010340b:	89 04 24             	mov    %eax,(%esp)
c010340e:	e8 dd e2 ff ff       	call   c01016f0 <send>
		receive(TTY, &m);
c0103413:	a1 c4 a6 1d c0       	mov    0xc01da6c4,%eax
c0103418:	89 74 24 04          	mov    %esi,0x4(%esp)
c010341c:	89 04 24             	mov    %eax,(%esp)
c010341f:	e8 cc e3 ff ff       	call   c01017f0 <receive>
	}
c0103424:	e9 2f ff ff ff       	jmp    c0103358 <test_tty+0x18>
		

		send(TTY, &m);
		receive(TTY, &m);

		for (i = 0; i < m.int_msg.p1; ++ i)
c0103429:	31 ed                	xor    %ebp,%ebp
c010342b:	eb aa                	jmp    c01033d7 <test_tty+0x97>
c010342d:	90                   	nop
c010342e:	90                   	nop
c010342f:	90                   	nop

c0103430 <test_ide>:
#include "kernel.h"

uint_32 hack;

void test_ide(void) {
c0103430:	83 ec 1c             	sub    $0x1c,%esp
	static struct Message m;

	m.type = PM_LOAD_PROC;
	m.pm_msg.file_name = 1;

	send(PM, &m);
c0103433:	a1 00 17 1e c0       	mov    0xc01e1700,%eax
c0103438:	c7 44 24 04 58 63 11 	movl   $0xc0116358,0x4(%esp)
c010343f:	c0 

void test_ide(void) {

	static struct Message m;

	m.type = PM_LOAD_PROC;
c0103440:	c7 05 60 63 11 c0 aa 	movl   $0xaa,0xc0116360
c0103447:	00 00 00 
	m.pm_msg.file_name = 1;
c010344a:	c7 05 64 63 11 c0 01 	movl   $0x1,0xc0116364
c0103451:	00 00 00 

	send(PM, &m);
c0103454:	89 04 24             	mov    %eax,(%esp)
c0103457:	e8 94 e2 ff ff       	call   c01016f0 <send>
	receive(PM, &m);
c010345c:	a1 00 17 1e c0       	mov    0xc01e1700,%eax
c0103461:	c7 44 24 04 58 63 11 	movl   $0xc0116358,0x4(%esp)
c0103468:	c0 
c0103469:	89 04 24             	mov    %eax,(%esp)
c010346c:	e8 7f e3 ff ff       	call   c01017f0 <receive>
	
	hack = 0;
	printk("hack address = %x\n", &hack);
c0103471:	c7 44 24 04 04 17 1e 	movl   $0xc01e1704,0x4(%esp)
c0103478:	c0 
c0103479:	c7 04 24 8a 41 10 c0 	movl   $0xc010418a,(%esp)
	m.pm_msg.file_name = 1;

	send(PM, &m);
	receive(PM, &m);
	
	hack = 0;
c0103480:	c7 05 04 17 1e c0 00 	movl   $0x0,0xc01e1704
c0103487:	00 00 00 
	printk("hack address = %x\n", &hack);
c010348a:	e8 01 cf ff ff       	call   c0100390 <printk>
c010348f:	90                   	nop
	while (1)
	{
		printk("%d", hack);
c0103490:	a1 04 17 1e c0       	mov    0xc01e1704,%eax
c0103495:	c7 04 24 9d 41 10 c0 	movl   $0xc010419d,(%esp)
c010349c:	89 44 24 04          	mov    %eax,0x4(%esp)
c01034a0:	e8 eb ce ff ff       	call   c0100390 <printk>
};

/* put the CPU into idle, waiting for next interrupt */
static inline void
idle_cpu() {
	asm volatile("hlt");
c01034a5:	f4                   	hlt    
c01034a6:	eb e8                	jmp    c0103490 <test_ide+0x60>
