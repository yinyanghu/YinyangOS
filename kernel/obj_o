
kernel:     file format elf32-i386


Disassembly of section .text:

c0100000 <idle_cpu>:
	uint_32 page_directory_base : 20;
};

/* put the CPU into idle, waiting for next interrupt */
static inline void
idle_cpu() {
c0100000:	55                   	push   %ebp
c0100001:	89 e5                	mov    %esp,%ebp
	asm volatile("hlt");
c0100003:	f4                   	hlt    
}
c0100004:	5d                   	pop    %ebp
c0100005:	c3                   	ret    

c0100006 <enable_interrupt>:
	data[2] = ((uint_32)addr) >> 16;
	asm volatile("lidt (%0)" : : "r"(data));
}

static inline void
enable_interrupt(void) {
c0100006:	55                   	push   %ebp
c0100007:	89 e5                	mov    %esp,%ebp
	asm volatile("sti");
c0100009:	fb                   	sti    
}
c010000a:	5d                   	pop    %ebp
c010000b:	c3                   	ret    

c010000c <os_init>:

void welcome(void);
void init_service(void);

void
os_init(void) {
c010000c:	55                   	push   %ebp
c010000d:	89 e5                	mov    %esp,%ebp
c010000f:	83 ec 08             	sub    $0x8,%esp
	/* Notice that when we are here, IF is always 0 (see bootloader) */

	/* We must set up kernel virtual memory first because our kernel
	   thinks it is located in 0xC0000000.
	   Before setting up correct paging, no global variable can be used. */
	init_page();
c0100012:	e8 e6 06 00 00       	call   c01006fd <init_page>

	/* Reset the GDT. Although user processes in Nanos run in Ring 0,
	   they have their own virtual address space. Therefore, the
	   old GDT located in physical address 0x7C00 cannot be used again. */
	init_segment();
c0100017:	e8 a0 08 00 00       	call   c01008bc <init_segment>

	/* Flush the screen, move cursor to (0, 0). */
	init_screen();
c010001c:	e8 28 01 00 00       	call   c0100149 <init_screen>

	/* Initialize interrupt handlers */
	init_handle();
c0100021:	e8 32 10 00 00       	call   c0101058 <init_handle>

	/* Set up interrupt and exception handlers,
	   just as we did in the game. */
	init_idt();
c0100026:	e8 16 0c 00 00       	call   c0100c41 <init_idt>

	/* Initialize the intel 8259 PIC. */
	init_intr();
c010002b:	e8 ce 09 00 00       	call   c01009fe <init_intr>

	/* Initialize the drivers. */
	init_drivers();
c0100030:	e8 8b 2f 00 00       	call   c0102fc0 <init_drivers>
	
	/* Initialize the services. */
	init_service();
c0100035:	e8 1c 00 00 00       	call   c0100056 <init_service>

	/* Initialize process table. You should fill this. */
	init_proc();
c010003a:	e8 5a 15 00 00       	call   c0101599 <init_proc>

	welcome();
c010003f:	e8 1f 00 00 00       	call   c0100063 <welcome>
	//asm volatile("movl %%esp, %0" : "=r"(stack_ptr));
	//printk("%d\n", stack_ptr);
	//printk("%d\n", *(uint_32 *)(stack_ptr + 4));
	//panic("sss");
	//current_pcb -> esp = (void *)(stack_ptr + 4);
	asm volatile("addl $0xC0000000, %esp");
c0100044:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp

	enable_interrupt();
c010004a:	e8 b7 ff ff ff       	call   c0100006 <enable_interrupt>

	/* This context now becomes the idle proess. */
	while (1) {
		idle_cpu();
c010004f:	e8 ac ff ff ff       	call   c0100000 <idle_cpu>
	}
c0100054:	eb f9                	jmp    c010004f <os_init+0x43>

c0100056 <init_service>:
}

void init_service(void) {
c0100056:	55                   	push   %ebp
c0100057:	89 e5                	mov    %esp,%ebp
c0100059:	83 ec 08             	sub    $0x8,%esp
	init_mm();
c010005c:	e8 41 31 00 00       	call   c01031a2 <init_mm>
}
c0100061:	c9                   	leave  
c0100062:	c3                   	ret    

c0100063 <welcome>:

void
welcome(void) {
c0100063:	55                   	push   %ebp
c0100064:	89 e5                	mov    %esp,%ebp
c0100066:	83 ec 28             	sub    $0x28,%esp
	static char prompt[] = "Hello, OS World!\n";
	const char *str;
	for (str = prompt; *str; str ++)
c0100069:	c7 45 f4 c0 53 10 c0 	movl   $0xc01053c0,-0xc(%ebp)
c0100070:	eb 15                	jmp    c0100087 <welcome+0x24>
		console_printc(*str);
c0100072:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100075:	0f b6 00             	movzbl (%eax),%eax
c0100078:	0f be c0             	movsbl %al,%eax
c010007b:	89 04 24             	mov    %eax,(%esp)
c010007e:	e8 15 03 00 00       	call   c0100398 <console_printc>

void
welcome(void) {
	static char prompt[] = "Hello, OS World!\n";
	const char *str;
	for (str = prompt; *str; str ++)
c0100083:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0100087:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010008a:	0f b6 00             	movzbl (%eax),%eax
c010008d:	84 c0                	test   %al,%al
c010008f:	75 e1                	jne    c0100072 <welcome+0xf>
		console_printc(*str);
	printk("Hello Yinyanghu!\n");
c0100091:	c7 04 24 d0 3e 10 c0 	movl   $0xc0103ed0,(%esp)
c0100098:	e8 4f 03 00 00       	call   c01003ec <printk>
}
c010009d:	c9                   	leave  
c010009e:	c3                   	ret    
c010009f:	90                   	nop

c01000a0 <idle_cpu>:
	uint_32 page_directory_base : 20;
};

/* put the CPU into idle, waiting for next interrupt */
static inline void
idle_cpu() {
c01000a0:	55                   	push   %ebp
c01000a1:	89 e5                	mov    %esp,%ebp
	asm volatile("hlt");
c01000a3:	f4                   	hlt    
}
c01000a4:	5d                   	pop    %ebp
c01000a5:	c3                   	ret    

c01000a6 <disable_interrupt>:
enable_interrupt(void) {
	asm volatile("sti");
}

static inline void
disable_interrupt(void) {
c01000a6:	55                   	push   %ebp
c01000a7:	89 e5                	mov    %esp,%ebp
	asm volatile("cli");
c01000a9:	fa                   	cli    
}
c01000aa:	5d                   	pop    %ebp
c01000ab:	c3                   	ret    

c01000ac <out_byte>:
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
	return data;
}

static inline void
out_byte(uint_16 port, uint_8 data) {
c01000ac:	55                   	push   %ebp
c01000ad:	89 e5                	mov    %esp,%ebp
c01000af:	83 ec 08             	sub    $0x8,%esp
c01000b2:	8b 55 08             	mov    0x8(%ebp),%edx
c01000b5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01000b8:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c01000bc:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("out %%al, %%dx" : : "a"(data), "d"(port));
c01000bf:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c01000c3:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c01000c7:	ee                   	out    %al,(%dx)
}
c01000c8:	c9                   	leave  
c01000c9:	c3                   	ret    

c01000ca <move_cursor>:

/* Set the cursor position. The I/O registers are 8-bit,
   so the hardware separates the 16-bit cursor position
   into two registers. */
static void
move_cursor(int x, int y) {
c01000ca:	55                   	push   %ebp
c01000cb:	89 e5                	mov    %esp,%ebp
c01000cd:	83 ec 08             	sub    $0x8,%esp
	out_byte(CRT_PORT_SEL, 0x0E);
c01000d0:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
c01000d7:	00 
c01000d8:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
c01000df:	e8 c8 ff ff ff       	call   c01000ac <out_byte>
	out_byte(CRT_PORT_DAT, ((x * 80 + y) >> 8) & 0xFF );
c01000e4:	8b 55 08             	mov    0x8(%ebp),%edx
c01000e7:	89 d0                	mov    %edx,%eax
c01000e9:	c1 e0 02             	shl    $0x2,%eax
c01000ec:	01 d0                	add    %edx,%eax
c01000ee:	c1 e0 04             	shl    $0x4,%eax
c01000f1:	03 45 0c             	add    0xc(%ebp),%eax
c01000f4:	c1 f8 08             	sar    $0x8,%eax
c01000f7:	0f b6 c0             	movzbl %al,%eax
c01000fa:	89 44 24 04          	mov    %eax,0x4(%esp)
c01000fe:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
c0100105:	e8 a2 ff ff ff       	call   c01000ac <out_byte>
	out_byte(CRT_PORT_SEL, 0x0F);
c010010a:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
c0100111:	00 
c0100112:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
c0100119:	e8 8e ff ff ff       	call   c01000ac <out_byte>
	out_byte(CRT_PORT_DAT, ((x * 80 + y)     ) & 0xFF );
c010011e:	8b 45 08             	mov    0x8(%ebp),%eax
c0100121:	89 c2                	mov    %eax,%edx
c0100123:	89 d0                	mov    %edx,%eax
c0100125:	c1 e0 02             	shl    $0x2,%eax
c0100128:	01 d0                	add    %edx,%eax
c010012a:	c1 e0 04             	shl    $0x4,%eax
c010012d:	89 c2                	mov    %eax,%edx
c010012f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100132:	01 d0                	add    %edx,%eax
c0100134:	0f b6 c0             	movzbl %al,%eax
c0100137:	89 44 24 04          	mov    %eax,0x4(%esp)
c010013b:	c7 04 24 d5 03 00 00 	movl   $0x3d5,(%esp)
c0100142:	e8 65 ff ff ff       	call   c01000ac <out_byte>
}
c0100147:	c9                   	leave  
c0100148:	c3                   	ret    

c0100149 <init_screen>:

void
init_screen() {
c0100149:	55                   	push   %ebp
c010014a:	89 e5                	mov    %esp,%ebp
c010014c:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < CRT_COLUMN * CRT_ROW; i ++)
c010014f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0100156:	eb 15                	jmp    c010016d <init_screen+0x24>
		vmem[i] = (BLACK << 12) | (WHITE << 8) | ' ';
c0100158:	a1 d4 53 10 c0       	mov    0xc01053d4,%eax
c010015d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0100160:	01 d2                	add    %edx,%edx
c0100162:	01 d0                	add    %edx,%eax
c0100164:	66 c7 00 20 07       	movw   $0x720,(%eax)
}

void
init_screen() {
	int i;
	for (i = 0; i < CRT_COLUMN * CRT_ROW; i ++)
c0100169:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010016d:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
c0100174:	7e e2                	jle    c0100158 <init_screen+0xf>
		vmem[i] = (BLACK << 12) | (WHITE << 8) | ' ';
	x = 0; y = 0;
c0100176:	c7 05 00 60 10 c0 00 	movl   $0x0,0xc0106000
c010017d:	00 00 00 
c0100180:	c7 05 04 60 10 c0 00 	movl   $0x0,0xc0106004
c0100187:	00 00 00 
	move_cursor(0, 0);
c010018a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0100191:	00 
c0100192:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0100199:	e8 2c ff ff ff       	call   c01000ca <move_cursor>
}
c010019e:	c9                   	leave  
c010019f:	c3                   	ret    

c01001a0 <cursor_left>:

void
cursor_left(int count) {
c01001a0:	55                   	push   %ebp
c01001a1:	89 e5                	mov    %esp,%ebp
c01001a3:	83 ec 08             	sub    $0x8,%esp
	while (count --) {
c01001a6:	eb 44                	jmp    c01001ec <cursor_left+0x4c>
		y --;
c01001a8:	a1 04 60 10 c0       	mov    0xc0106004,%eax
c01001ad:	83 e8 01             	sub    $0x1,%eax
c01001b0:	a3 04 60 10 c0       	mov    %eax,0xc0106004
		if (y < 0) {
c01001b5:	a1 04 60 10 c0       	mov    0xc0106004,%eax
c01001ba:	85 c0                	test   %eax,%eax
c01001bc:	79 17                	jns    c01001d5 <cursor_left+0x35>
			y = CRT_COLUMN - 1;
c01001be:	c7 05 04 60 10 c0 4f 	movl   $0x4f,0xc0106004
c01001c5:	00 00 00 
			x --;
c01001c8:	a1 00 60 10 c0       	mov    0xc0106000,%eax
c01001cd:	83 e8 01             	sub    $0x1,%eax
c01001d0:	a3 00 60 10 c0       	mov    %eax,0xc0106000
		}
		move_cursor(x, y);
c01001d5:	8b 15 04 60 10 c0    	mov    0xc0106004,%edx
c01001db:	a1 00 60 10 c0       	mov    0xc0106000,%eax
c01001e0:	89 54 24 04          	mov    %edx,0x4(%esp)
c01001e4:	89 04 24             	mov    %eax,(%esp)
c01001e7:	e8 de fe ff ff       	call   c01000ca <move_cursor>
	move_cursor(0, 0);
}

void
cursor_left(int count) {
	while (count --) {
c01001ec:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c01001f0:	0f 95 c0             	setne  %al
c01001f3:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
c01001f7:	84 c0                	test   %al,%al
c01001f9:	75 ad                	jne    c01001a8 <cursor_left+0x8>
			y = CRT_COLUMN - 1;
			x --;
		}
		move_cursor(x, y);
	}
}
c01001fb:	c9                   	leave  
c01001fc:	c3                   	ret    

c01001fd <cursor_right>:

void
cursor_right(int count) {
c01001fd:	55                   	push   %ebp
c01001fe:	89 e5                	mov    %esp,%ebp
c0100200:	83 ec 08             	sub    $0x8,%esp
	while (count --) {
c0100203:	eb 2e                	jmp    c0100233 <cursor_right+0x36>
		y ++;
c0100205:	a1 04 60 10 c0       	mov    0xc0106004,%eax
c010020a:	83 c0 01             	add    $0x1,%eax
c010020d:	a3 04 60 10 c0       	mov    %eax,0xc0106004
		if (y >= CRT_COLUMN) {
c0100212:	a1 04 60 10 c0       	mov    0xc0106004,%eax
c0100217:	83 f8 4f             	cmp    $0x4f,%eax
c010021a:	7e 17                	jle    c0100233 <cursor_right+0x36>
			x ++;
c010021c:	a1 00 60 10 c0       	mov    0xc0106000,%eax
c0100221:	83 c0 01             	add    $0x1,%eax
c0100224:	a3 00 60 10 c0       	mov    %eax,0xc0106000
			y = 0;
c0100229:	c7 05 04 60 10 c0 00 	movl   $0x0,0xc0106004
c0100230:	00 00 00 
	}
}

void
cursor_right(int count) {
	while (count --) {
c0100233:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0100237:	0f 95 c0             	setne  %al
c010023a:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
c010023e:	84 c0                	test   %al,%al
c0100240:	75 c3                	jne    c0100205 <cursor_right+0x8>
		if (y >= CRT_COLUMN) {
			x ++;
			y = 0;
		}
	}
	move_cursor(x, y);
c0100242:	8b 15 04 60 10 c0    	mov    0xc0106004,%edx
c0100248:	a1 00 60 10 c0       	mov    0xc0106000,%eax
c010024d:	89 54 24 04          	mov    %edx,0x4(%esp)
c0100251:	89 04 24             	mov    %eax,(%esp)
c0100254:	e8 71 fe ff ff       	call   c01000ca <move_cursor>
}
c0100259:	c9                   	leave  
c010025a:	c3                   	ret    

c010025b <wrap_screen>:


static void
wrap_screen() {
c010025b:	55                   	push   %ebp
c010025c:	89 e5                	mov    %esp,%ebp
c010025e:	83 ec 10             	sub    $0x10,%esp
	int i;
	for (i = CRT_COLUMN; i < CRT_ROW * CRT_COLUMN; i ++)
c0100261:	c7 45 fc 50 00 00 00 	movl   $0x50,-0x4(%ebp)
c0100268:	eb 25                	jmp    c010028f <wrap_screen+0x34>
		vmem[i - CRT_COLUMN] = vmem[i];
c010026a:	a1 d4 53 10 c0       	mov    0xc01053d4,%eax
c010026f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0100272:	83 ea 50             	sub    $0x50,%edx
c0100275:	01 d2                	add    %edx,%edx
c0100277:	01 c2                	add    %eax,%edx
c0100279:	a1 d4 53 10 c0       	mov    0xc01053d4,%eax
c010027e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c0100281:	01 c9                	add    %ecx,%ecx
c0100283:	01 c8                	add    %ecx,%eax
c0100285:	0f b7 00             	movzwl (%eax),%eax
c0100288:	66 89 02             	mov    %ax,(%edx)


static void
wrap_screen() {
	int i;
	for (i = CRT_COLUMN; i < CRT_ROW * CRT_COLUMN; i ++)
c010028b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c010028f:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
c0100296:	7e d2                	jle    c010026a <wrap_screen+0xf>
		vmem[i - CRT_COLUMN] = vmem[i];
	for (i = 0; i < CRT_COLUMN; i ++)
c0100298:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c010029f:	eb 23                	jmp    c01002c4 <wrap_screen+0x69>
		vmem[CRT_ROW * CRT_COLUMN - i - 1] = (BLACK << 12) | (WHITE << 8) | ' ';
c01002a1:	8b 15 d4 53 10 c0    	mov    0xc01053d4,%edx
c01002a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01002aa:	8d 88 31 f8 ff ff    	lea    -0x7cf(%eax),%ecx
c01002b0:	b8 00 00 00 00       	mov    $0x0,%eax
c01002b5:	29 c8                	sub    %ecx,%eax
c01002b7:	01 c0                	add    %eax,%eax
c01002b9:	01 d0                	add    %edx,%eax
c01002bb:	66 c7 00 20 07       	movw   $0x720,(%eax)
static void
wrap_screen() {
	int i;
	for (i = CRT_COLUMN; i < CRT_ROW * CRT_COLUMN; i ++)
		vmem[i - CRT_COLUMN] = vmem[i];
	for (i = 0; i < CRT_COLUMN; i ++)
c01002c0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01002c4:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
c01002c8:	7e d7                	jle    c01002a1 <wrap_screen+0x46>
		vmem[CRT_ROW * CRT_COLUMN - i - 1] = (BLACK << 12) | (WHITE << 8) | ' ';
}
c01002ca:	c9                   	leave  
c01002cb:	c3                   	ret    

c01002cc <color_console_printc>:

/* find the postion, then put the character */
void
color_console_printc(int forecolor, int backcolor, char ch) {
c01002cc:	55                   	push   %ebp
c01002cd:	89 e5                	mov    %esp,%ebp
c01002cf:	83 ec 0c             	sub    $0xc,%esp
c01002d2:	8b 45 10             	mov    0x10(%ebp),%eax
c01002d5:	88 45 fc             	mov    %al,-0x4(%ebp)
	switch (ch) {
c01002d8:	0f be 45 fc          	movsbl -0x4(%ebp),%eax
c01002dc:	83 f8 0a             	cmp    $0xa,%eax
c01002df:	75 19                	jne    c01002fa <color_console_printc+0x2e>
	case '\n': /* everyone will get mad if linebreak is not provided */
		x ++;
c01002e1:	a1 00 60 10 c0       	mov    0xc0106000,%eax
c01002e6:	83 c0 01             	add    $0x1,%eax
c01002e9:	a3 00 60 10 c0       	mov    %eax,0xc0106000
		y = 0;
c01002ee:	c7 05 04 60 10 c0 00 	movl   $0x0,0xc0106004
c01002f5:	00 00 00 
		break;
c01002f8:	eb 6c                	jmp    c0100366 <color_console_printc+0x9a>
	default: /* print the character otherwise */
		vmem[x * CRT_COLUMN + y] = (backcolor << 12) | (forecolor << 8) | ch;
c01002fa:	8b 0d d4 53 10 c0    	mov    0xc01053d4,%ecx
c0100300:	8b 15 00 60 10 c0    	mov    0xc0106000,%edx
c0100306:	89 d0                	mov    %edx,%eax
c0100308:	c1 e0 02             	shl    $0x2,%eax
c010030b:	01 d0                	add    %edx,%eax
c010030d:	c1 e0 04             	shl    $0x4,%eax
c0100310:	89 c2                	mov    %eax,%edx
c0100312:	a1 04 60 10 c0       	mov    0xc0106004,%eax
c0100317:	01 d0                	add    %edx,%eax
c0100319:	01 c0                	add    %eax,%eax
c010031b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c010031e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100321:	c1 e0 0c             	shl    $0xc,%eax
c0100324:	89 c1                	mov    %eax,%ecx
c0100326:	8b 45 08             	mov    0x8(%ebp),%eax
c0100329:	c1 e0 08             	shl    $0x8,%eax
c010032c:	09 c1                	or     %eax,%ecx
c010032e:	66 0f be 45 fc       	movsbw -0x4(%ebp),%ax
c0100333:	09 c8                	or     %ecx,%eax
c0100335:	66 89 02             	mov    %ax,(%edx)
		y ++;
c0100338:	a1 04 60 10 c0       	mov    0xc0106004,%eax
c010033d:	83 c0 01             	add    $0x1,%eax
c0100340:	a3 04 60 10 c0       	mov    %eax,0xc0106004
		if (y >= CRT_COLUMN) {
c0100345:	a1 04 60 10 c0       	mov    0xc0106004,%eax
c010034a:	83 f8 4f             	cmp    $0x4f,%eax
c010034d:	7e 17                	jle    c0100366 <color_console_printc+0x9a>
			x ++;
c010034f:	a1 00 60 10 c0       	mov    0xc0106000,%eax
c0100354:	83 c0 01             	add    $0x1,%eax
c0100357:	a3 00 60 10 c0       	mov    %eax,0xc0106000
			y = 0;
c010035c:	c7 05 04 60 10 c0 00 	movl   $0x0,0xc0106004
c0100363:	00 00 00 
		}
	}
	if (x >= CRT_ROW) { /* bottom touched! */
c0100366:	a1 00 60 10 c0       	mov    0xc0106000,%eax
c010036b:	83 f8 18             	cmp    $0x18,%eax
c010036e:	7e 0f                	jle    c010037f <color_console_printc+0xb3>
		x = CRT_ROW - 1;
c0100370:	c7 05 00 60 10 c0 18 	movl   $0x18,0xc0106000
c0100377:	00 00 00 
		wrap_screen();
c010037a:	e8 dc fe ff ff       	call   c010025b <wrap_screen>
	}
	move_cursor(x, y);
c010037f:	8b 15 04 60 10 c0    	mov    0xc0106004,%edx
c0100385:	a1 00 60 10 c0       	mov    0xc0106000,%eax
c010038a:	89 54 24 04          	mov    %edx,0x4(%esp)
c010038e:	89 04 24             	mov    %eax,(%esp)
c0100391:	e8 34 fd ff ff       	call   c01000ca <move_cursor>
}
c0100396:	c9                   	leave  
c0100397:	c3                   	ret    

c0100398 <console_printc>:

void
console_printc(char ch) {
c0100398:	55                   	push   %ebp
c0100399:	89 e5                	mov    %esp,%ebp
c010039b:	83 ec 10             	sub    $0x10,%esp
c010039e:	8b 45 08             	mov    0x8(%ebp),%eax
c01003a1:	88 45 fc             	mov    %al,-0x4(%ebp)
	color_console_printc(WHITE, BLACK, ch);
c01003a4:	0f be 45 fc          	movsbl -0x4(%ebp),%eax
c01003a8:	89 44 24 08          	mov    %eax,0x8(%esp)
c01003ac:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01003b3:	00 
c01003b4:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
c01003bb:	e8 0c ff ff ff       	call   c01002cc <color_console_printc>
}
c01003c0:	c9                   	leave  
c01003c1:	c3                   	ret    

c01003c2 <red_console_printc>:



void
red_console_printc(char ch) {
c01003c2:	55                   	push   %ebp
c01003c3:	89 e5                	mov    %esp,%ebp
c01003c5:	83 ec 10             	sub    $0x10,%esp
c01003c8:	8b 45 08             	mov    0x8(%ebp),%eax
c01003cb:	88 45 fc             	mov    %al,-0x4(%ebp)
	color_console_printc(RED, BLACK, ch);
c01003ce:	0f be 45 fc          	movsbl -0x4(%ebp),%eax
c01003d2:	89 44 24 08          	mov    %eax,0x8(%esp)
c01003d6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01003dd:	00 
c01003de:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
c01003e5:	e8 e2 fe ff ff       	call   c01002cc <color_console_printc>
}
c01003ea:	c9                   	leave  
c01003eb:	c3                   	ret    

c01003ec <printk>:


void
printk(const char *ctl, ...) {
c01003ec:	55                   	push   %ebp
c01003ed:	89 e5                	mov    %esp,%ebp
c01003ef:	83 ec 28             	sub    $0x28,%esp
	void **args = (void **)&ctl + 1;
c01003f2:	8d 45 0c             	lea    0xc(%ebp),%eax
c01003f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vfprintf(console_printc, ctl, args);
c01003f8:	8b 45 08             	mov    0x8(%ebp),%eax
c01003fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01003fe:	89 54 24 08          	mov    %edx,0x8(%esp)
c0100402:	89 44 24 04          	mov    %eax,0x4(%esp)
c0100406:	c7 04 24 98 03 10 c0 	movl   $0xc0100398,(%esp)
c010040d:	e8 66 00 00 00       	call   c0100478 <vfprintf>
}
c0100412:	c9                   	leave  
c0100413:	c3                   	ret    

c0100414 <panic>:

void
panic(const char *ctl, ...) {
c0100414:	55                   	push   %ebp
c0100415:	89 e5                	mov    %esp,%ebp
c0100417:	83 ec 28             	sub    $0x28,%esp
	void *args = (void **)&ctl + 1;
c010041a:	8d 45 0c             	lea    0xc(%ebp),%eax
c010041d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vfprintf(console_printc, ctl, args);
c0100420:	8b 45 08             	mov    0x8(%ebp),%eax
c0100423:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0100426:	89 54 24 08          	mov    %edx,0x8(%esp)
c010042a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010042e:	c7 04 24 98 03 10 c0 	movl   $0xc0100398,(%esp)
c0100435:	e8 3e 00 00 00       	call   c0100478 <vfprintf>
	disable_interrupt();
c010043a:	e8 67 fc ff ff       	call   c01000a6 <disable_interrupt>
	while (1) {
		idle_cpu();
c010043f:	e8 5c fc ff ff       	call   c01000a0 <idle_cpu>
	}
c0100444:	eb f9                	jmp    c010043f <panic+0x2b>

c0100446 <color_panic>:
}

void
color_panic(const char *ctl, ...) {
c0100446:	55                   	push   %ebp
c0100447:	89 e5                	mov    %esp,%ebp
c0100449:	83 ec 28             	sub    $0x28,%esp
	void *args = (void **)&ctl + 1;
c010044c:	8d 45 0c             	lea    0xc(%ebp),%eax
c010044f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vfprintf(red_console_printc, ctl, args);
c0100452:	8b 45 08             	mov    0x8(%ebp),%eax
c0100455:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0100458:	89 54 24 08          	mov    %edx,0x8(%esp)
c010045c:	89 44 24 04          	mov    %eax,0x4(%esp)
c0100460:	c7 04 24 c2 03 10 c0 	movl   $0xc01003c2,(%esp)
c0100467:	e8 0c 00 00 00       	call   c0100478 <vfprintf>
	disable_interrupt();
c010046c:	e8 35 fc ff ff       	call   c01000a6 <disable_interrupt>
	while (1) {
		idle_cpu();
c0100471:	e8 2a fc ff ff       	call   c01000a0 <idle_cpu>
	}
c0100476:	eb f9                	jmp    c0100471 <color_panic+0x2b>

c0100478 <vfprintf>:
#include "kernel.h"

#define MAX_LEN 10

void
vfprintf(void (*printer)(char), const char *ctl, void **args) {
c0100478:	55                   	push   %ebp
c0100479:	89 e5                	mov    %esp,%ebp
c010047b:	83 ec 58             	sub    $0x58,%esp
	int_32 dec;
	uint_32 hex;
	char *ch;
	int i;
	
	for (; *ctl != 0; ++ ctl)
c010047e:	e9 f4 01 00 00       	jmp    c0100677 <vfprintf+0x1ff>
	{
		if (*ctl != '%') printer(*ctl);
c0100483:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100486:	0f b6 00             	movzbl (%eax),%eax
c0100489:	3c 25                	cmp    $0x25,%al
c010048b:	74 16                	je     c01004a3 <vfprintf+0x2b>
c010048d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100490:	0f b6 00             	movzbl (%eax),%eax
c0100493:	0f be c0             	movsbl %al,%eax
c0100496:	89 04 24             	mov    %eax,(%esp)
c0100499:	8b 45 08             	mov    0x8(%ebp),%eax
c010049c:	ff d0                	call   *%eax
c010049e:	e9 d0 01 00 00       	jmp    c0100673 <vfprintf+0x1fb>
		else
			switch (*(++ ctl))
c01004a3:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c01004a7:	8b 45 0c             	mov    0xc(%ebp),%eax
c01004aa:	0f b6 00             	movzbl (%eax),%eax
c01004ad:	0f be c0             	movsbl %al,%eax
c01004b0:	83 f8 64             	cmp    $0x64,%eax
c01004b3:	74 33                	je     c01004e8 <vfprintf+0x70>
c01004b5:	83 f8 64             	cmp    $0x64,%eax
c01004b8:	7f 17                	jg     c01004d1 <vfprintf+0x59>
c01004ba:	83 f8 25             	cmp    $0x25,%eax
c01004bd:	0f 84 5d 01 00 00    	je     c0100620 <vfprintf+0x1a8>
c01004c3:	83 f8 63             	cmp    $0x63,%eax
c01004c6:	0f 84 62 01 00 00    	je     c010062e <vfprintf+0x1b6>
c01004cc:	e9 a2 01 00 00       	jmp    c0100673 <vfprintf+0x1fb>
c01004d1:	83 f8 73             	cmp    $0x73,%eax
c01004d4:	0f 84 6b 01 00 00    	je     c0100645 <vfprintf+0x1cd>
c01004da:	83 f8 78             	cmp    $0x78,%eax
c01004dd:	0f 84 c1 00 00 00    	je     c01005a4 <vfprintf+0x12c>
c01004e3:	e9 8b 01 00 00       	jmp    c0100673 <vfprintf+0x1fb>
			{
				case 'd':	dec = *((int_32 *)args ++);
c01004e8:	8b 45 10             	mov    0x10(%ebp),%eax
c01004eb:	8b 00                	mov    (%eax),%eax
c01004ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
c01004f0:	83 45 10 04          	addl   $0x4,0x10(%ebp)
						if (dec == 0) printer('0');
c01004f4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c01004f8:	75 11                	jne    c010050b <vfprintf+0x93>
c01004fa:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
c0100501:	8b 45 08             	mov    0x8(%ebp),%eax
c0100504:	ff d0                	call   *%eax
							for (i = 0; dec != 0; dec /= 10, ++ i)
								temp[i] = dec % 10;	
							for (-- i; i >= 0; -- i)
								printer(temp[i] + 48);
						}
						break;
c0100506:	e9 68 01 00 00       	jmp    c0100673 <vfprintf+0x1fb>
			{
				case 'd':	dec = *((int_32 *)args ++);
						if (dec == 0) printer('0');
						else
						{
							if (dec < 0)
c010050b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010050f:	79 0f                	jns    c0100520 <vfprintf+0xa8>
							{
								printer('-');
c0100511:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
c0100518:	8b 45 08             	mov    0x8(%ebp),%eax
c010051b:	ff d0                	call   *%eax
								dec = -dec;
c010051d:	f7 5d f4             	negl   -0xc(%ebp)
							}
							for (i = 0; dec != 0; dec /= 10, ++ i)
c0100520:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0100527:	eb 4b                	jmp    c0100574 <vfprintf+0xfc>
								temp[i] = dec % 10;	
c0100529:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c010052c:	ba 67 66 66 66       	mov    $0x66666667,%edx
c0100531:	89 c8                	mov    %ecx,%eax
c0100533:	f7 ea                	imul   %edx
c0100535:	c1 fa 02             	sar    $0x2,%edx
c0100538:	89 c8                	mov    %ecx,%eax
c010053a:	c1 f8 1f             	sar    $0x1f,%eax
c010053d:	29 c2                	sub    %eax,%edx
c010053f:	89 d0                	mov    %edx,%eax
c0100541:	c1 e0 02             	shl    $0x2,%eax
c0100544:	01 d0                	add    %edx,%eax
c0100546:	01 c0                	add    %eax,%eax
c0100548:	89 ca                	mov    %ecx,%edx
c010054a:	29 c2                	sub    %eax,%edx
c010054c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010054f:	89 54 85 c0          	mov    %edx,-0x40(%ebp,%eax,4)
							if (dec < 0)
							{
								printer('-');
								dec = -dec;
							}
							for (i = 0; dec != 0; dec /= 10, ++ i)
c0100553:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0100556:	ba 67 66 66 66       	mov    $0x66666667,%edx
c010055b:	89 c8                	mov    %ecx,%eax
c010055d:	f7 ea                	imul   %edx
c010055f:	c1 fa 02             	sar    $0x2,%edx
c0100562:	89 c8                	mov    %ecx,%eax
c0100564:	c1 f8 1f             	sar    $0x1f,%eax
c0100567:	89 d1                	mov    %edx,%ecx
c0100569:	29 c1                	sub    %eax,%ecx
c010056b:	89 c8                	mov    %ecx,%eax
c010056d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0100570:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0100574:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0100578:	75 af                	jne    c0100529 <vfprintf+0xb1>
								temp[i] = dec % 10;	
							for (-- i; i >= 0; -- i)
c010057a:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
c010057e:	eb 19                	jmp    c0100599 <vfprintf+0x121>
								printer(temp[i] + 48);
c0100580:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0100583:	8b 44 85 c0          	mov    -0x40(%ebp,%eax,4),%eax
c0100587:	83 c0 30             	add    $0x30,%eax
c010058a:	0f be c0             	movsbl %al,%eax
c010058d:	89 04 24             	mov    %eax,(%esp)
c0100590:	8b 45 08             	mov    0x8(%ebp),%eax
c0100593:	ff d0                	call   *%eax
								printer('-');
								dec = -dec;
							}
							for (i = 0; dec != 0; dec /= 10, ++ i)
								temp[i] = dec % 10;	
							for (-- i; i >= 0; -- i)
c0100595:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
c0100599:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c010059d:	79 e1                	jns    c0100580 <vfprintf+0x108>
								printer(temp[i] + 48);
						}
						break;
c010059f:	e9 cf 00 00 00       	jmp    c0100673 <vfprintf+0x1fb>

				case 'x':	hex = *((uint_32 *)args ++);
c01005a4:	8b 45 10             	mov    0x10(%ebp),%eax
c01005a7:	8b 00                	mov    (%eax),%eax
c01005a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c01005ac:	83 45 10 04          	addl   $0x4,0x10(%ebp)
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
c01005b0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c01005b7:	eb 17                	jmp    c01005d0 <vfprintf+0x158>
							temp[i] = hex & 0xF;
c01005b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01005bc:	89 c2                	mov    %eax,%edx
c01005be:	83 e2 0f             	and    $0xf,%edx
c01005c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01005c4:	89 54 85 c0          	mov    %edx,-0x40(%ebp,%eax,4)
								printer(temp[i] + 48);
						}
						break;

				case 'x':	hex = *((uint_32 *)args ++);
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
c01005c8:	c1 6d f0 04          	shrl   $0x4,-0x10(%ebp)
c01005cc:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c01005d0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c01005d4:	75 e3                	jne    c01005b9 <vfprintf+0x141>
							temp[i] = hex & 0xF;
						for (-- i; i >= 0; -- i)
c01005d6:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
c01005da:	eb 3c                	jmp    c0100618 <vfprintf+0x1a0>
							if (temp[i] < 10)
c01005dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01005df:	8b 44 85 c0          	mov    -0x40(%ebp,%eax,4),%eax
c01005e3:	83 f8 09             	cmp    $0x9,%eax
c01005e6:	77 17                	ja     c01005ff <vfprintf+0x187>
								printer(temp[i] + 48);
c01005e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01005eb:	8b 44 85 c0          	mov    -0x40(%ebp,%eax,4),%eax
c01005ef:	83 c0 30             	add    $0x30,%eax
c01005f2:	0f be c0             	movsbl %al,%eax
c01005f5:	89 04 24             	mov    %eax,(%esp)
c01005f8:	8b 45 08             	mov    0x8(%ebp),%eax
c01005fb:	ff d0                	call   *%eax
c01005fd:	eb 15                	jmp    c0100614 <vfprintf+0x19c>
							else
								printer(temp[i] - 10 + 65);
c01005ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0100602:	8b 44 85 c0          	mov    -0x40(%ebp,%eax,4),%eax
c0100606:	83 c0 37             	add    $0x37,%eax
c0100609:	0f be c0             	movsbl %al,%eax
c010060c:	89 04 24             	mov    %eax,(%esp)
c010060f:	8b 45 08             	mov    0x8(%ebp),%eax
c0100612:	ff d0                	call   *%eax
						break;

				case 'x':	hex = *((uint_32 *)args ++);
						for (i = 0; hex != 0; hex = hex >> 4, ++ i)
							temp[i] = hex & 0xF;
						for (-- i; i >= 0; -- i)
c0100614:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
c0100618:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c010061c:	79 be                	jns    c01005dc <vfprintf+0x164>
							if (temp[i] < 10)
								printer(temp[i] + 48);
							else
								printer(temp[i] - 10 + 65);
						break;
c010061e:	eb 53                	jmp    c0100673 <vfprintf+0x1fb>

				case '%':	printer('%');
c0100620:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
c0100627:	8b 45 08             	mov    0x8(%ebp),%eax
c010062a:	ff d0                	call   *%eax
						break;
c010062c:	eb 45                	jmp    c0100673 <vfprintf+0x1fb>

				case 'c':	printer(*((char *)args ++));
c010062e:	8b 45 10             	mov    0x10(%ebp),%eax
c0100631:	0f b6 00             	movzbl (%eax),%eax
c0100634:	0f be c0             	movsbl %al,%eax
c0100637:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c010063b:	89 04 24             	mov    %eax,(%esp)
c010063e:	8b 45 08             	mov    0x8(%ebp),%eax
c0100641:	ff d0                	call   *%eax
						break;
c0100643:	eb 2e                	jmp    c0100673 <vfprintf+0x1fb>

				case 's':	for (ch = (char *)(*(args ++)); *ch != 0; ++ ch)
c0100645:	8b 45 10             	mov    0x10(%ebp),%eax
c0100648:	8b 00                	mov    (%eax),%eax
c010064a:	89 45 ec             	mov    %eax,-0x14(%ebp)
c010064d:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0100651:	eb 15                	jmp    c0100668 <vfprintf+0x1f0>
							printer(*ch);
c0100653:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0100656:	0f b6 00             	movzbl (%eax),%eax
c0100659:	0f be c0             	movsbl %al,%eax
c010065c:	89 04 24             	mov    %eax,(%esp)
c010065f:	8b 45 08             	mov    0x8(%ebp),%eax
c0100662:	ff d0                	call   *%eax
						break;

				case 'c':	printer(*((char *)args ++));
						break;

				case 's':	for (ch = (char *)(*(args ++)); *ch != 0; ++ ch)
c0100664:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0100668:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010066b:	0f b6 00             	movzbl (%eax),%eax
c010066e:	84 c0                	test   %al,%al
c0100670:	75 e1                	jne    c0100653 <vfprintf+0x1db>
							printer(*ch);
						break; 
c0100672:	90                   	nop
	int_32 dec;
	uint_32 hex;
	char *ch;
	int i;
	
	for (; *ctl != 0; ++ ctl)
c0100673:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c0100677:	8b 45 0c             	mov    0xc(%ebp),%eax
c010067a:	0f b6 00             	movzbl (%eax),%eax
c010067d:	84 c0                	test   %al,%al
c010067f:	0f 85 fe fd ff ff    	jne    c0100483 <vfprintf+0xb>

			}
	}


}
c0100685:	c9                   	leave  
c0100686:	c3                   	ret    
c0100687:	90                   	nop

c0100688 <load_cr0>:
	asm volatile("hlt");
}

/* read CR0 */
static inline void
load_cr0(struct CR0 *ptr) {
c0100688:	55                   	push   %ebp
c0100689:	89 e5                	mov    %esp,%ebp
c010068b:	53                   	push   %ebx
c010068c:	83 ec 10             	sub    $0x10,%esp
	uint_32 val;
	asm volatile("movl %%cr0, %0" : "=r"(val));
c010068f:	0f 20 c3             	mov    %cr0,%ebx
c0100692:	89 5d f8             	mov    %ebx,-0x8(%ebp)
	*((uint_32*)ptr) = val;
c0100695:	8b 45 08             	mov    0x8(%ebp),%eax
c0100698:	8b 55 f8             	mov    -0x8(%ebp),%edx
c010069b:	89 10                	mov    %edx,(%eax)
}
c010069d:	83 c4 10             	add    $0x10,%esp
c01006a0:	5b                   	pop    %ebx
c01006a1:	5d                   	pop    %ebp
c01006a2:	c3                   	ret    

c01006a3 <save_cr0>:

/* write CR0 */
static inline void
save_cr0(struct CR0 *ptr) {
c01006a3:	55                   	push   %ebp
c01006a4:	89 e5                	mov    %esp,%ebp
c01006a6:	83 ec 10             	sub    $0x10,%esp
	uint_32 val = *((uint_32*)ptr);
c01006a9:	8b 45 08             	mov    0x8(%ebp),%eax
c01006ac:	8b 00                	mov    (%eax),%eax
c01006ae:	89 45 fc             	mov    %eax,-0x4(%ebp)
	asm volatile("movl %0, %%cr0" : : "r"(val));
c01006b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01006b4:	0f 22 c0             	mov    %eax,%cr0
}
c01006b7:	c9                   	leave  
c01006b8:	c3                   	ret    

c01006b9 <save_cr3>:

/* write CR3, notice that CR3 are never read in Nanos */
static inline void
save_cr3(struct CR3 *ptr) {
c01006b9:	55                   	push   %ebp
c01006ba:	89 e5                	mov    %esp,%ebp
c01006bc:	83 ec 10             	sub    $0x10,%esp
	uint_32 val = *((uint_32*)ptr);
c01006bf:	8b 45 08             	mov    0x8(%ebp),%eax
c01006c2:	8b 00                	mov    (%eax),%eax
c01006c4:	89 45 fc             	mov    %eax,-0x4(%ebp)
	asm volatile("movl %0, %%cr3" : : "r"(val));
c01006c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01006ca:	0f 22 d8             	mov    %eax,%cr3
}
c01006cd:	c9                   	leave  
c01006ce:	c3                   	ret    

c01006cf <save_gdt>:

/* modify the value of GDTR */
static inline void
save_gdt(void *addr, uint_32 size) {
c01006cf:	55                   	push   %ebp
c01006d0:	89 e5                	mov    %esp,%ebp
	static volatile uint_16 data[3];
	data[0] = size - 1;
c01006d2:	8b 45 0c             	mov    0xc(%ebp),%eax
c01006d5:	83 e8 01             	sub    $0x1,%eax
c01006d8:	66 a3 20 60 10 c0    	mov    %ax,0xc0106020
	data[1] = (uint_32)addr;
c01006de:	8b 45 08             	mov    0x8(%ebp),%eax
c01006e1:	66 a3 22 60 10 c0    	mov    %ax,0xc0106022
	data[2] = ((uint_32)addr) >> 16;
c01006e7:	8b 45 08             	mov    0x8(%ebp),%eax
c01006ea:	c1 e8 10             	shr    $0x10,%eax
c01006ed:	66 a3 24 60 10 c0    	mov    %ax,0xc0106024
	asm volatile("lgdt (%0)" : : "r"(data));
c01006f3:	b8 20 60 10 c0       	mov    $0xc0106020,%eax
c01006f8:	0f 01 10             	lgdtl  (%eax)
}
c01006fb:	5d                   	pop    %ebp
c01006fc:	c3                   	ret    

c01006fd <init_page>:
struct PageDirectoryEntry kpagedir[NR_PDE_ENTRY] align_to_page;
struct PageTableEntry kpagetable[USER_MEM_HIGH / PAGE_SIZE] align_to_page;

/* Build a page table for the kernel */
void
init_page(void) {
c01006fd:	55                   	push   %ebp
c01006fe:	89 e5                	mov    %esp,%ebp
c0100700:	83 ec 38             	sub    $0x38,%esp
	struct PageTableEntry *pent;
	struct CR0 cr0;
	struct CR3 cr3;
	uint_32 i, j;

	pdir = (struct PageDirectoryEntry *)va_to_pa(kpagedir);
c0100703:	b8 00 80 13 c0       	mov    $0xc0138000,%eax
c0100708:	05 00 00 00 40       	add    $0x40000000,%eax
c010070d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	pent = (struct PageTableEntry *)va_to_pa(kpagetable);
c0100710:	b8 00 80 11 c0       	mov    $0xc0118000,%eax
c0100715:	05 00 00 00 40       	add    $0x40000000,%eax
c010071a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	for (i = 0; i < NR_PDE_ENTRY; i ++) {
c010071d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0100724:	eb 15                	jmp    c010073b <init_page+0x3e>
		make_invalid_pde(&pdir[i]);
c0100726:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0100729:	c1 e0 02             	shl    $0x2,%eax
c010072c:	03 45 e8             	add    -0x18(%ebp),%eax
c010072f:	89 04 24             	mov    %eax,(%esp)
c0100732:	e8 e9 01 00 00       	call   c0100920 <make_invalid_pde>
	uint_32 i, j;

	pdir = (struct PageDirectoryEntry *)va_to_pa(kpagedir);
	pent = (struct PageTableEntry *)va_to_pa(kpagetable);

	for (i = 0; i < NR_PDE_ENTRY; i ++) {
c0100737:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010073b:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c0100742:	76 e2                	jbe    c0100726 <init_page+0x29>
		make_invalid_pde(&pdir[i]);
	}

	for (i = 0; i < USER_MEM_HIGH / PD_SIZE; i ++) {
c0100744:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010074b:	eb 6e                	jmp    c01007bb <init_page+0xbe>
		make_pde(&pdir[i], pent);
c010074d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0100750:	c1 e0 02             	shl    $0x2,%eax
c0100753:	03 45 e8             	add    -0x18(%ebp),%eax
c0100756:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0100759:	89 54 24 04          	mov    %edx,0x4(%esp)
c010075d:	89 04 24             	mov    %eax,(%esp)
c0100760:	e8 d7 01 00 00       	call   c010093c <make_pde>
		make_pde(&pdir[i + KOFFSET / PD_SIZE], pent);
c0100765:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0100768:	05 00 03 00 00       	add    $0x300,%eax
c010076d:	c1 e0 02             	shl    $0x2,%eax
c0100770:	03 45 e8             	add    -0x18(%ebp),%eax
c0100773:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0100776:	89 54 24 04          	mov    %edx,0x4(%esp)
c010077a:	89 04 24             	mov    %eax,(%esp)
c010077d:	e8 ba 01 00 00       	call   c010093c <make_pde>
		for (j = 0; j < NR_PTE_ENTRY; j ++) {
c0100782:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0100789:	eb 23                	jmp    c01007ae <init_page+0xb1>
			make_pte(pent, (void*)((i * NR_PTE_ENTRY + j) << 12));
c010078b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010078e:	c1 e0 0a             	shl    $0xa,%eax
c0100791:	03 45 ec             	add    -0x14(%ebp),%eax
c0100794:	c1 e0 0c             	shl    $0xc,%eax
c0100797:	89 44 24 04          	mov    %eax,0x4(%esp)
c010079b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010079e:	89 04 24             	mov    %eax,(%esp)
c01007a1:	e8 e7 01 00 00       	call   c010098d <make_pte>
			pent ++;
c01007a6:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
	}

	for (i = 0; i < USER_MEM_HIGH / PD_SIZE; i ++) {
		make_pde(&pdir[i], pent);
		make_pde(&pdir[i + KOFFSET / PD_SIZE], pent);
		for (j = 0; j < NR_PTE_ENTRY; j ++) {
c01007aa:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c01007ae:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
c01007b5:	76 d4                	jbe    c010078b <init_page+0x8e>

	for (i = 0; i < NR_PDE_ENTRY; i ++) {
		make_invalid_pde(&pdir[i]);
	}

	for (i = 0; i < USER_MEM_HIGH / PD_SIZE; i ++) {
c01007b7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c01007bb:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
c01007bf:	76 8c                	jbe    c010074d <init_page+0x50>
			pent ++;
		}
	}

	/* make CR3 to be the entry of page directory */
	*(uint_32*)&cr3 = 0;
c01007c1:	8d 45 e0             	lea    -0x20(%ebp),%eax
c01007c4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	cr3.page_directory_base = ((uint_32)pdir) >> 12;
c01007ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01007cd:	c1 e8 0c             	shr    $0xc,%eax
c01007d0:	25 ff ff 0f 00       	and    $0xfffff,%eax
c01007d5:	89 c2                	mov    %eax,%edx
c01007d7:	c1 e2 0c             	shl    $0xc,%edx
c01007da:	8b 45 e0             	mov    -0x20(%ebp),%eax
c01007dd:	25 ff 0f 00 00       	and    $0xfff,%eax
c01007e2:	09 d0                	or     %edx,%eax
c01007e4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	save_cr3(&cr3);
c01007e7:	8d 45 e0             	lea    -0x20(%ebp),%eax
c01007ea:	89 04 24             	mov    %eax,(%esp)
c01007ed:	e8 c7 fe ff ff       	call   c01006b9 <save_cr3>

	/* set PG bit in CR0 */
	load_cr0(&cr0);
c01007f2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c01007f5:	89 04 24             	mov    %eax,(%esp)
c01007f8:	e8 8b fe ff ff       	call   c0100688 <load_cr0>
	cr0.paging = 1;
c01007fd:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
c0100801:	83 c8 80             	or     $0xffffff80,%eax
c0100804:	88 45 e7             	mov    %al,-0x19(%ebp)
	save_cr0(&cr0);
c0100807:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010080a:	89 04 24             	mov    %eax,(%esp)
c010080d:	e8 91 fe ff ff       	call   c01006a3 <save_cr0>
}
c0100812:	c9                   	leave  
c0100813:	c3                   	ret    

c0100814 <set_segment>:
/* GDT in the kernel's memory, whoes virtual memory is greater than
   0xC0000000. */
static struct SegmentDescriptor gdt[NR_SEGMENTS];

static void
set_segment(struct SegmentDescriptor *ptr, uint_32 type) {
c0100814:	55                   	push   %ebp
c0100815:	89 e5                	mov    %esp,%ebp
	ptr->limit_15_0  = 0xFFFF;
c0100817:	8b 45 08             	mov    0x8(%ebp),%eax
c010081a:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
	ptr->base_15_0   = 0x0;
c010081f:	8b 45 08             	mov    0x8(%ebp),%eax
c0100822:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	ptr->base_23_16  = 0x0;
c0100828:	8b 45 08             	mov    0x8(%ebp),%eax
c010082b:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	ptr->type = type;
c010082f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100832:	89 c2                	mov    %eax,%edx
c0100834:	83 e2 0f             	and    $0xf,%edx
c0100837:	8b 45 08             	mov    0x8(%ebp),%eax
c010083a:	89 d1                	mov    %edx,%ecx
c010083c:	83 e1 0f             	and    $0xf,%ecx
c010083f:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c0100843:	83 e2 f0             	and    $0xfffffff0,%edx
c0100846:	09 ca                	or     %ecx,%edx
c0100848:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->segment_type = 1;
c010084b:	8b 45 08             	mov    0x8(%ebp),%eax
c010084e:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c0100852:	83 ca 10             	or     $0x10,%edx
c0100855:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->privilege_level = DPL_KERNEL;
c0100858:	8b 45 08             	mov    0x8(%ebp),%eax
c010085b:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c010085f:	83 e2 9f             	and    $0xffffff9f,%edx
c0100862:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->present = 1;
c0100865:	8b 45 08             	mov    0x8(%ebp),%eax
c0100868:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c010086c:	83 ca 80             	or     $0xffffff80,%edx
c010086f:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->limit_19_16 = 0xF;
c0100872:	8b 45 08             	mov    0x8(%ebp),%eax
c0100875:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c0100879:	83 ca 0f             	or     $0xf,%edx
c010087c:	88 50 06             	mov    %dl,0x6(%eax)
	ptr->soft_use = 0;
c010087f:	8b 45 08             	mov    0x8(%ebp),%eax
c0100882:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c0100886:	83 e2 ef             	and    $0xffffffef,%edx
c0100889:	88 50 06             	mov    %dl,0x6(%eax)
	ptr->operation_size = 0;
c010088c:	8b 45 08             	mov    0x8(%ebp),%eax
c010088f:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c0100893:	83 e2 df             	and    $0xffffffdf,%edx
c0100896:	88 50 06             	mov    %dl,0x6(%eax)
	ptr->pad0 = 1;
c0100899:	8b 45 08             	mov    0x8(%ebp),%eax
c010089c:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c01008a0:	83 ca 40             	or     $0x40,%edx
c01008a3:	88 50 06             	mov    %dl,0x6(%eax)
	ptr->granularity = 1;
c01008a6:	8b 45 08             	mov    0x8(%ebp),%eax
c01008a9:	0f b6 50 06          	movzbl 0x6(%eax),%edx
c01008ad:	83 ca 80             	or     $0xffffff80,%edx
c01008b0:	88 50 06             	mov    %dl,0x6(%eax)
	ptr->base_31_24  = 0x0;
c01008b3:	8b 45 08             	mov    0x8(%ebp),%eax
c01008b6:	c6 40 07 00          	movb   $0x0,0x7(%eax)
}
c01008ba:	5d                   	pop    %ebp
c01008bb:	c3                   	ret    

c01008bc <init_segment>:

/* This is exactly the same as the one in the bootloader. However the
   previous one cannot be accessed in user process, because its virtual
   address below 0xC0000000, and is mapped into process' private space. */
void
init_segment(void) {
c01008bc:	55                   	push   %ebp
c01008bd:	89 e5                	mov    %esp,%ebp
c01008bf:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < sizeof(gdt); i ++) {
c01008c2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01008c9:	eb 0f                	jmp    c01008da <init_segment+0x1e>
		((uint_8*)gdt)[i] = 0;
c01008cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01008ce:	05 08 60 10 c0       	add    $0xc0106008,%eax
c01008d3:	c6 00 00             	movb   $0x0,(%eax)
   previous one cannot be accessed in user process, because its virtual
   address below 0xC0000000, and is mapped into process' private space. */
void
init_segment(void) {
	int i;
	for (i = 0; i < sizeof(gdt); i ++) {
c01008d6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01008da:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01008dd:	83 f8 17             	cmp    $0x17,%eax
c01008e0:	76 e9                	jbe    c01008cb <init_segment+0xf>
		((uint_8*)gdt)[i] = 0;
	}
	set_segment(&gdt[SEG_KERNEL_CODE], SEG_EXECUTABLE | SEG_READABLE);
c01008e2:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
c01008e9:	00 
c01008ea:	c7 04 24 10 60 10 c0 	movl   $0xc0106010,(%esp)
c01008f1:	e8 1e ff ff ff       	call   c0100814 <set_segment>
	set_segment(&gdt[SEG_KERNEL_DATA], SEG_WRITABLE );
c01008f6:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
c01008fd:	00 
c01008fe:	c7 04 24 18 60 10 c0 	movl   $0xc0106018,(%esp)
c0100905:	e8 0a ff ff ff       	call   c0100814 <set_segment>
	save_gdt(gdt, sizeof(gdt));
c010090a:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%esp)
c0100911:	00 
c0100912:	c7 04 24 08 60 10 c0 	movl   $0xc0106008,(%esp)
c0100919:	e8 b1 fd ff ff       	call   c01006cf <save_gdt>
}
c010091e:	c9                   	leave  
c010091f:	c3                   	ret    

c0100920 <make_invalid_pde>:
#include "kernel.h"

void
make_invalid_pde(struct PageDirectoryEntry *p) {
c0100920:	55                   	push   %ebp
c0100921:	89 e5                	mov    %esp,%ebp
	*(uint_32*)p = 0;
c0100923:	8b 45 08             	mov    0x8(%ebp),%eax
c0100926:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c010092c:	5d                   	pop    %ebp
c010092d:	c3                   	ret    

c010092e <make_invalid_pte>:
void
make_invalid_pte(struct PageTableEntry *p) {
c010092e:	55                   	push   %ebp
c010092f:	89 e5                	mov    %esp,%ebp
	*(uint_32*)p = 0;
c0100931:	8b 45 08             	mov    0x8(%ebp),%eax
c0100934:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c010093a:	5d                   	pop    %ebp
c010093b:	c3                   	ret    

c010093c <make_pde>:

void
make_pde(struct PageDirectoryEntry *p, void *addr) {
c010093c:	55                   	push   %ebp
c010093d:	89 e5                	mov    %esp,%ebp
	*(uint_32*)p = 0;
c010093f:	8b 45 08             	mov    0x8(%ebp),%eax
c0100942:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	p->page_frame = ((uint_32)addr) >> 12;
c0100948:	8b 45 0c             	mov    0xc(%ebp),%eax
c010094b:	c1 e8 0c             	shr    $0xc,%eax
c010094e:	89 c2                	mov    %eax,%edx
c0100950:	81 e2 ff ff 0f 00    	and    $0xfffff,%edx
c0100956:	8b 45 08             	mov    0x8(%ebp),%eax
c0100959:	89 d1                	mov    %edx,%ecx
c010095b:	c1 e1 0c             	shl    $0xc,%ecx
c010095e:	8b 10                	mov    (%eax),%edx
c0100960:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0100966:	09 ca                	or     %ecx,%edx
c0100968:	89 10                	mov    %edx,(%eax)
	p->present = 1;
c010096a:	8b 45 08             	mov    0x8(%ebp),%eax
c010096d:	0f b6 10             	movzbl (%eax),%edx
c0100970:	83 ca 01             	or     $0x1,%edx
c0100973:	88 10                	mov    %dl,(%eax)
	p->read_write = 1;
c0100975:	8b 45 08             	mov    0x8(%ebp),%eax
c0100978:	0f b6 10             	movzbl (%eax),%edx
c010097b:	83 ca 02             	or     $0x2,%edx
c010097e:	88 10                	mov    %dl,(%eax)
	p->user_supervisor = 1;
c0100980:	8b 45 08             	mov    0x8(%ebp),%eax
c0100983:	0f b6 10             	movzbl (%eax),%edx
c0100986:	83 ca 04             	or     $0x4,%edx
c0100989:	88 10                	mov    %dl,(%eax)
}
c010098b:	5d                   	pop    %ebp
c010098c:	c3                   	ret    

c010098d <make_pte>:

void
make_pte(struct PageTableEntry *p, void *addr) {
c010098d:	55                   	push   %ebp
c010098e:	89 e5                	mov    %esp,%ebp
	*(uint_32*)p = 0;
c0100990:	8b 45 08             	mov    0x8(%ebp),%eax
c0100993:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	p->page_frame = ((uint_32)addr) >> 12;
c0100999:	8b 45 0c             	mov    0xc(%ebp),%eax
c010099c:	c1 e8 0c             	shr    $0xc,%eax
c010099f:	89 c2                	mov    %eax,%edx
c01009a1:	81 e2 ff ff 0f 00    	and    $0xfffff,%edx
c01009a7:	8b 45 08             	mov    0x8(%ebp),%eax
c01009aa:	89 d1                	mov    %edx,%ecx
c01009ac:	c1 e1 0c             	shl    $0xc,%ecx
c01009af:	8b 10                	mov    (%eax),%edx
c01009b1:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c01009b7:	09 ca                	or     %ecx,%edx
c01009b9:	89 10                	mov    %edx,(%eax)
	p->present = 1;
c01009bb:	8b 45 08             	mov    0x8(%ebp),%eax
c01009be:	0f b6 10             	movzbl (%eax),%edx
c01009c1:	83 ca 01             	or     $0x1,%edx
c01009c4:	88 10                	mov    %dl,(%eax)
	p->read_write = 1;
c01009c6:	8b 45 08             	mov    0x8(%ebp),%eax
c01009c9:	0f b6 10             	movzbl (%eax),%edx
c01009cc:	83 ca 02             	or     $0x2,%edx
c01009cf:	88 10                	mov    %dl,(%eax)
	p->user_supervisor = 1;
c01009d1:	8b 45 08             	mov    0x8(%ebp),%eax
c01009d4:	0f b6 10             	movzbl (%eax),%edx
c01009d7:	83 ca 04             	or     $0x4,%edx
c01009da:	88 10                	mov    %dl,(%eax)
}
c01009dc:	5d                   	pop    %ebp
c01009dd:	c3                   	ret    
c01009de:	90                   	nop
c01009df:	90                   	nop

c01009e0 <out_byte>:
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
	return data;
}

static inline void
out_byte(uint_16 port, uint_8 data) {
c01009e0:	55                   	push   %ebp
c01009e1:	89 e5                	mov    %esp,%ebp
c01009e3:	83 ec 08             	sub    $0x8,%esp
c01009e6:	8b 55 08             	mov    0x8(%ebp),%edx
c01009e9:	8b 45 0c             	mov    0xc(%ebp),%eax
c01009ec:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c01009f0:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("out %%al, %%dx" : : "a"(data), "d"(port));
c01009f3:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c01009f7:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c01009fb:	ee                   	out    %al,(%dx)
}
c01009fc:	c9                   	leave  
c01009fd:	c3                   	ret    

c01009fe <init_intr>:

#define PORT_PIC_MASTER 0x20
#define PORT_PIC_SLAVE  0xA0
#define IRQ_SLAVE       2

void init_intr(void) {
c01009fe:	55                   	push   %ebp
c01009ff:	89 e5                	mov    %esp,%ebp
c0100a01:	83 ec 08             	sub    $0x8,%esp
	out_byte(PORT_PIC_MASTER + 1, 0xFF);
c0100a04:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
c0100a0b:	00 
c0100a0c:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c0100a13:	e8 c8 ff ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_SLAVE + 1 , 0xFF);
c0100a18:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
c0100a1f:	00 
c0100a20:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c0100a27:	e8 b4 ff ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_MASTER, 0x11);
c0100a2c:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
c0100a33:	00 
c0100a34:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c0100a3b:	e8 a0 ff ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_MASTER + 1, 32);
c0100a40:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
c0100a47:	00 
c0100a48:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c0100a4f:	e8 8c ff ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_MASTER + 1, 1 << 2);
c0100a54:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
c0100a5b:	00 
c0100a5c:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c0100a63:	e8 78 ff ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_MASTER + 1, 0x3);
c0100a68:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
c0100a6f:	00 
c0100a70:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
c0100a77:	e8 64 ff ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_SLAVE, 0x11);
c0100a7c:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
c0100a83:	00 
c0100a84:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
c0100a8b:	e8 50 ff ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_SLAVE + 1, 32 + 8);
c0100a90:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
c0100a97:	00 
c0100a98:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c0100a9f:	e8 3c ff ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_SLAVE + 1, 2);
c0100aa4:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
c0100aab:	00 
c0100aac:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c0100ab3:	e8 28 ff ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_SLAVE + 1, 0x3);
c0100ab8:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
c0100abf:	00 
c0100ac0:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
c0100ac7:	e8 14 ff ff ff       	call   c01009e0 <out_byte>

	out_byte(PORT_PIC_MASTER, 0x68);
c0100acc:	c7 44 24 04 68 00 00 	movl   $0x68,0x4(%esp)
c0100ad3:	00 
c0100ad4:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c0100adb:	e8 00 ff ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_MASTER, 0x0A);
c0100ae0:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
c0100ae7:	00 
c0100ae8:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c0100aef:	e8 ec fe ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_SLAVE, 0x68);
c0100af4:	c7 44 24 04 68 00 00 	movl   $0x68,0x4(%esp)
c0100afb:	00 
c0100afc:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
c0100b03:	e8 d8 fe ff ff       	call   c01009e0 <out_byte>
	out_byte(PORT_PIC_SLAVE, 0x0A);
c0100b08:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
c0100b0f:	00 
c0100b10:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
c0100b17:	e8 c4 fe ff ff       	call   c01009e0 <out_byte>
}
c0100b1c:	c9                   	leave  
c0100b1d:	c3                   	ret    
c0100b1e:	90                   	nop
c0100b1f:	90                   	nop

c0100b20 <save_idt>:

/* modify the value of IDTR */
static inline void
save_idt(void *addr, uint_32 size) {
c0100b20:	55                   	push   %ebp
c0100b21:	89 e5                	mov    %esp,%ebp
	static volatile uint_16 data[3];
	data[0] = size - 1;
c0100b23:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100b26:	83 e8 01             	sub    $0x1,%eax
c0100b29:	66 a3 28 60 10 c0    	mov    %ax,0xc0106028
	data[1] = (uint_32)addr;
c0100b2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b32:	66 a3 2a 60 10 c0    	mov    %ax,0xc010602a
	data[2] = ((uint_32)addr) >> 16;
c0100b38:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b3b:	c1 e8 10             	shr    $0x10,%eax
c0100b3e:	66 a3 2c 60 10 c0    	mov    %ax,0xc010602c
	asm volatile("lidt (%0)" : : "r"(data));
c0100b44:	b8 28 60 10 c0       	mov    $0xc0106028,%eax
c0100b49:	0f 01 18             	lidtl  (%eax)
}
c0100b4c:	5d                   	pop    %ebp
c0100b4d:	c3                   	ret    

c0100b4e <set_intr>:
/* the global IDT list
   in Nanos, each entry of the IDT is either an interrupt gate, or a trap gate */
struct GateDescriptor idt[NR_IRQ];

/* setup a interrupt gate for interrupt handlers */
void set_intr(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
c0100b4e:	55                   	push   %ebp
c0100b4f:	89 e5                	mov    %esp,%ebp
	ptr->offset_15_0 = offset & 0xFFFF;
c0100b51:	8b 45 10             	mov    0x10(%ebp),%eax
c0100b54:	89 c2                	mov    %eax,%edx
c0100b56:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b59:	66 89 10             	mov    %dx,(%eax)
	ptr->segment = selector;
c0100b5c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100b5f:	89 c2                	mov    %eax,%edx
c0100b61:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b64:	66 89 50 02          	mov    %dx,0x2(%eax)
	ptr->pad0 = 0;
c0100b68:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b6b:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	ptr->type = INTERRUPT_GATE_32;
c0100b6f:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b72:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c0100b76:	83 e2 f0             	and    $0xfffffff0,%edx
c0100b79:	83 ca 0e             	or     $0xe,%edx
c0100b7c:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->system = FALSE;
c0100b7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b82:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c0100b86:	83 e2 ef             	and    $0xffffffef,%edx
c0100b89:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->privilege_level = dpl;
c0100b8c:	8b 45 14             	mov    0x14(%ebp),%eax
c0100b8f:	89 c2                	mov    %eax,%edx
c0100b91:	83 e2 03             	and    $0x3,%edx
c0100b94:	8b 45 08             	mov    0x8(%ebp),%eax
c0100b97:	83 e2 03             	and    $0x3,%edx
c0100b9a:	89 d1                	mov    %edx,%ecx
c0100b9c:	c1 e1 05             	shl    $0x5,%ecx
c0100b9f:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c0100ba3:	83 e2 9f             	and    $0xffffff9f,%edx
c0100ba6:	09 ca                	or     %ecx,%edx
c0100ba8:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->present = TRUE;
c0100bab:	8b 45 08             	mov    0x8(%ebp),%eax
c0100bae:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c0100bb2:	83 ca 80             	or     $0xffffff80,%edx
c0100bb5:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100bb8:	8b 45 10             	mov    0x10(%ebp),%eax
c0100bbb:	c1 e8 10             	shr    $0x10,%eax
c0100bbe:	89 c2                	mov    %eax,%edx
c0100bc0:	8b 45 08             	mov    0x8(%ebp),%eax
c0100bc3:	66 89 50 06          	mov    %dx,0x6(%eax)
}
c0100bc7:	5d                   	pop    %ebp
c0100bc8:	c3                   	ret    

c0100bc9 <set_trap>:

/* setup a trap gate for cpu exceptions */
void set_trap(struct GateDescriptor *ptr, uint_32 selector, uint_32 offset, uint_32 dpl) {
c0100bc9:	55                   	push   %ebp
c0100bca:	89 e5                	mov    %esp,%ebp
	ptr->offset_15_0 = offset & 0xFFFF;
c0100bcc:	8b 45 10             	mov    0x10(%ebp),%eax
c0100bcf:	89 c2                	mov    %eax,%edx
c0100bd1:	8b 45 08             	mov    0x8(%ebp),%eax
c0100bd4:	66 89 10             	mov    %dx,(%eax)
	ptr->segment = selector;
c0100bd7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0100bda:	89 c2                	mov    %eax,%edx
c0100bdc:	8b 45 08             	mov    0x8(%ebp),%eax
c0100bdf:	66 89 50 02          	mov    %dx,0x2(%eax)
	ptr->pad0 = 0;
c0100be3:	8b 45 08             	mov    0x8(%ebp),%eax
c0100be6:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	ptr->type = TRAP_GATE_32;
c0100bea:	8b 45 08             	mov    0x8(%ebp),%eax
c0100bed:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c0100bf1:	83 ca 0f             	or     $0xf,%edx
c0100bf4:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->system = FALSE;
c0100bf7:	8b 45 08             	mov    0x8(%ebp),%eax
c0100bfa:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c0100bfe:	83 e2 ef             	and    $0xffffffef,%edx
c0100c01:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->privilege_level = dpl;
c0100c04:	8b 45 14             	mov    0x14(%ebp),%eax
c0100c07:	89 c2                	mov    %eax,%edx
c0100c09:	83 e2 03             	and    $0x3,%edx
c0100c0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0100c0f:	83 e2 03             	and    $0x3,%edx
c0100c12:	89 d1                	mov    %edx,%ecx
c0100c14:	c1 e1 05             	shl    $0x5,%ecx
c0100c17:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c0100c1b:	83 e2 9f             	and    $0xffffff9f,%edx
c0100c1e:	09 ca                	or     %ecx,%edx
c0100c20:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->present = TRUE;
c0100c23:	8b 45 08             	mov    0x8(%ebp),%eax
c0100c26:	0f b6 50 05          	movzbl 0x5(%eax),%edx
c0100c2a:	83 ca 80             	or     $0xffffff80,%edx
c0100c2d:	88 50 05             	mov    %dl,0x5(%eax)
	ptr->offset_31_16 = (offset >> 16) & 0xFFFF;
c0100c30:	8b 45 10             	mov    0x10(%ebp),%eax
c0100c33:	c1 e8 10             	shr    $0x10,%eax
c0100c36:	89 c2                	mov    %eax,%edx
c0100c38:	8b 45 08             	mov    0x8(%ebp),%eax
c0100c3b:	66 89 50 06          	mov    %dx,0x6(%eax)
}
c0100c3f:	5d                   	pop    %ebp
c0100c40:	c3                   	ret    

c0100c41 <init_idt>:
void vec14();
void vecsys();

void irq_empty();

void init_idt() {
c0100c41:	55                   	push   %ebp
c0100c42:	89 e5                	mov    %esp,%ebp
c0100c44:	83 ec 20             	sub    $0x20,%esp
	int i;
	for (i = 0; i < NR_IRQ; i ++) {
c0100c47:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0100c4e:	eb 31                	jmp    c0100c81 <init_idt+0x40>
		set_trap(idt + i, SEG_KERNEL_CODE << 3, (uint_32)irq_empty, DPL_KERNEL);
c0100c50:	b8 15 11 10 c0       	mov    $0xc0101115,%eax
c0100c55:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0100c58:	c1 e2 03             	shl    $0x3,%edx
c0100c5b:	81 c2 00 90 13 c0    	add    $0xc0139000,%edx
c0100c61:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100c68:	00 
c0100c69:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100c6d:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100c74:	00 
c0100c75:	89 14 24             	mov    %edx,(%esp)
c0100c78:	e8 4c ff ff ff       	call   c0100bc9 <set_trap>

void irq_empty();

void init_idt() {
	int i;
	for (i = 0; i < NR_IRQ; i ++) {
c0100c7d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0100c81:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0100c88:	7e c6                	jle    c0100c50 <init_idt+0xf>
		set_trap(idt + i, SEG_KERNEL_CODE << 3, (uint_32)irq_empty, DPL_KERNEL);
	}
	set_trap(idt + 0, SEG_KERNEL_CODE << 3, (uint_32)vec0, DPL_KERNEL);
c0100c8a:	b8 84 10 10 c0       	mov    $0xc0101084,%eax
c0100c8f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100c96:	00 
c0100c97:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100c9b:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100ca2:	00 
c0100ca3:	c7 04 24 00 90 13 c0 	movl   $0xc0139000,(%esp)
c0100caa:	e8 1a ff ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 1, SEG_KERNEL_CODE << 3, (uint_32)vec1, DPL_KERNEL);
c0100caf:	b8 8b 10 10 c0       	mov    $0xc010108b,%eax
c0100cb4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100cbb:	00 
c0100cbc:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100cc0:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100cc7:	00 
c0100cc8:	c7 04 24 08 90 13 c0 	movl   $0xc0139008,(%esp)
c0100ccf:	e8 f5 fe ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 2, SEG_KERNEL_CODE << 3, (uint_32)vec2, DPL_KERNEL);
c0100cd4:	b8 92 10 10 c0       	mov    $0xc0101092,%eax
c0100cd9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100ce0:	00 
c0100ce1:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100ce5:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100cec:	00 
c0100ced:	c7 04 24 10 90 13 c0 	movl   $0xc0139010,(%esp)
c0100cf4:	e8 d0 fe ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 3, SEG_KERNEL_CODE << 3, (uint_32)vec3, DPL_KERNEL);
c0100cf9:	b8 99 10 10 c0       	mov    $0xc0101099,%eax
c0100cfe:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100d05:	00 
c0100d06:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100d0a:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100d11:	00 
c0100d12:	c7 04 24 18 90 13 c0 	movl   $0xc0139018,(%esp)
c0100d19:	e8 ab fe ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 4, SEG_KERNEL_CODE << 3, (uint_32)vec4, DPL_KERNEL);
c0100d1e:	b8 a0 10 10 c0       	mov    $0xc01010a0,%eax
c0100d23:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100d2a:	00 
c0100d2b:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100d2f:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100d36:	00 
c0100d37:	c7 04 24 20 90 13 c0 	movl   $0xc0139020,(%esp)
c0100d3e:	e8 86 fe ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 5, SEG_KERNEL_CODE << 3, (uint_32)vec5, DPL_KERNEL);
c0100d43:	b8 a7 10 10 c0       	mov    $0xc01010a7,%eax
c0100d48:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100d4f:	00 
c0100d50:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100d54:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100d5b:	00 
c0100d5c:	c7 04 24 28 90 13 c0 	movl   $0xc0139028,(%esp)
c0100d63:	e8 61 fe ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 6, SEG_KERNEL_CODE << 3, (uint_32)vec6, DPL_KERNEL);
c0100d68:	b8 ae 10 10 c0       	mov    $0xc01010ae,%eax
c0100d6d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100d74:	00 
c0100d75:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100d79:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100d80:	00 
c0100d81:	c7 04 24 30 90 13 c0 	movl   $0xc0139030,(%esp)
c0100d88:	e8 3c fe ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 7, SEG_KERNEL_CODE << 3, (uint_32)vec7, DPL_KERNEL);
c0100d8d:	b8 b5 10 10 c0       	mov    $0xc01010b5,%eax
c0100d92:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100d99:	00 
c0100d9a:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100d9e:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100da5:	00 
c0100da6:	c7 04 24 38 90 13 c0 	movl   $0xc0139038,(%esp)
c0100dad:	e8 17 fe ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 8, SEG_KERNEL_CODE << 3, (uint_32)vec8, DPL_KERNEL);
c0100db2:	b8 bc 10 10 c0       	mov    $0xc01010bc,%eax
c0100db7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100dbe:	00 
c0100dbf:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100dc3:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100dca:	00 
c0100dcb:	c7 04 24 40 90 13 c0 	movl   $0xc0139040,(%esp)
c0100dd2:	e8 f2 fd ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 9, SEG_KERNEL_CODE << 3, (uint_32)vec9, DPL_KERNEL);
c0100dd7:	b8 c3 10 10 c0       	mov    $0xc01010c3,%eax
c0100ddc:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100de3:	00 
c0100de4:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100de8:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100def:	00 
c0100df0:	c7 04 24 48 90 13 c0 	movl   $0xc0139048,(%esp)
c0100df7:	e8 cd fd ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 10, SEG_KERNEL_CODE << 3, (uint_32)vec10, DPL_KERNEL);
c0100dfc:	b8 ca 10 10 c0       	mov    $0xc01010ca,%eax
c0100e01:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100e08:	00 
c0100e09:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100e0d:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100e14:	00 
c0100e15:	c7 04 24 50 90 13 c0 	movl   $0xc0139050,(%esp)
c0100e1c:	e8 a8 fd ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 11, SEG_KERNEL_CODE << 3, (uint_32)vec11, DPL_KERNEL);
c0100e21:	b8 d1 10 10 c0       	mov    $0xc01010d1,%eax
c0100e26:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100e2d:	00 
c0100e2e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100e32:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100e39:	00 
c0100e3a:	c7 04 24 58 90 13 c0 	movl   $0xc0139058,(%esp)
c0100e41:	e8 83 fd ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 12, SEG_KERNEL_CODE << 3, (uint_32)vec12, DPL_KERNEL);
c0100e46:	b8 d8 10 10 c0       	mov    $0xc01010d8,%eax
c0100e4b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100e52:	00 
c0100e53:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100e57:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100e5e:	00 
c0100e5f:	c7 04 24 60 90 13 c0 	movl   $0xc0139060,(%esp)
c0100e66:	e8 5e fd ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 13, SEG_KERNEL_CODE << 3, (uint_32)vec13, DPL_KERNEL);
c0100e6b:	b8 df 10 10 c0       	mov    $0xc01010df,%eax
c0100e70:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100e77:	00 
c0100e78:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100e7c:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100e83:	00 
c0100e84:	c7 04 24 68 90 13 c0 	movl   $0xc0139068,(%esp)
c0100e8b:	e8 39 fd ff ff       	call   c0100bc9 <set_trap>
	set_trap(idt + 14, SEG_KERNEL_CODE << 3, (uint_32)vec14, DPL_KERNEL);
c0100e90:	b8 e6 10 10 c0       	mov    $0xc01010e6,%eax
c0100e95:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100e9c:	00 
c0100e9d:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100ea1:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100ea8:	00 
c0100ea9:	c7 04 24 70 90 13 c0 	movl   $0xc0139070,(%esp)
c0100eb0:	e8 14 fd ff ff       	call   c0100bc9 <set_trap>

	/* the system call 0x80 */
	set_trap(idt + 0x80, SEG_KERNEL_CODE << 3, (uint_32)vecsys, DPL_KERNEL);
c0100eb5:	b8 ed 10 10 c0       	mov    $0xc01010ed,%eax
c0100eba:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100ec1:	00 
c0100ec2:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100ec6:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100ecd:	00 
c0100ece:	c7 04 24 00 94 13 c0 	movl   $0xc0139400,(%esp)
c0100ed5:	e8 ef fc ff ff       	call   c0100bc9 <set_trap>

	set_intr(idt+32 + 0, SEG_KERNEL_CODE << 3, (uint_32)irq0, DPL_KERNEL);
c0100eda:	b8 f7 10 10 c0       	mov    $0xc01010f7,%eax
c0100edf:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100ee6:	00 
c0100ee7:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100eeb:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100ef2:	00 
c0100ef3:	c7 04 24 00 91 13 c0 	movl   $0xc0139100,(%esp)
c0100efa:	e8 4f fc ff ff       	call   c0100b4e <set_intr>
	set_intr(idt+32 + 1, SEG_KERNEL_CODE << 3, (uint_32)irq1, DPL_KERNEL);
c0100eff:	b8 01 11 10 c0       	mov    $0xc0101101,%eax
c0100f04:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100f0b:	00 
c0100f0c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100f10:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100f17:	00 
c0100f18:	c7 04 24 08 91 13 c0 	movl   $0xc0139108,(%esp)
c0100f1f:	e8 2a fc ff ff       	call   c0100b4e <set_intr>
	set_intr(idt+32 + 14, SEG_KERNEL_CODE << 3, (uint_32)irq14, DPL_KERNEL);
c0100f24:	b8 0b 11 10 c0       	mov    $0xc010110b,%eax
c0100f29:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0100f30:	00 
c0100f31:	89 44 24 08          	mov    %eax,0x8(%esp)
c0100f35:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
c0100f3c:	00 
c0100f3d:	c7 04 24 70 91 13 c0 	movl   $0xc0139170,(%esp)
c0100f44:	e8 05 fc ff ff       	call   c0100b4e <set_intr>

	/* the ``idt'' is its virtual address */
	save_idt(idt, sizeof(idt));
c0100f49:	c7 44 24 04 00 08 00 	movl   $0x800,0x4(%esp)
c0100f50:	00 
c0100f51:	c7 04 24 00 90 13 c0 	movl   $0xc0139000,(%esp)
c0100f58:	e8 c3 fb ff ff       	call   c0100b20 <save_idt>
}
c0100f5d:	c9                   	leave  
c0100f5e:	c3                   	ret    
c0100f5f:	90                   	nop

c0100f60 <add_irq_handle>:
static struct IRQ_t handle_pool[NR_IRQ_HANDLE];
static struct IRQ_t *handles[NR_IRQ];
static int handle_count = 0;

void
add_irq_handle( int irq, void (*func)(void) ) {
c0100f60:	55                   	push   %ebp
c0100f61:	89 e5                	mov    %esp,%ebp
c0100f63:	83 ec 28             	sub    $0x28,%esp
	struct IRQ_t *ptr;
	if (handle_count > NR_IRQ_HANDLE) {
c0100f66:	a1 40 65 10 c0       	mov    0xc0106540,%eax
c0100f6b:	83 f8 20             	cmp    $0x20,%eax
c0100f6e:	7e 0c                	jle    c0100f7c <add_irq_handle+0x1c>
		panic("Too many irq registrations!");
c0100f70:	c7 04 24 e2 3e 10 c0 	movl   $0xc0103ee2,(%esp)
c0100f77:	e8 98 f4 ff ff       	call   c0100414 <panic>
	}
	ptr = &handle_pool[handle_count ++]; /* get a free handler */
c0100f7c:	a1 40 65 10 c0       	mov    0xc0106540,%eax
c0100f81:	89 c2                	mov    %eax,%edx
c0100f83:	c1 e2 03             	shl    $0x3,%edx
c0100f86:	81 c2 40 60 10 c0    	add    $0xc0106040,%edx
c0100f8c:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0100f8f:	83 c0 01             	add    $0x1,%eax
c0100f92:	a3 40 65 10 c0       	mov    %eax,0xc0106540
	ptr->routine = func;
c0100f97:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100f9a:	8b 55 0c             	mov    0xc(%ebp),%edx
c0100f9d:	89 10                	mov    %edx,(%eax)
	ptr->next = handles[irq]; /* insert into the linked list */
c0100f9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0100fa2:	8b 14 85 40 61 10 c0 	mov    -0x3fef9ec0(,%eax,4),%edx
c0100fa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0100fac:	89 50 04             	mov    %edx,0x4(%eax)
	handles[irq] = ptr;
c0100faf:	8b 45 08             	mov    0x8(%ebp),%eax
c0100fb2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0100fb5:	89 14 85 40 61 10 c0 	mov    %edx,-0x3fef9ec0(,%eax,4)
}
c0100fbc:	c9                   	leave  
c0100fbd:	c3                   	ret    

c0100fbe <irq_handle>:

//void schedule();

void irq_handle(struct TrapFrame *tf) {
c0100fbe:	55                   	push   %ebp
c0100fbf:	89 e5                	mov    %esp,%ebp
c0100fc1:	83 ec 28             	sub    $0x28,%esp
//	asm volatile("cli");
//	printk("*********************************** %d\n", global_lock_counter);
//	lock();
	int irq = tf -> irq;
c0100fc4:	8b 45 08             	mov    0x8(%ebp),%eax
c0100fc7:	8b 40 20             	mov    0x20(%eax),%eax
c0100fca:	89 45 f0             	mov    %eax,-0x10(%ebp)
//	printk("***************** %d\n", enter_interrupt);

//	enter_interrupt = TRUE;	

	current_pcb -> esp = tf;
c0100fcd:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0100fd2:	8b 55 08             	mov    0x8(%ebp),%edx
c0100fd5:	89 10                	mov    %edx,(%eax)

	if (irq < 0) {
c0100fd7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0100fdb:	79 0c                	jns    c0100fe9 <irq_handle+0x2b>
		panic("Unhandled exception!");
c0100fdd:	c7 04 24 fe 3e 10 c0 	movl   $0xc0103efe,(%esp)
c0100fe4:	e8 2b f4 ff ff       	call   c0100414 <panic>
	}

	if (irq < 1000) {
c0100fe9:	81 7d f0 e7 03 00 00 	cmpl   $0x3e7,-0x10(%ebp)
c0100ff0:	7f 15                	jg     c0101007 <irq_handle+0x49>
		panic("Unexpected exception #%d\n", irq);
c0100ff2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0100ff5:	89 44 24 04          	mov    %eax,0x4(%esp)
c0100ff9:	c7 04 24 13 3f 10 c0 	movl   $0xc0103f13,(%esp)
c0101000:	e8 0f f4 ff ff       	call   c0100414 <panic>
c0101005:	eb 39                	jmp    c0101040 <irq_handle+0x82>
	} else if (irq >= 1000) {
c0101007:	81 7d f0 e7 03 00 00 	cmpl   $0x3e7,-0x10(%ebp)
c010100e:	7e 30                	jle    c0101040 <irq_handle+0x82>
		int irq_id = irq - 1000;
c0101010:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101013:	2d e8 03 00 00       	sub    $0x3e8,%eax
c0101018:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct IRQ_t *f = handles[irq_id];
c010101b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010101e:	8b 04 85 40 61 10 c0 	mov    -0x3fef9ec0(,%eax,4),%eax
c0101025:	89 45 f4             	mov    %eax,-0xc(%ebp)

		while (f != NULL) { /* call handlers one by one */
c0101028:	eb 10                	jmp    c010103a <irq_handle+0x7c>
			f->routine(); 
c010102a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010102d:	8b 00                	mov    (%eax),%eax
c010102f:	ff d0                	call   *%eax
			f = f->next;
c0101031:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101034:	8b 40 04             	mov    0x4(%eax),%eax
c0101037:	89 45 f4             	mov    %eax,-0xc(%ebp)
		panic("Unexpected exception #%d\n", irq);
	} else if (irq >= 1000) {
		int irq_id = irq - 1000;
		struct IRQ_t *f = handles[irq_id];

		while (f != NULL) { /* call handlers one by one */
c010103a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c010103e:	75 ea                	jne    c010102a <irq_handle+0x6c>
	//schedule();
	//unlock();
	//-- global_lock_counter;
//	enter_interrupt = FALSE;
	
}
c0101040:	c9                   	leave  
c0101041:	c3                   	ret    

c0101042 <int_handle>:

void int_handle(struct TrapFrame *tf) {
c0101042:	55                   	push   %ebp
c0101043:	89 e5                	mov    %esp,%ebp

	//printk("begin\n");	

	current_pcb -> esp = tf;
c0101045:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c010104a:	8b 55 08             	mov    0x8(%ebp),%edx
c010104d:	89 10                	mov    %edx,(%eax)

	need_sched = TRUE;	
c010104f:	c6 05 d8 53 10 c0 01 	movb   $0x1,0xc01053d8
	
	//printk("end\n");	
}
c0101056:	5d                   	pop    %ebp
c0101057:	c3                   	ret    

c0101058 <init_handle>:
	need_sched = TRUE;
}
*/


void init_handle() {
c0101058:	55                   	push   %ebp
c0101059:	89 e5                	mov    %esp,%ebp
c010105b:	83 ec 10             	sub    $0x10,%esp
	int i;
	for (i = 0; i < NR_IRQ; ++ i)
c010105e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0101065:	eb 12                	jmp    c0101079 <init_handle+0x21>
		handles[i] = NULL;
c0101067:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010106a:	c7 04 85 40 61 10 c0 	movl   $0x0,-0x3fef9ec0(,%eax,4)
c0101071:	00 00 00 00 
*/


void init_handle() {
	int i;
	for (i = 0; i < NR_IRQ; ++ i)
c0101075:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0101079:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0101080:	7e e5                	jle    c0101067 <init_handle+0xf>
		handles[i] = NULL;

//	add_irq_handle(0, set_need_sched);
}
c0101082:	c9                   	leave  
c0101083:	c3                   	ret    

c0101084 <vec0>:
c0101084:	6a 00                	push   $0x0
c0101086:	e9 91 00 00 00       	jmp    c010111c <asm_do_irq>

c010108b <vec1>:
c010108b:	6a 01                	push   $0x1
c010108d:	e9 8a 00 00 00       	jmp    c010111c <asm_do_irq>

c0101092 <vec2>:
c0101092:	6a 02                	push   $0x2
c0101094:	e9 83 00 00 00       	jmp    c010111c <asm_do_irq>

c0101099 <vec3>:
c0101099:	6a 03                	push   $0x3
c010109b:	e9 7c 00 00 00       	jmp    c010111c <asm_do_irq>

c01010a0 <vec4>:
c01010a0:	6a 04                	push   $0x4
c01010a2:	e9 75 00 00 00       	jmp    c010111c <asm_do_irq>

c01010a7 <vec5>:
c01010a7:	6a 05                	push   $0x5
c01010a9:	e9 6e 00 00 00       	jmp    c010111c <asm_do_irq>

c01010ae <vec6>:
c01010ae:	6a 06                	push   $0x6
c01010b0:	e9 67 00 00 00       	jmp    c010111c <asm_do_irq>

c01010b5 <vec7>:
c01010b5:	6a 07                	push   $0x7
c01010b7:	e9 60 00 00 00       	jmp    c010111c <asm_do_irq>

c01010bc <vec8>:
c01010bc:	6a 08                	push   $0x8
c01010be:	e9 59 00 00 00       	jmp    c010111c <asm_do_irq>

c01010c3 <vec9>:
c01010c3:	6a 09                	push   $0x9
c01010c5:	e9 52 00 00 00       	jmp    c010111c <asm_do_irq>

c01010ca <vec10>:
c01010ca:	6a 0a                	push   $0xa
c01010cc:	e9 4b 00 00 00       	jmp    c010111c <asm_do_irq>

c01010d1 <vec11>:
c01010d1:	6a 0b                	push   $0xb
c01010d3:	e9 44 00 00 00       	jmp    c010111c <asm_do_irq>

c01010d8 <vec12>:
c01010d8:	6a 0c                	push   $0xc
c01010da:	e9 3d 00 00 00       	jmp    c010111c <asm_do_irq>

c01010df <vec13>:
c01010df:	6a 0d                	push   $0xd
c01010e1:	e9 36 00 00 00       	jmp    c010111c <asm_do_irq>

c01010e6 <vec14>:
c01010e6:	6a 0e                	push   $0xe
c01010e8:	e9 2f 00 00 00       	jmp    c010111c <asm_do_irq>

c01010ed <vecsys>:
c01010ed:	68 80 00 00 00       	push   $0x80
c01010f2:	e9 6b 00 00 00       	jmp    c0101162 <asm_do_int>

c01010f7 <irq0>:
c01010f7:	68 e8 03 00 00       	push   $0x3e8
c01010fc:	e9 1b 00 00 00       	jmp    c010111c <asm_do_irq>

c0101101 <irq1>:
c0101101:	68 e9 03 00 00       	push   $0x3e9
c0101106:	e9 11 00 00 00       	jmp    c010111c <asm_do_irq>

c010110b <irq14>:
c010110b:	68 f6 03 00 00       	push   $0x3f6
c0101110:	e9 07 00 00 00       	jmp    c010111c <asm_do_irq>

c0101115 <irq_empty>:
c0101115:	6a ff                	push   $0xffffffff
c0101117:	e9 00 00 00 00       	jmp    c010111c <asm_do_irq>

c010111c <asm_do_irq>:
c010111c:	c7 05 48 65 10 c0 01 	movl   $0x1,0xc0106548
c0101123:	00 00 00 
c0101126:	60                   	pusha  
c0101127:	89 e3                	mov    %esp,%ebx
c0101129:	81 fc 00 00 00 c0    	cmp    $0xc0000000,%esp
c010112f:	73 08                	jae    c0101139 <irq_in_kernel>
c0101131:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101136:	8b 60 04             	mov    0x4(%eax),%esp

c0101139 <irq_in_kernel>:
c0101139:	53                   	push   %ebx
c010113a:	e8 7f fe ff ff       	call   c0100fbe <irq_handle>
c010113f:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101144:	89 20                	mov    %esp,(%eax)
c0101146:	e8 19 06 00 00       	call   c0101764 <schedule>
c010114b:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101150:	8b 20                	mov    (%eax),%esp
c0101152:	5c                   	pop    %esp
c0101153:	61                   	popa   
c0101154:	83 c4 04             	add    $0x4,%esp
c0101157:	c7 05 48 65 10 c0 00 	movl   $0x0,0xc0106548
c010115e:	00 00 00 
c0101161:	cf                   	iret   

c0101162 <asm_do_int>:
c0101162:	60                   	pusha  
c0101163:	89 e3                	mov    %esp,%ebx
c0101165:	81 fc 00 00 00 c0    	cmp    $0xc0000000,%esp
c010116b:	73 08                	jae    c0101175 <int_in_kernel>
c010116d:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101172:	8b 60 04             	mov    0x4(%eax),%esp

c0101175 <int_in_kernel>:
c0101175:	53                   	push   %ebx
c0101176:	e8 c7 fe ff ff       	call   c0101042 <int_handle>
c010117b:	fa                   	cli    
c010117c:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101181:	89 20                	mov    %esp,(%eax)
c0101183:	e8 dc 05 00 00       	call   c0101764 <schedule>
c0101188:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c010118d:	8b 20                	mov    (%eax),%esp
c010118f:	5c                   	pop    %esp
c0101190:	61                   	popa   
c0101191:	83 c4 04             	add    $0x4,%esp
c0101194:	cf                   	iret   
c0101195:	90                   	nop
c0101196:	90                   	nop
c0101197:	90                   	nop

c0101198 <Find_Empty_PCB>:
};
*/



int Find_Empty_PCB() {
c0101198:	55                   	push   %ebp
c0101199:	89 e5                	mov    %esp,%ebp
c010119b:	83 ec 10             	sub    $0x10,%esp
	int i;
	for (i = 1; i < MAX_PROC; ++ i)
c010119e:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
c01011a5:	eb 23                	jmp    c01011ca <Find_Empty_PCB+0x32>
		if (Proc[i].flag == TRUE) return i;
c01011a7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c01011aa:	89 d0                	mov    %edx,%eax
c01011ac:	c1 e0 02             	shl    $0x2,%eax
c01011af:	01 d0                	add    %edx,%eax
c01011b1:	c1 e0 0c             	shl    $0xc,%eax
c01011b4:	05 10 c0 13 c0       	add    $0xc013c010,%eax
c01011b9:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c01011bd:	3c 01                	cmp    $0x1,%al
c01011bf:	75 05                	jne    c01011c6 <Find_Empty_PCB+0x2e>
c01011c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01011c4:	eb 0f                	jmp    c01011d5 <Find_Empty_PCB+0x3d>



int Find_Empty_PCB() {
	int i;
	for (i = 1; i < MAX_PROC; ++ i)
c01011c6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01011ca:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%ebp)
c01011ce:	7e d7                	jle    c01011a7 <Find_Empty_PCB+0xf>
		if (Proc[i].flag == TRUE) return i;
	return PROC_FULL;
c01011d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
c01011d5:	c9                   	leave  
c01011d6:	c3                   	ret    

c01011d7 <fetch_pcb>:



struct PCB* fetch_pcb(pid_t pid) {
c01011d7:	55                   	push   %ebp
c01011d8:	89 e5                	mov    %esp,%ebp
	return (Proc + pid);
c01011da:	8b 55 08             	mov    0x8(%ebp),%edx
c01011dd:	89 d0                	mov    %edx,%eax
c01011df:	c1 e0 02             	shl    $0x2,%eax
c01011e2:	01 d0                	add    %edx,%eax
c01011e4:	c1 e0 0c             	shl    $0xc,%eax
c01011e7:	05 00 a0 13 c0       	add    $0xc013a000,%eax
}
c01011ec:	5d                   	pop    %ebp
c01011ed:	c3                   	ret    

c01011ee <copy_from_kernel>:


void copy_from_kernel(struct PCB *pcb, void *dest, void *src, int length) {
c01011ee:	55                   	push   %ebp
c01011ef:	89 e5                	mov    %esp,%ebp
c01011f1:	83 ec 20             	sub    $0x20,%esp
	uint_32 pde = ((uint_32)dest) >> 22;
c01011f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c01011f7:	c1 e8 16             	shr    $0x16,%eax
c01011fa:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint_32 pte = (((uint_32)dest) >> 12) & 0x3FF;
c01011fd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0101200:	c1 e8 0c             	shr    $0xc,%eax
c0101203:	25 ff 03 00 00       	and    $0x3ff,%eax
c0101208:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint_32 pa = ((uint_32)dest) & 0xFFF;
c010120b:	8b 45 0c             	mov    0xc(%ebp),%eax
c010120e:	25 ff 0f 00 00       	and    $0xfff,%eax
c0101213:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent;

	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
c0101216:	8b 45 08             	mov    0x8(%ebp),%eax
c0101219:	8b 40 08             	mov    0x8(%eax),%eax
c010121c:	c1 e8 0c             	shr    $0xc,%eax
c010121f:	c1 e0 0c             	shl    $0xc,%eax
c0101222:	89 45 ec             	mov    %eax,-0x14(%ebp)
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c0101225:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0101228:	c1 e0 02             	shl    $0x2,%eax
c010122b:	03 45 ec             	add    -0x14(%ebp),%eax
c010122e:	8b 00                	mov    (%eax),%eax
c0101230:	c1 e8 0c             	shr    $0xc,%eax
c0101233:	c1 e0 0c             	shl    $0xc,%eax
c0101236:	89 45 f0             	mov    %eax,-0x10(%ebp)

	while (length != 0)
c0101239:	eb 77                	jmp    c01012b2 <copy_from_kernel+0xc4>
	{
		ptr = (void *)(((pent + pte) -> page_frame) << 12);
c010123b:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010123e:	c1 e0 02             	shl    $0x2,%eax
c0101241:	03 45 f0             	add    -0x10(%ebp),%eax
c0101244:	8b 00                	mov    (%eax),%eax
c0101246:	c1 e8 0c             	shr    $0xc,%eax
c0101249:	c1 e0 0c             	shl    $0xc,%eax
c010124c:	89 45 e8             	mov    %eax,-0x18(%ebp)

		while (pa < PAGE_SIZE)
c010124f:	eb 22                	jmp    c0101273 <copy_from_kernel+0x85>
		{
			*((uint_8 *)ptr + (pa ++)) = *(uint_8 *)(src ++);
c0101251:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101254:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0101257:	01 c2                	add    %eax,%edx
c0101259:	8b 45 10             	mov    0x10(%ebp),%eax
c010125c:	0f b6 00             	movzbl (%eax),%eax
c010125f:	88 02                	mov    %al,(%edx)
c0101261:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0101265:	83 45 10 01          	addl   $0x1,0x10(%ebp)
			-- length;
c0101269:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
			if (length == 0) break;
c010126d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0101271:	74 0b                	je     c010127e <copy_from_kernel+0x90>

	while (length != 0)
	{
		ptr = (void *)(((pent + pte) -> page_frame) << 12);

		while (pa < PAGE_SIZE)
c0101273:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%ebp)
c010127a:	76 d5                	jbe    c0101251 <copy_from_kernel+0x63>
c010127c:	eb 01                	jmp    c010127f <copy_from_kernel+0x91>
		{
			*((uint_8 *)ptr + (pa ++)) = *(uint_8 *)(src ++);
			-- length;
			if (length == 0) break;
c010127e:	90                   	nop
		}
		pa = 0;
c010127f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		++ pte;
c0101286:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
		if (pte == NR_PTE_ENTRY)
c010128a:	81 7d f8 00 04 00 00 	cmpl   $0x400,-0x8(%ebp)
c0101291:	75 1f                	jne    c01012b2 <copy_from_kernel+0xc4>
		{
			pte = 0;
c0101293:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
			++ pde;
c010129a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c010129e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01012a1:	c1 e0 02             	shl    $0x2,%eax
c01012a4:	03 45 ec             	add    -0x14(%ebp),%eax
c01012a7:	8b 00                	mov    (%eax),%eax
c01012a9:	c1 e8 0c             	shr    $0xc,%eax
c01012ac:	c1 e0 0c             	shl    $0xc,%eax
c01012af:	89 45 f0             	mov    %eax,-0x10(%ebp)
	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);

	while (length != 0)
c01012b2:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c01012b6:	75 83                	jne    c010123b <copy_from_kernel+0x4d>
			++ pde;
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
		}

	}
}
c01012b8:	c9                   	leave  
c01012b9:	c3                   	ret    

c01012ba <copy_to_kernel>:

void copy_to_kernel(struct PCB *pcb, void *dest, void *src, int length) {
c01012ba:	55                   	push   %ebp
c01012bb:	89 e5                	mov    %esp,%ebp
c01012bd:	83 ec 20             	sub    $0x20,%esp
	uint_32 pde = ((uint_32)src) >> 22;
c01012c0:	8b 45 10             	mov    0x10(%ebp),%eax
c01012c3:	c1 e8 16             	shr    $0x16,%eax
c01012c6:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint_32 pte = (((uint_32)src) >> 12) & 0x3FF;
c01012c9:	8b 45 10             	mov    0x10(%ebp),%eax
c01012cc:	c1 e8 0c             	shr    $0xc,%eax
c01012cf:	25 ff 03 00 00       	and    $0x3ff,%eax
c01012d4:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint_32 pa = ((uint_32)src) & 0xFFF;
c01012d7:	8b 45 10             	mov    0x10(%ebp),%eax
c01012da:	25 ff 0f 00 00       	and    $0xfff,%eax
c01012df:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent;

	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
c01012e2:	8b 45 08             	mov    0x8(%ebp),%eax
c01012e5:	8b 40 08             	mov    0x8(%eax),%eax
c01012e8:	c1 e8 0c             	shr    $0xc,%eax
c01012eb:	c1 e0 0c             	shl    $0xc,%eax
c01012ee:	89 45 ec             	mov    %eax,-0x14(%ebp)
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c01012f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01012f4:	c1 e0 02             	shl    $0x2,%eax
c01012f7:	03 45 ec             	add    -0x14(%ebp),%eax
c01012fa:	8b 00                	mov    (%eax),%eax
c01012fc:	c1 e8 0c             	shr    $0xc,%eax
c01012ff:	c1 e0 0c             	shl    $0xc,%eax
c0101302:	89 45 f0             	mov    %eax,-0x10(%ebp)

	while (length != 0)
c0101305:	eb 77                	jmp    c010137e <copy_to_kernel+0xc4>
	{
		ptr = (void *)(((pent + pte) -> page_frame) << 12);
c0101307:	8b 45 f8             	mov    -0x8(%ebp),%eax
c010130a:	c1 e0 02             	shl    $0x2,%eax
c010130d:	03 45 f0             	add    -0x10(%ebp),%eax
c0101310:	8b 00                	mov    (%eax),%eax
c0101312:	c1 e8 0c             	shr    $0xc,%eax
c0101315:	c1 e0 0c             	shl    $0xc,%eax
c0101318:	89 45 e8             	mov    %eax,-0x18(%ebp)

		while (pa < PAGE_SIZE)
c010131b:	eb 22                	jmp    c010133f <copy_to_kernel+0x85>
		{
			*(uint_8 *)(dest ++) = *((uint_8 *)ptr + (pa ++));
c010131d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101320:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0101323:	01 d0                	add    %edx,%eax
c0101325:	0f b6 10             	movzbl (%eax),%edx
c0101328:	8b 45 0c             	mov    0xc(%ebp),%eax
c010132b:	88 10                	mov    %dl,(%eax)
c010132d:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c0101331:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
			-- length;
c0101335:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
			if (length == 0) break;
c0101339:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c010133d:	74 0b                	je     c010134a <copy_to_kernel+0x90>

	while (length != 0)
	{
		ptr = (void *)(((pent + pte) -> page_frame) << 12);

		while (pa < PAGE_SIZE)
c010133f:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%ebp)
c0101346:	76 d5                	jbe    c010131d <copy_to_kernel+0x63>
c0101348:	eb 01                	jmp    c010134b <copy_to_kernel+0x91>
		{
			*(uint_8 *)(dest ++) = *((uint_8 *)ptr + (pa ++));
			-- length;
			if (length == 0) break;
c010134a:	90                   	nop
		}
		pa = 0;
c010134b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		++ pte;
c0101352:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
		if (pte == NR_PTE_ENTRY)
c0101356:	81 7d f8 00 04 00 00 	cmpl   $0x400,-0x8(%ebp)
c010135d:	75 1f                	jne    c010137e <copy_to_kernel+0xc4>
		{
			pte = 0;
c010135f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
			++ pde;
c0101366:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c010136a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010136d:	c1 e0 02             	shl    $0x2,%eax
c0101370:	03 45 ec             	add    -0x14(%ebp),%eax
c0101373:	8b 00                	mov    (%eax),%eax
c0101375:	c1 e8 0c             	shr    $0xc,%eax
c0101378:	c1 e0 0c             	shl    $0xc,%eax
c010137b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	void				*ptr;

	pdir = (struct PageDirectoryEntry *)((pcb -> cr3).page_directory_base << 12);
	pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);

	while (length != 0)
c010137e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0101382:	75 83                	jne    c0101307 <copy_to_kernel+0x4d>
			++ pde;
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
		}

	}
}
c0101384:	c9                   	leave  
c0101385:	c3                   	ret    

c0101386 <init_message_pool>:

struct PCB *init;

//struct PCB *preempt_proc = NULL;

void init_message_pool(struct PCB *ptr) {
c0101386:	55                   	push   %ebp
c0101387:	89 e5                	mov    %esp,%ebp
c0101389:	83 ec 28             	sub    $0x28,%esp

	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
c010138c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0101393:	eb 1f                	jmp    c01013b4 <init_message_pool+0x2e>
		(ptr -> Msg_rec_Pool[i]).flag = TRUE;
c0101395:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0101398:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010139b:	89 d0                	mov    %edx,%eax
c010139d:	c1 e0 02             	shl    $0x2,%eax
c01013a0:	01 d0                	add    %edx,%eax
c01013a2:	c1 e0 03             	shl    $0x3,%eax
c01013a5:	01 c8                	add    %ecx,%eax
c01013a7:	05 10 21 00 00       	add    $0x2110,%eax
c01013ac:	c6 40 04 01          	movb   $0x1,0x4(%eax)
//struct PCB *preempt_proc = NULL;

void init_message_pool(struct PCB *ptr) {

	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
c01013b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01013b4:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
c01013b8:	7e db                	jle    c0101395 <init_message_pool+0xf>
		(ptr -> Msg_rec_Pool[i]).flag = TRUE;
	ptr -> Msg_rec = NULL;
c01013ba:	8b 45 08             	mov    0x8(%ebp),%eax
c01013bd:	c7 80 f0 34 00 00 00 	movl   $0x0,0x34f0(%eax)
c01013c4:	00 00 00 
	ptr -> Msg_ign = NULL;
c01013c7:	8b 45 08             	mov    0x8(%ebp),%eax
c01013ca:	c7 80 f4 34 00 00 00 	movl   $0x0,0x34f4(%eax)
c01013d1:	00 00 00 
	Sem_init(&(ptr -> Msg_lock), 0);
c01013d4:	8b 45 08             	mov    0x8(%ebp),%eax
c01013d7:	05 20 20 00 00       	add    $0x2020,%eax
c01013dc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c01013e3:	00 
c01013e4:	89 04 24             	mov    %eax,(%esp)
c01013e7:	e8 ac 05 00 00       	call   c0101998 <Sem_init>
}
c01013ec:	c9                   	leave  
c01013ed:	c3                   	ret    

c01013ee <Push_Stack_4Byte>:


void Push_Stack_4Byte(uint_8 **Addr, uint_32 Key) {
c01013ee:	55                   	push   %ebp
c01013ef:	89 e5                	mov    %esp,%ebp
	*((uint_32 *)(*Addr)) = Key;	
c01013f1:	8b 45 08             	mov    0x8(%ebp),%eax
c01013f4:	8b 00                	mov    (%eax),%eax
c01013f6:	8b 55 0c             	mov    0xc(%ebp),%edx
c01013f9:	89 10                	mov    %edx,(%eax)
	*Addr -= 4;
c01013fb:	8b 45 08             	mov    0x8(%ebp),%eax
c01013fe:	8b 00                	mov    (%eax),%eax
c0101400:	8d 50 fc             	lea    -0x4(%eax),%edx
c0101403:	8b 45 08             	mov    0x8(%ebp),%eax
c0101406:	89 10                	mov    %edx,(%eax)
}
c0101408:	5d                   	pop    %ebp
c0101409:	c3                   	ret    

c010140a <Create_kthread>:


void Create_kthread(void (*thread)(void)) {
c010140a:	55                   	push   %ebp
c010140b:	89 e5                	mov    %esp,%ebp
c010140d:	83 ec 38             	sub    $0x38,%esp
	int new = Find_Empty_PCB();
c0101410:	e8 83 fd ff ff       	call   c0101198 <Find_Empty_PCB>
c0101415:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (new == PROC_FULL)
c0101418:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c010141c:	75 0c                	jne    c010142a <Create_kthread+0x20>
		panic("Process Table is Full!\n");
c010141e:	c7 04 24 2d 3f 10 c0 	movl   $0xc0103f2d,(%esp)
c0101425:	e8 ea ef ff ff       	call   c0100414 <panic>

	struct PCB *new_pcb = Proc + new; 
c010142a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c010142d:	89 d0                	mov    %edx,%eax
c010142f:	c1 e0 02             	shl    $0x2,%eax
c0101432:	01 d0                	add    %edx,%eax
c0101434:	c1 e0 0c             	shl    $0xc,%eax
c0101437:	05 00 a0 13 c0       	add    $0xc013a000,%eax
c010143c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	new_pcb -> next = init;
c010143f:	8b 15 00 a0 1d c0    	mov    0xc01da000,%edx
c0101445:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101448:	89 90 0c 20 00 00    	mov    %edx,0x200c(%eax)
	new_pcb -> prev = init -> prev;
c010144e:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c0101453:	8b 90 10 20 00 00    	mov    0x2010(%eax),%edx
c0101459:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010145c:	89 90 10 20 00 00    	mov    %edx,0x2010(%eax)
	init -> prev -> next = new_pcb;
c0101462:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c0101467:	8b 80 10 20 00 00    	mov    0x2010(%eax),%eax
c010146d:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0101470:	89 90 0c 20 00 00    	mov    %edx,0x200c(%eax)
	init -> prev = new_pcb;
c0101476:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c010147b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c010147e:	89 90 10 20 00 00    	mov    %edx,0x2010(%eax)



	//Initialize

	new_pcb -> status = STATUS_WAITING;
c0101484:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101487:	c7 80 18 20 00 00 00 	movl   $0x0,0x2018(%eax)
c010148e:	00 00 00 
	new_pcb -> pid = new;
c0101491:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101494:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0101497:	89 90 1c 20 00 00    	mov    %edx,0x201c(%eax)
	new_pcb -> flag = FALSE;
c010149d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01014a0:	c6 80 14 20 00 00 00 	movb   $0x0,0x2014(%eax)

	new_pcb -> time_elapsed = 0;
c01014a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01014aa:	c7 80 f8 34 00 00 00 	movl   $0x0,0x34f8(%eax)
c01014b1:	00 00 00 


	*(uint_32 *)&(new_pcb -> cr3) = 0;
c01014b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01014b7:	83 c0 08             	add    $0x8,%eax
c01014ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(new_pcb -> cr3).page_directory_base = ((uint_32)va_to_pa(kpagedir)) >> 12;
c01014c0:	b8 00 80 13 c0       	mov    $0xc0138000,%eax
c01014c5:	05 00 00 00 40       	add    $0x40000000,%eax
c01014ca:	c1 e8 0c             	shr    $0xc,%eax
c01014cd:	89 c2                	mov    %eax,%edx
c01014cf:	81 e2 ff ff 0f 00    	and    $0xfffff,%edx
c01014d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01014d8:	89 d1                	mov    %edx,%ecx
c01014da:	c1 e1 0c             	shl    $0xc,%ecx
c01014dd:	8b 50 08             	mov    0x8(%eax),%edx
c01014e0:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c01014e6:	09 ca                	or     %ecx,%edx
c01014e8:	89 50 08             	mov    %edx,0x8(%eax)


	init_message_pool(new_pcb);
c01014eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01014ee:	89 04 24             	mov    %eax,(%esp)
c01014f1:	e8 90 fe ff ff       	call   c0101386 <init_message_pool>

	//printk("kernel stack : %x\n", new_pcb -> kstack);
	uint_8 *stack_ptr = (uint_8 *)((uint_32)(new_pcb -> kstack) + STACK_SIZE - 4);
c01014f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01014f9:	83 c0 0c             	add    $0xc,%eax
c01014fc:	05 fc 1f 00 00       	add    $0x1ffc,%eax
c0101501:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	

	uint_32 key;

	//eflags
	key = (1 << 9); 
c0101504:	c7 45 e8 00 02 00 00 	movl   $0x200,-0x18(%ebp)
	Push_Stack_4Byte(&stack_ptr, key);
c010150b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010150e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0101512:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0101515:	89 04 24             	mov    %eax,(%esp)
c0101518:	e8 d1 fe ff ff       	call   c01013ee <Push_Stack_4Byte>
	//printk("key = %d", key);
	//printk("stack pointer = %x\n", (uint_32)stack_ptr);
	//printk("eflags = %d\n", *((uint_32 *)(stack_ptr + 4)));
	
	//%cs
	key = 8;
c010151d:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%ebp)
	Push_Stack_4Byte(&stack_ptr, key);
c0101524:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0101527:	89 44 24 04          	mov    %eax,0x4(%esp)
c010152b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010152e:	89 04 24             	mov    %eax,(%esp)
c0101531:	e8 b8 fe ff ff       	call   c01013ee <Push_Stack_4Byte>
	
	//%eip
	key = (uint_32)thread;
c0101536:	8b 45 08             	mov    0x8(%ebp),%eax
c0101539:	89 45 e8             	mov    %eax,-0x18(%ebp)
	Push_Stack_4Byte(&stack_ptr, key);
c010153c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010153f:	89 44 24 04          	mov    %eax,0x4(%esp)
c0101543:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0101546:	89 04 24             	mov    %eax,(%esp)
c0101549:	e8 a0 fe ff ff       	call   c01013ee <Push_Stack_4Byte>
	
	//TrapFrame
	uint_32 i;
	key = 0;
c010154e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	for (i = 0; i < 9; ++ i)
c0101555:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010155c:	eb 16                	jmp    c0101574 <Create_kthread+0x16a>
		Push_Stack_4Byte(&stack_ptr, key);
c010155e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0101561:	89 44 24 04          	mov    %eax,0x4(%esp)
c0101565:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0101568:	89 04 24             	mov    %eax,(%esp)
c010156b:	e8 7e fe ff ff       	call   c01013ee <Push_Stack_4Byte>
	Push_Stack_4Byte(&stack_ptr, key);
	
	//TrapFrame
	uint_32 i;
	key = 0;
	for (i = 0; i < 9; ++ i)
c0101570:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0101574:	83 7d f4 08          	cmpl   $0x8,-0xc(%ebp)
c0101578:	76 e4                	jbe    c010155e <Create_kthread+0x154>
		Push_Stack_4Byte(&stack_ptr, key);

	//%esp & PCB -> esp
	new_pcb -> esp = (void *)((uint_32)stack_ptr);
c010157a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c010157d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101580:	89 10                	mov    %edx,(%eax)
	Push_Stack_4Byte(&stack_ptr, (uint_32)stack_ptr + 4);
c0101582:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0101585:	83 c0 04             	add    $0x4,%eax
c0101588:	89 44 24 04          	mov    %eax,0x4(%esp)
c010158c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c010158f:	89 04 24             	mov    %eax,(%esp)
c0101592:	e8 57 fe ff ff       	call   c01013ee <Push_Stack_4Byte>
	struct TrapFrame tf;
	uint_32 eip;
	uint_32 cs;
	struct EFLAGS eflags;
	*/
}
c0101597:	c9                   	leave  
c0101598:	c3                   	ret    

c0101599 <init_proc>:

struct PCB *current_pcb;

void init_proc() {
c0101599:	55                   	push   %ebp
c010159a:	89 e5                	mov    %esp,%ebp
c010159c:	83 ec 28             	sub    $0x28,%esp

	int i;

	init = Proc;			//Proc[0] --> init
c010159f:	c7 05 00 a0 1d c0 00 	movl   $0xc013a000,0xc01da000
c01015a6:	a0 13 c0 
	init -> next = init -> prev = init;
c01015a9:	8b 15 00 a0 1d c0    	mov    0xc01da000,%edx
c01015af:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c01015b4:	8b 0d 00 a0 1d c0    	mov    0xc01da000,%ecx
c01015ba:	89 88 10 20 00 00    	mov    %ecx,0x2010(%eax)
c01015c0:	8b 80 10 20 00 00    	mov    0x2010(%eax),%eax
c01015c6:	89 82 0c 20 00 00    	mov    %eax,0x200c(%edx)
	init -> flag = FALSE;
c01015cc:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c01015d1:	c6 80 14 20 00 00 00 	movb   $0x0,0x2014(%eax)
	init -> pid = 0;
c01015d8:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c01015dd:	c7 80 1c 20 00 00 00 	movl   $0x0,0x201c(%eax)
c01015e4:	00 00 00 
	init -> status = STATUS_WAITING;
c01015e7:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c01015ec:	c7 80 18 20 00 00 00 	movl   $0x0,0x2018(%eax)
c01015f3:	00 00 00 
	init -> time_elapsed = 0;
c01015f6:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c01015fb:	c7 80 f8 34 00 00 00 	movl   $0x0,0x34f8(%eax)
c0101602:	00 00 00 
	init_message_pool(init);
c0101605:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c010160a:	89 04 24             	mov    %eax,(%esp)
c010160d:	e8 74 fd ff ff       	call   c0101386 <init_message_pool>

	*(uint_32*)&(init -> cr3) = 0;
c0101612:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c0101617:	83 c0 08             	add    $0x8,%eax
c010161a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(init -> cr3).page_directory_base = ((uint_32)va_to_pa(kpagedir)) >> 12;
c0101620:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c0101625:	ba 00 80 13 c0       	mov    $0xc0138000,%edx
c010162a:	81 c2 00 00 00 40    	add    $0x40000000,%edx
c0101630:	c1 ea 0c             	shr    $0xc,%edx
c0101633:	81 e2 ff ff 0f 00    	and    $0xfffff,%edx
c0101639:	89 d1                	mov    %edx,%ecx
c010163b:	c1 e1 0c             	shl    $0xc,%ecx
c010163e:	8b 50 08             	mov    0x8(%eax),%edx
c0101641:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0101647:	09 ca                	or     %ecx,%edx
c0101649:	89 50 08             	mov    %edx,0x8(%eax)
	

	for (i = 1; i < MAX_PROC; ++ i)
c010164c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c0101653:	eb 1a                	jmp    c010166f <init_proc+0xd6>
		Proc[i].flag = 1;
c0101655:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101658:	89 d0                	mov    %edx,%eax
c010165a:	c1 e0 02             	shl    $0x2,%eax
c010165d:	01 d0                	add    %edx,%eax
c010165f:	c1 e0 0c             	shl    $0xc,%eax
c0101662:	05 10 c0 13 c0       	add    $0xc013c010,%eax
c0101667:	c6 40 04 01          	movb   $0x1,0x4(%eax)

	*(uint_32*)&(init -> cr3) = 0;
	(init -> cr3).page_directory_base = ((uint_32)va_to_pa(kpagedir)) >> 12;
	

	for (i = 1; i < MAX_PROC; ++ i)
c010166b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010166f:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c0101673:	7e e0                	jle    c0101655 <init_proc+0xbc>
		Proc[i].flag = 1;


	Create_kthread(timer_driver_thread);
c0101675:	c7 04 24 30 1e 10 c0 	movl   $0xc0101e30,(%esp)
c010167c:	e8 89 fd ff ff       	call   c010140a <Create_kthread>
	TIMER = 1;
c0101681:	c7 05 c0 b6 1d c0 01 	movl   $0x1,0xc01db6c0
c0101688:	00 00 00 
	Create_kthread(tty_driver_thread);
c010168b:	c7 04 24 4d 21 10 c0 	movl   $0xc010214d,(%esp)
c0101692:	e8 73 fd ff ff       	call   c010140a <Create_kthread>
	TTY = 2;
c0101697:	c7 05 c4 b6 1d c0 02 	movl   $0x2,0xc01db6c4
c010169e:	00 00 00 
	Create_kthread(ide_driver_thread);
c01016a1:	c7 04 24 35 2a 10 c0 	movl   $0xc0102a35,(%esp)
c01016a8:	e8 5d fd ff ff       	call   c010140a <Create_kthread>
	IDE = 3;
c01016ad:	c7 05 c8 b6 1d c0 03 	movl   $0x3,0xc01db6c8
c01016b4:	00 00 00 
	Create_kthread(FileManagement);
c01016b7:	c7 04 24 d8 2f 10 c0 	movl   $0xc0102fd8,(%esp)
c01016be:	e8 47 fd ff ff       	call   c010140a <Create_kthread>
	FM = 4;
c01016c3:	c7 05 cc b6 1d c0 04 	movl   $0x4,0xc01db6cc
c01016ca:	00 00 00 
	Create_kthread(MemoryManagement);
c01016cd:	c7 04 24 e8 30 10 c0 	movl   $0xc01030e8,(%esp)
c01016d4:	e8 31 fd ff ff       	call   c010140a <Create_kthread>
	MM = 5;
c01016d9:	c7 05 e0 b6 1d c0 05 	movl   $0x5,0xc01db6e0
c01016e0:	00 00 00 
	Create_kthread(ProcessManagement);
c01016e3:	c7 04 24 09 3b 10 c0 	movl   $0xc0103b09,(%esp)
c01016ea:	e8 1b fd ff ff       	call   c010140a <Create_kthread>
	PM = 6;
c01016ef:	c7 05 00 27 1e c0 06 	movl   $0x6,0xc01e2700
c01016f6:	00 00 00 

	Create_kthread(test_ide);
c01016f9:	c7 04 24 52 3e 10 c0 	movl   $0xc0103e52,(%esp)
c0101700:	e8 05 fd ff ff       	call   c010140a <Create_kthread>

	current_pcb = init;
c0101705:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c010170a:	a3 04 a0 1d c0       	mov    %eax,0xc01da004
}
c010170f:	c9                   	leave  
c0101710:	c3                   	ret    
c0101711:	90                   	nop
c0101712:	90                   	nop
c0101713:	90                   	nop

c0101714 <save_cr3>:
	asm volatile("movl %0, %%cr0" : : "r"(val));
}

/* write CR3, notice that CR3 are never read in Nanos */
static inline void
save_cr3(struct CR3 *ptr) {
c0101714:	55                   	push   %ebp
c0101715:	89 e5                	mov    %esp,%ebp
c0101717:	83 ec 10             	sub    $0x10,%esp
	uint_32 val = *((uint_32*)ptr);
c010171a:	8b 45 08             	mov    0x8(%ebp),%eax
c010171d:	8b 00                	mov    (%eax),%eax
c010171f:	89 45 fc             	mov    %eax,-0x4(%ebp)
	asm volatile("movl %0, %%cr3" : : "r"(val));
c0101722:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0101725:	0f 22 d8             	mov    %eax,%cr3
}
c0101728:	c9                   	leave  
c0101729:	c3                   	ret    

c010172a <find_next_live_process>:
   just need to set "need_sched" to be TRUE,
   schedule() will be called each time before interrupt return. */

boolean	need_sched = TRUE;

struct PCB* find_next_live_process(void) {
c010172a:	55                   	push   %ebp
c010172b:	89 e5                	mov    %esp,%ebp
c010172d:	83 ec 10             	sub    $0x10,%esp
	{
		p = preempt_proc;	
		preempt_proc = NULL;
	}
	else*/
	for (p = current_pcb -> next; p != NULL && p -> status != STATUS_WAITING; p = p -> next);
c0101730:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101735:	8b 80 0c 20 00 00    	mov    0x200c(%eax),%eax
c010173b:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010173e:	eb 0c                	jmp    c010174c <find_next_live_process+0x22>
c0101740:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0101743:	8b 80 0c 20 00 00    	mov    0x200c(%eax),%eax
c0101749:	89 45 fc             	mov    %eax,-0x4(%ebp)
c010174c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0101750:	74 0d                	je     c010175f <find_next_live_process+0x35>
c0101752:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0101755:	8b 80 18 20 00 00    	mov    0x2018(%eax),%eax
c010175b:	85 c0                	test   %eax,%eax
c010175d:	75 e1                	jne    c0101740 <find_next_live_process+0x16>
	return p;
c010175f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0101762:	c9                   	leave  
c0101763:	c3                   	ret    

c0101764 <schedule>:

void schedule(void) {
c0101764:	55                   	push   %ebp
c0101765:	89 e5                	mov    %esp,%ebp
c0101767:	83 ec 18             	sub    $0x18,%esp
	//lock();
	if (need_sched)
c010176a:	0f b6 05 d8 53 10 c0 	movzbl 0xc01053d8,%eax
c0101771:	84 c0                	test   %al,%al
c0101773:	0f 84 84 00 00 00    	je     c01017fd <schedule+0x99>
	{
		if (current_pcb -> status == STATUS_RUNNING)
c0101779:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c010177e:	8b 80 18 20 00 00    	mov    0x2018(%eax),%eax
c0101784:	83 f8 01             	cmp    $0x1,%eax
c0101787:	75 0f                	jne    c0101798 <schedule+0x34>
			current_pcb -> status = STATUS_WAITING;
c0101789:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c010178e:	c7 80 18 20 00 00 00 	movl   $0x0,0x2018(%eax)
c0101795:	00 00 00 
		current_pcb = find_next_live_process();
c0101798:	e8 8d ff ff ff       	call   c010172a <find_next_live_process>
c010179d:	a3 04 a0 1d c0       	mov    %eax,0xc01da004
	//	printk("%d\n", current_pcb -> pid);
		current_pcb -> status = STATUS_RUNNING;
c01017a2:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c01017a7:	c7 80 18 20 00 00 01 	movl   $0x1,0x2018(%eax)
c01017ae:	00 00 00 
		printk("Next PCB = %d\n", current_pcb -> pid);
c01017b1:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c01017b6:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c01017bc:	89 44 24 04          	mov    %eax,0x4(%esp)
c01017c0:	c7 04 24 45 3f 10 c0 	movl   $0xc0103f45,(%esp)
c01017c7:	e8 20 ec ff ff       	call   c01003ec <printk>
		printk("CR3 = %x\n", *((uint_32 *)(&(current_pcb -> cr3))));
c01017cc:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c01017d1:	83 c0 08             	add    $0x8,%eax
c01017d4:	8b 00                	mov    (%eax),%eax
c01017d6:	89 44 24 04          	mov    %eax,0x4(%esp)
c01017da:	c7 04 24 54 3f 10 c0 	movl   $0xc0103f54,(%esp)
c01017e1:	e8 06 ec ff ff       	call   c01003ec <printk>
		save_cr3(&(current_pcb -> cr3));
c01017e6:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c01017eb:	83 c0 08             	add    $0x8,%eax
c01017ee:	89 04 24             	mov    %eax,(%esp)
c01017f1:	e8 1e ff ff ff       	call   c0101714 <save_cr3>
		//asm volatile ("movl %0, %%cr3" : : "r"(*((uint_32 *)(&(current_pcb -> cr3)))));
		need_sched = FALSE;
c01017f6:	c6 05 d8 53 10 c0 00 	movb   $0x0,0xc01053d8
	}
	//unlock();
}
c01017fd:	c9                   	leave  
c01017fe:	c3                   	ret    
c01017ff:	90                   	nop

c0101800 <process_A>:
#include "kernel.h"

void process_A(void) {
c0101800:	55                   	push   %ebp
c0101801:	89 e5                	mov    %esp,%ebp
c0101803:	83 ec 18             	sub    $0x18,%esp
	while (1)
		printk("A");
c0101806:	c7 04 24 5e 3f 10 c0 	movl   $0xc0103f5e,(%esp)
c010180d:	e8 da eb ff ff       	call   c01003ec <printk>
c0101812:	eb f2                	jmp    c0101806 <process_A+0x6>

c0101814 <process_B>:
}


void process_B(void) {
c0101814:	55                   	push   %ebp
c0101815:	89 e5                	mov    %esp,%ebp
c0101817:	83 ec 18             	sub    $0x18,%esp
	while (1)
		printk("B");
c010181a:	c7 04 24 60 3f 10 c0 	movl   $0xc0103f60,(%esp)
c0101821:	e8 c6 eb ff ff       	call   c01003ec <printk>
c0101826:	eb f2                	jmp    c010181a <process_B+0x6>

c0101828 <process_C>:
}

void process_C(void) {
c0101828:	55                   	push   %ebp
c0101829:	89 e5                	mov    %esp,%ebp
c010182b:	83 ec 18             	sub    $0x18,%esp
	while (1)
		printk("C");
c010182e:	c7 04 24 62 3f 10 c0 	movl   $0xc0103f62,(%esp)
c0101835:	e8 b2 eb ff ff       	call   c01003ec <printk>
c010183a:	eb f2                	jmp    c010182e <process_C+0x6>

c010183c <init_producer_consumer>:
struct Sem_type empty;
struct Sem_type full;
struct Sem_type mutex;
int	PC_counter;

void init_producer_consumer(void) {
c010183c:	55                   	push   %ebp
c010183d:	89 e5                	mov    %esp,%ebp
c010183f:	83 ec 18             	sub    $0x18,%esp
	Sem_init(&empty, 20);
c0101842:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
c0101849:	00 
c010184a:	c7 04 24 e0 a1 1d c0 	movl   $0xc01da1e0,(%esp)
c0101851:	e8 42 01 00 00       	call   c0101998 <Sem_init>
	Sem_init(&full, 0);
c0101856:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c010185d:	00 
c010185e:	c7 04 24 20 a0 1d c0 	movl   $0xc01da020,(%esp)
c0101865:	e8 2e 01 00 00       	call   c0101998 <Sem_init>
	Sem_init(&mutex, 1);
c010186a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c0101871:	00 
c0101872:	c7 04 24 00 a1 1d c0 	movl   $0xc01da100,(%esp)
c0101879:	e8 1a 01 00 00       	call   c0101998 <Sem_init>
	PC_counter = 0;
c010187e:	c7 05 f0 a0 1d c0 00 	movl   $0x0,0xc01da0f0
c0101885:	00 00 00 
}
c0101888:	c9                   	leave  
c0101889:	c3                   	ret    

c010188a <producer>:
	


void producer(void) {
c010188a:	55                   	push   %ebp
c010188b:	89 e5                	mov    %esp,%ebp
c010188d:	83 ec 18             	sub    $0x18,%esp

	//panic("sb");
	while (1)
	{
		Sem_P(&empty);
c0101890:	c7 04 24 e0 a1 1d c0 	movl   $0xc01da1e0,(%esp)
c0101897:	e8 13 01 00 00       	call   c01019af <Sem_P>
		Sem_P(&mutex);
c010189c:	c7 04 24 00 a1 1d c0 	movl   $0xc01da100,(%esp)
c01018a3:	e8 07 01 00 00       	call   c01019af <Sem_P>
		++ PC_counter;
c01018a8:	a1 f0 a0 1d c0       	mov    0xc01da0f0,%eax
c01018ad:	83 c0 01             	add    $0x1,%eax
c01018b0:	a3 f0 a0 1d c0       	mov    %eax,0xc01da0f0
		printk("producing! %d\n", PC_counter);
c01018b5:	a1 f0 a0 1d c0       	mov    0xc01da0f0,%eax
c01018ba:	89 44 24 04          	mov    %eax,0x4(%esp)
c01018be:	c7 04 24 64 3f 10 c0 	movl   $0xc0103f64,(%esp)
c01018c5:	e8 22 eb ff ff       	call   c01003ec <printk>
		Sem_V(&mutex);
c01018ca:	c7 04 24 00 a1 1d c0 	movl   $0xc01da100,(%esp)
c01018d1:	e8 3b 01 00 00       	call   c0101a11 <Sem_V>
		Sem_V(&full);
c01018d6:	c7 04 24 20 a0 1d c0 	movl   $0xc01da020,(%esp)
c01018dd:	e8 2f 01 00 00       	call   c0101a11 <Sem_V>
	}
c01018e2:	eb ac                	jmp    c0101890 <producer+0x6>

c01018e4 <consumer>:
}

void consumer(void) {
c01018e4:	55                   	push   %ebp
c01018e5:	89 e5                	mov    %esp,%ebp
c01018e7:	83 ec 18             	sub    $0x18,%esp

//	panic("fuck");
	while (1)
	{
		Sem_P(&full);
c01018ea:	c7 04 24 20 a0 1d c0 	movl   $0xc01da020,(%esp)
c01018f1:	e8 b9 00 00 00       	call   c01019af <Sem_P>
		Sem_P(&mutex);
c01018f6:	c7 04 24 00 a1 1d c0 	movl   $0xc01da100,(%esp)
c01018fd:	e8 ad 00 00 00       	call   c01019af <Sem_P>
		-- PC_counter;
c0101902:	a1 f0 a0 1d c0       	mov    0xc01da0f0,%eax
c0101907:	83 e8 01             	sub    $0x1,%eax
c010190a:	a3 f0 a0 1d c0       	mov    %eax,0xc01da0f0
		printk("consuming! %d\n", PC_counter);
c010190f:	a1 f0 a0 1d c0       	mov    0xc01da0f0,%eax
c0101914:	89 44 24 04          	mov    %eax,0x4(%esp)
c0101918:	c7 04 24 73 3f 10 c0 	movl   $0xc0103f73,(%esp)
c010191f:	e8 c8 ea ff ff       	call   c01003ec <printk>
		Sem_V(&mutex);
c0101924:	c7 04 24 00 a1 1d c0 	movl   $0xc01da100,(%esp)
c010192b:	e8 e1 00 00 00       	call   c0101a11 <Sem_V>
		Sem_V(&empty);
c0101930:	c7 04 24 e0 a1 1d c0 	movl   $0xc01da1e0,(%esp)
c0101937:	e8 d5 00 00 00       	call   c0101a11 <Sem_V>
	}
c010193c:	eb ac                	jmp    c01018ea <consumer+0x6>
c010193e:	90                   	nop
c010193f:	90                   	nop

c0101940 <enable_interrupt>:
	data[2] = ((uint_32)addr) >> 16;
	asm volatile("lidt (%0)" : : "r"(data));
}

static inline void
enable_interrupt(void) {
c0101940:	55                   	push   %ebp
c0101941:	89 e5                	mov    %esp,%ebp
	asm volatile("sti");
c0101943:	fb                   	sti    
}
c0101944:	5d                   	pop    %ebp
c0101945:	c3                   	ret    

c0101946 <disable_interrupt>:

static inline void
disable_interrupt(void) {
c0101946:	55                   	push   %ebp
c0101947:	89 e5                	mov    %esp,%ebp
	asm volatile("cli");
c0101949:	fa                   	cli    
}
c010194a:	5d                   	pop    %ebp
c010194b:	c3                   	ret    

c010194c <lock>:
uint_32 global_lock_counter = 0;

uint_32 enter_interrupt = 0;

void lock(void)
{
c010194c:	55                   	push   %ebp
c010194d:	89 e5                	mov    %esp,%ebp
	if (global_lock_counter == 0)
c010194f:	a1 44 65 10 c0       	mov    0xc0106544,%eax
c0101954:	85 c0                	test   %eax,%eax
c0101956:	75 05                	jne    c010195d <lock+0x11>
		disable_interrupt();
c0101958:	e8 e9 ff ff ff       	call   c0101946 <disable_interrupt>
	++ global_lock_counter;
c010195d:	a1 44 65 10 c0       	mov    0xc0106544,%eax
c0101962:	83 c0 01             	add    $0x1,%eax
c0101965:	a3 44 65 10 c0       	mov    %eax,0xc0106544
}
c010196a:	5d                   	pop    %ebp
c010196b:	c3                   	ret    

c010196c <unlock>:


void unlock(void)
{
c010196c:	55                   	push   %ebp
c010196d:	89 e5                	mov    %esp,%ebp
	-- global_lock_counter;
c010196f:	a1 44 65 10 c0       	mov    0xc0106544,%eax
c0101974:	83 e8 01             	sub    $0x1,%eax
c0101977:	a3 44 65 10 c0       	mov    %eax,0xc0106544
	if (global_lock_counter == 0 && enter_interrupt == 0)
c010197c:	a1 44 65 10 c0       	mov    0xc0106544,%eax
c0101981:	85 c0                	test   %eax,%eax
c0101983:	75 0e                	jne    c0101993 <unlock+0x27>
c0101985:	a1 48 65 10 c0       	mov    0xc0106548,%eax
c010198a:	85 c0                	test   %eax,%eax
c010198c:	75 05                	jne    c0101993 <unlock+0x27>
		enable_interrupt();
c010198e:	e8 ad ff ff ff       	call   c0101940 <enable_interrupt>
}
c0101993:	5d                   	pop    %ebp
c0101994:	c3                   	ret    
c0101995:	90                   	nop
c0101996:	90                   	nop
c0101997:	90                   	nop

c0101998 <Sem_init>:
#include "kernel.h"


void Sem_init(struct Sem_type *sem, int init_token) {
c0101998:	55                   	push   %ebp
c0101999:	89 e5                	mov    %esp,%ebp
	sem -> token = init_token;
c010199b:	8b 45 08             	mov    0x8(%ebp),%eax
c010199e:	8b 55 0c             	mov    0xc(%ebp),%edx
c01019a1:	89 10                	mov    %edx,(%eax)
	sem -> queue_tail = 0;
c01019a3:	8b 45 08             	mov    0x8(%ebp),%eax
c01019a6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}
c01019ad:	5d                   	pop    %ebp
c01019ae:	c3                   	ret    

c01019af <Sem_P>:
	return NULL;
}
*/

void Sem_P(struct Sem_type *sem)
{
c01019af:	55                   	push   %ebp
c01019b0:	89 e5                	mov    %esp,%ebp
c01019b2:	83 ec 08             	sub    $0x8,%esp
	lock();
c01019b5:	e8 92 ff ff ff       	call   c010194c <lock>
	if (sem -> token > 0)
c01019ba:	8b 45 08             	mov    0x8(%ebp),%eax
c01019bd:	8b 00                	mov    (%eax),%eax
c01019bf:	85 c0                	test   %eax,%eax
c01019c1:	7e 14                	jle    c01019d7 <Sem_P+0x28>
	{
		-- (sem -> token);
c01019c3:	8b 45 08             	mov    0x8(%ebp),%eax
c01019c6:	8b 00                	mov    (%eax),%eax
c01019c8:	8d 50 ff             	lea    -0x1(%eax),%edx
c01019cb:	8b 45 08             	mov    0x8(%ebp),%eax
c01019ce:	89 10                	mov    %edx,(%eax)
		unlock();
c01019d0:	e8 97 ff ff ff       	call   c010196c <unlock>
c01019d5:	eb 38                	jmp    c0101a0f <Sem_P+0x60>
	}
	else
	{
		sem -> queue[sem -> queue_tail ++] = current_pcb -> pid;
c01019d7:	8b 45 08             	mov    0x8(%ebp),%eax
c01019da:	8b 40 04             	mov    0x4(%eax),%eax
c01019dd:	8b 15 04 a0 1d c0    	mov    0xc01da004,%edx
c01019e3:	8b 8a 1c 20 00 00    	mov    0x201c(%edx),%ecx
c01019e9:	8b 55 08             	mov    0x8(%ebp),%edx
c01019ec:	89 4c 82 08          	mov    %ecx,0x8(%edx,%eax,4)
c01019f0:	8d 50 01             	lea    0x1(%eax),%edx
c01019f3:	8b 45 08             	mov    0x8(%ebp),%eax
c01019f6:	89 50 04             	mov    %edx,0x4(%eax)
		current_pcb -> status = STATUS_SLEEPING;
c01019f9:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c01019fe:	c7 80 18 20 00 00 ff 	movl   $0xffffffff,0x2018(%eax)
c0101a05:	ff ff ff 
		unlock();
c0101a08:	e8 5f ff ff ff       	call   c010196c <unlock>
		asm volatile("int $0x80");
c0101a0d:	cd 80                	int    $0x80
	}
}
c0101a0f:	c9                   	leave  
c0101a10:	c3                   	ret    

c0101a11 <Sem_V>:


void Sem_V(struct Sem_type *sem)
{
c0101a11:	55                   	push   %ebp
c0101a12:	89 e5                	mov    %esp,%ebp
c0101a14:	83 ec 08             	sub    $0x8,%esp
	lock();
c0101a17:	e8 30 ff ff ff       	call   c010194c <lock>
	if (sem -> queue_tail != 0)
c0101a1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0101a1f:	8b 40 04             	mov    0x4(%eax),%eax
c0101a22:	85 c0                	test   %eax,%eax
c0101a24:	74 39                	je     c0101a5f <Sem_V+0x4e>
	{
		-- (sem -> queue_tail);
c0101a26:	8b 45 08             	mov    0x8(%ebp),%eax
c0101a29:	8b 40 04             	mov    0x4(%eax),%eax
c0101a2c:	8d 50 ff             	lea    -0x1(%eax),%edx
c0101a2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0101a32:	89 50 04             	mov    %edx,0x4(%eax)
		(Proc + (sem -> queue[sem -> queue_tail])) -> status = STATUS_WAITING;
c0101a35:	8b 45 08             	mov    0x8(%ebp),%eax
c0101a38:	8b 50 04             	mov    0x4(%eax),%edx
c0101a3b:	8b 45 08             	mov    0x8(%ebp),%eax
c0101a3e:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
c0101a42:	89 c2                	mov    %eax,%edx
c0101a44:	89 d0                	mov    %edx,%eax
c0101a46:	c1 e0 02             	shl    $0x2,%eax
c0101a49:	01 d0                	add    %edx,%eax
c0101a4b:	c1 e0 0c             	shl    $0xc,%eax
c0101a4e:	05 00 a0 13 c0       	add    $0xc013a000,%eax
c0101a53:	c7 80 18 20 00 00 00 	movl   $0x0,0x2018(%eax)
c0101a5a:	00 00 00 
c0101a5d:	eb 0d                	jmp    c0101a6c <Sem_V+0x5b>
		//preempt_proc = Proc + (sem -> queue[sem -> queue_tail]);
	}
	else
		++ (sem -> token);	
c0101a5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0101a62:	8b 00                	mov    (%eax),%eax
c0101a64:	8d 50 01             	lea    0x1(%eax),%edx
c0101a67:	8b 45 08             	mov    0x8(%ebp),%eax
c0101a6a:	89 10                	mov    %edx,(%eax)
	unlock();
c0101a6c:	e8 fb fe ff ff       	call   c010196c <unlock>
}
c0101a71:	c9                   	leave  
c0101a72:	c3                   	ret    
c0101a73:	90                   	nop

c0101a74 <Find_Empty_Message>:
#include "kernel.h"

struct Message_Pool_type	Message_Pool[Max_Message_Pool];

//static
struct Message_Pool_type* Find_Empty_Message(struct Message_Pool_type *Pool) {
c0101a74:	55                   	push   %ebp
c0101a75:	89 e5                	mov    %esp,%ebp
c0101a77:	83 ec 10             	sub    $0x10,%esp
	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
c0101a7a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0101a81:	eb 2e                	jmp    c0101ab1 <Find_Empty_Message+0x3d>
		if ((Pool + i) -> flag == TRUE) return (Pool + i);
c0101a83:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0101a86:	89 d0                	mov    %edx,%eax
c0101a88:	c1 e0 02             	shl    $0x2,%eax
c0101a8b:	01 d0                	add    %edx,%eax
c0101a8d:	c1 e0 03             	shl    $0x3,%eax
c0101a90:	03 45 08             	add    0x8(%ebp),%eax
c0101a93:	0f b6 40 24          	movzbl 0x24(%eax),%eax
c0101a97:	3c 01                	cmp    $0x1,%al
c0101a99:	75 12                	jne    c0101aad <Find_Empty_Message+0x39>
c0101a9b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0101a9e:	89 d0                	mov    %edx,%eax
c0101aa0:	c1 e0 02             	shl    $0x2,%eax
c0101aa3:	01 d0                	add    %edx,%eax
c0101aa5:	c1 e0 03             	shl    $0x3,%eax
c0101aa8:	03 45 08             	add    0x8(%ebp),%eax
c0101aab:	eb 0f                	jmp    c0101abc <Find_Empty_Message+0x48>
struct Message_Pool_type	Message_Pool[Max_Message_Pool];

//static
struct Message_Pool_type* Find_Empty_Message(struct Message_Pool_type *Pool) {
	int i;
	for (i = 0; i < Max_Message_Pool; ++ i)
c0101aad:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0101ab1:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
c0101ab5:	7e cc                	jle    c0101a83 <Find_Empty_Message+0xf>
		if ((Pool + i) -> flag == TRUE) return (Pool + i);
	return NULL;
c0101ab7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0101abc:	c9                   	leave  
c0101abd:	c3                   	ret    

c0101abe <send>:

void send(pid_t pid, struct Message *m) {
c0101abe:	55                   	push   %ebp
c0101abf:	89 e5                	mov    %esp,%ebp
c0101ac1:	83 ec 28             	sub    $0x28,%esp

#ifdef DEBUG
printk("In send, from %d to %d\n", (enter_interrupt == 1) ? MSG_HARD_INTR : current_pcb -> pid, pid);
#endif

	lock();
c0101ac4:	e8 83 fe ff ff       	call   c010194c <lock>

	struct PCB	*target_pcb = Proc + pid;
c0101ac9:	8b 55 08             	mov    0x8(%ebp),%edx
c0101acc:	89 d0                	mov    %edx,%eax
c0101ace:	c1 e0 02             	shl    $0x2,%eax
c0101ad1:	01 d0                	add    %edx,%eax
c0101ad3:	c1 e0 0c             	shl    $0xc,%eax
c0101ad6:	05 00 a0 13 c0       	add    $0xc013a000,%eax
c0101adb:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Message_Pool_type *new_msg = Find_Empty_Message(target_pcb -> Msg_rec_Pool);
c0101ade:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101ae1:	05 f0 20 00 00       	add    $0x20f0,%eax
c0101ae6:	89 04 24             	mov    %eax,(%esp)
c0101ae9:	e8 86 ff ff ff       	call   c0101a74 <Find_Empty_Message>
c0101aee:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (new_msg == NULL)
c0101af1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0101af5:	75 0c                	jne    c0101b03 <send+0x45>
		panic("\nNo enough space for message passing!\n");
c0101af7:	c7 04 24 84 3f 10 c0 	movl   $0xc0103f84,(%esp)
c0101afe:	e8 11 e9 ff ff       	call   c0100414 <panic>

	new_msg -> flag = FALSE;
c0101b03:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101b06:	c6 40 24 00          	movb   $0x0,0x24(%eax)

	new_msg -> msg = *m;
c0101b0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101b0d:	8b 55 0c             	mov    0xc(%ebp),%edx
c0101b10:	8b 0a                	mov    (%edx),%ecx
c0101b12:	89 08                	mov    %ecx,(%eax)
c0101b14:	8b 4a 04             	mov    0x4(%edx),%ecx
c0101b17:	89 48 04             	mov    %ecx,0x4(%eax)
c0101b1a:	8b 4a 08             	mov    0x8(%edx),%ecx
c0101b1d:	89 48 08             	mov    %ecx,0x8(%eax)
c0101b20:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0101b23:	89 48 0c             	mov    %ecx,0xc(%eax)
c0101b26:	8b 4a 10             	mov    0x10(%edx),%ecx
c0101b29:	89 48 10             	mov    %ecx,0x10(%eax)
c0101b2c:	8b 4a 14             	mov    0x14(%edx),%ecx
c0101b2f:	89 48 14             	mov    %ecx,0x14(%eax)
c0101b32:	8b 52 18             	mov    0x18(%edx),%edx
c0101b35:	89 50 18             	mov    %edx,0x18(%eax)

	if (enter_interrupt == 1)
c0101b38:	a1 48 65 10 c0       	mov    0xc0106548,%eax
c0101b3d:	83 f8 01             	cmp    $0x1,%eax
c0101b40:	75 0b                	jne    c0101b4d <send+0x8f>
		(new_msg -> msg).src = MSG_HARD_INTR;
c0101b42:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101b45:	c7 00 80 ff ff ff    	movl   $0xffffff80,(%eax)
c0101b4b:	eb 10                	jmp    c0101b5d <send+0x9f>
	else
		(new_msg -> msg).src = current_pcb -> pid;
c0101b4d:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101b52:	8b 90 1c 20 00 00    	mov    0x201c(%eax),%edx
c0101b58:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101b5b:	89 10                	mov    %edx,(%eax)

	(new_msg -> msg).dest = pid;
c0101b5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101b60:	8b 55 08             	mov    0x8(%ebp),%edx
c0101b63:	89 50 04             	mov    %edx,0x4(%eax)

	//printk("from %d to %d\n", (new_msg -> msg).src, (new_msg -> msg).dest);

	new_msg -> next = NULL;
c0101b66:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0101b69:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

	if (target_pcb -> Msg_rec == NULL)
c0101b70:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101b73:	8b 80 f0 34 00 00    	mov    0x34f0(%eax),%eax
c0101b79:	85 c0                	test   %eax,%eax
c0101b7b:	75 23                	jne    c0101ba0 <send+0xe2>
	{
#ifdef DEBUG
printk("Exact NULL %d\n", target_pcb -> pid);
#endif
		target_pcb -> Msg_rec = new_msg;
c0101b7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101b80:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0101b83:	89 90 f0 34 00 00    	mov    %edx,0x34f0(%eax)
		target_pcb -> Msg_rec -> prev = target_pcb -> Msg_rec;
c0101b89:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101b8c:	8b 80 f0 34 00 00    	mov    0x34f0(%eax),%eax
c0101b92:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101b95:	8b 92 f0 34 00 00    	mov    0x34f0(%edx),%edx
c0101b9b:	89 50 1c             	mov    %edx,0x1c(%eax)
c0101b9e:	eb 21                	jmp    c0101bc1 <send+0x103>
	}
	else
	{
		target_pcb -> Msg_rec -> prev -> next = new_msg;
c0101ba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101ba3:	8b 80 f0 34 00 00    	mov    0x34f0(%eax),%eax
c0101ba9:	8b 40 1c             	mov    0x1c(%eax),%eax
c0101bac:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0101baf:	89 50 20             	mov    %edx,0x20(%eax)
		target_pcb -> Msg_rec -> prev = new_msg;
c0101bb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101bb5:	8b 80 f0 34 00 00    	mov    0x34f0(%eax),%eax
c0101bbb:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0101bbe:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	unlock();
c0101bc1:	e8 a6 fd ff ff       	call   c010196c <unlock>

	Sem_V(&(target_pcb -> Msg_lock));
c0101bc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101bc9:	05 20 20 00 00       	add    $0x2020,%eax
c0101bce:	89 04 24             	mov    %eax,(%esp)
c0101bd1:	e8 3b fe ff ff       	call   c0101a11 <Sem_V>
	
}
c0101bd6:	c9                   	leave  
c0101bd7:	c3                   	ret    

c0101bd8 <receive>:


void receive(pid_t pid, struct Message *m) {
c0101bd8:	55                   	push   %ebp
c0101bd9:	89 e5                	mov    %esp,%ebp
c0101bdb:	83 ec 28             	sub    $0x28,%esp
printk("In receive, from %d\n", pid);
#endif

	struct Message_Pool_type	*ptr;

	for (ptr = (current_pcb -> Msg_ign); ptr != NULL && !(pid == ANY || pid == (ptr -> msg).src); ptr = ptr -> next);
c0101bde:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101be3:	8b 80 f4 34 00 00    	mov    0x34f4(%eax),%eax
c0101be9:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0101bec:	eb 09                	jmp    c0101bf7 <receive+0x1f>
c0101bee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101bf1:	8b 40 20             	mov    0x20(%eax),%eax
c0101bf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0101bf7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0101bfb:	74 10                	je     c0101c0d <receive+0x35>
c0101bfd:	83 7d 08 ff          	cmpl   $0xffffffff,0x8(%ebp)
c0101c01:	74 0a                	je     c0101c0d <receive+0x35>
c0101c03:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101c06:	8b 00                	mov    (%eax),%eax
c0101c08:	3b 45 08             	cmp    0x8(%ebp),%eax
c0101c0b:	75 e1                	jne    c0101bee <receive+0x16>

	if (ptr != NULL)
c0101c0d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0101c11:	74 76                	je     c0101c89 <receive+0xb1>
	{
		if (ptr == (current_pcb -> Msg_ign))
c0101c13:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101c18:	8b 80 f4 34 00 00    	mov    0x34f4(%eax),%eax
c0101c1e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0101c21:	75 43                	jne    c0101c66 <receive+0x8e>
		{
			if (ptr -> next == NULL)
c0101c23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101c26:	8b 40 20             	mov    0x20(%eax),%eax
c0101c29:	85 c0                	test   %eax,%eax
c0101c2b:	75 14                	jne    c0101c41 <receive+0x69>
			{
				current_pcb -> Msg_ign = NULL;
c0101c2d:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101c32:	c7 80 f4 34 00 00 00 	movl   $0x0,0x34f4(%eax)
c0101c39:	00 00 00 
c0101c3c:	e9 69 01 00 00       	jmp    c0101daa <receive+0x1d2>

			}
			else
			{
				ptr -> next -> prev = ptr -> prev;
c0101c41:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101c44:	8b 40 20             	mov    0x20(%eax),%eax
c0101c47:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101c4a:	8b 52 1c             	mov    0x1c(%edx),%edx
c0101c4d:	89 50 1c             	mov    %edx,0x1c(%eax)
				current_pcb -> Msg_ign = ptr -> next;
c0101c50:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101c55:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101c58:	8b 52 20             	mov    0x20(%edx),%edx
c0101c5b:	89 90 f4 34 00 00    	mov    %edx,0x34f4(%eax)
c0101c61:	e9 44 01 00 00       	jmp    c0101daa <receive+0x1d2>
			}
		}
		else
		{
			ptr -> prev -> next = ptr -> next;
c0101c66:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101c69:	8b 40 1c             	mov    0x1c(%eax),%eax
c0101c6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101c6f:	8b 52 20             	mov    0x20(%edx),%edx
c0101c72:	89 50 20             	mov    %edx,0x20(%eax)
			ptr -> next -> prev = ptr -> prev;
c0101c75:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101c78:	8b 40 20             	mov    0x20(%eax),%eax
c0101c7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101c7e:	8b 52 1c             	mov    0x1c(%edx),%edx
c0101c81:	89 50 1c             	mov    %edx,0x1c(%eax)
c0101c84:	e9 21 01 00 00       	jmp    c0101daa <receive+0x1d2>
	}
	else
	{
		while (1)
		{
			Sem_P(&(current_pcb -> Msg_lock));
c0101c89:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101c8e:	05 20 20 00 00       	add    $0x2020,%eax
c0101c93:	89 04 24             	mov    %eax,(%esp)
c0101c96:	e8 14 fd ff ff       	call   c01019af <Sem_P>
#ifdef DEBUG
printk("received\n");
#endif

			lock();
c0101c9b:	e8 ac fc ff ff       	call   c010194c <lock>

			ptr = current_pcb -> Msg_rec;
c0101ca0:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101ca5:	8b 80 f0 34 00 00    	mov    0x34f0(%eax),%eax
c0101cab:	89 45 f4             	mov    %eax,-0xc(%ebp)

#ifdef DEBUG
printk("fuck you %d\n", current_pcb -> pid);
printk("Token = %d\n", (current_pcb -> Msg_lock).token);
#endif
			if (current_pcb -> Msg_rec -> next == NULL)
c0101cae:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101cb3:	8b 80 f0 34 00 00    	mov    0x34f0(%eax),%eax
c0101cb9:	8b 40 20             	mov    0x20(%eax),%eax
c0101cbc:	85 c0                	test   %eax,%eax
c0101cbe:	75 11                	jne    c0101cd1 <receive+0xf9>
			{
				current_pcb -> Msg_rec = NULL;
c0101cc0:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101cc5:	c7 80 f0 34 00 00 00 	movl   $0x0,0x34f0(%eax)
c0101ccc:	00 00 00 
c0101ccf:	eb 3a                	jmp    c0101d0b <receive+0x133>
			}
			else
			{
				current_pcb -> Msg_rec -> next -> prev = current_pcb -> Msg_rec -> prev;
c0101cd1:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101cd6:	8b 80 f0 34 00 00    	mov    0x34f0(%eax),%eax
c0101cdc:	8b 40 20             	mov    0x20(%eax),%eax
c0101cdf:	8b 15 04 a0 1d c0    	mov    0xc01da004,%edx
c0101ce5:	8b 92 f0 34 00 00    	mov    0x34f0(%edx),%edx
c0101ceb:	8b 52 1c             	mov    0x1c(%edx),%edx
c0101cee:	89 50 1c             	mov    %edx,0x1c(%eax)
				current_pcb -> Msg_rec = current_pcb -> Msg_rec -> next;
c0101cf1:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101cf6:	8b 15 04 a0 1d c0    	mov    0xc01da004,%edx
c0101cfc:	8b 92 f0 34 00 00    	mov    0x34f0(%edx),%edx
c0101d02:	8b 52 20             	mov    0x20(%edx),%edx
c0101d05:	89 90 f0 34 00 00    	mov    %edx,0x34f0(%eax)
			}

			unlock();
c0101d0b:	e8 5c fc ff ff       	call   c010196c <unlock>

			if (pid == ANY || pid == (ptr -> msg).src) break;
c0101d10:	83 7d 08 ff          	cmpl   $0xffffffff,0x8(%ebp)
c0101d14:	0f 84 90 00 00 00    	je     c0101daa <receive+0x1d2>
c0101d1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101d1d:	8b 00                	mov    (%eax),%eax
c0101d1f:	3b 45 08             	cmp    0x8(%ebp),%eax
c0101d22:	0f 84 82 00 00 00    	je     c0101daa <receive+0x1d2>

			if (current_pcb -> Msg_ign == NULL)
c0101d28:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101d2d:	8b 80 f4 34 00 00    	mov    0x34f4(%eax),%eax
c0101d33:	85 c0                	test   %eax,%eax
c0101d35:	75 36                	jne    c0101d6d <receive+0x195>
			{
				current_pcb -> Msg_ign = ptr;
c0101d37:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101d3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101d3f:	89 90 f4 34 00 00    	mov    %edx,0x34f4(%eax)
				current_pcb -> Msg_ign -> next = NULL;
c0101d45:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101d4a:	8b 80 f4 34 00 00    	mov    0x34f4(%eax),%eax
c0101d50:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
				current_pcb -> Msg_ign -> prev = ptr;
c0101d57:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101d5c:	8b 80 f4 34 00 00    	mov    0x34f4(%eax),%eax
c0101d62:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101d65:	89 50 1c             	mov    %edx,0x1c(%eax)
			{
				ptr -> next = NULL;
				current_pcb -> Msg_ign -> prev -> next = current_pcb -> Msg_ign;
				current_pcb -> Msg_ign -> prev = ptr;
			}
		}
c0101d68:	e9 1c ff ff ff       	jmp    c0101c89 <receive+0xb1>
				current_pcb -> Msg_ign -> next = NULL;
				current_pcb -> Msg_ign -> prev = ptr;
			}
			else
			{
				ptr -> next = NULL;
c0101d6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101d70:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
				current_pcb -> Msg_ign -> prev -> next = current_pcb -> Msg_ign;
c0101d77:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101d7c:	8b 80 f4 34 00 00    	mov    0x34f4(%eax),%eax
c0101d82:	8b 40 1c             	mov    0x1c(%eax),%eax
c0101d85:	8b 15 04 a0 1d c0    	mov    0xc01da004,%edx
c0101d8b:	8b 92 f4 34 00 00    	mov    0x34f4(%edx),%edx
c0101d91:	89 50 20             	mov    %edx,0x20(%eax)
				current_pcb -> Msg_ign -> prev = ptr;
c0101d94:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101d99:	8b 80 f4 34 00 00    	mov    0x34f4(%eax),%eax
c0101d9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101da2:	89 50 1c             	mov    %edx,0x1c(%eax)
			}
		}
c0101da5:	e9 df fe ff ff       	jmp    c0101c89 <receive+0xb1>
	}
	
	*m = ptr -> msg;
c0101daa:	8b 45 0c             	mov    0xc(%ebp),%eax
c0101dad:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0101db0:	8b 0a                	mov    (%edx),%ecx
c0101db2:	89 08                	mov    %ecx,(%eax)
c0101db4:	8b 4a 04             	mov    0x4(%edx),%ecx
c0101db7:	89 48 04             	mov    %ecx,0x4(%eax)
c0101dba:	8b 4a 08             	mov    0x8(%edx),%ecx
c0101dbd:	89 48 08             	mov    %ecx,0x8(%eax)
c0101dc0:	8b 4a 0c             	mov    0xc(%edx),%ecx
c0101dc3:	89 48 0c             	mov    %ecx,0xc(%eax)
c0101dc6:	8b 4a 10             	mov    0x10(%edx),%ecx
c0101dc9:	89 48 10             	mov    %ecx,0x10(%eax)
c0101dcc:	8b 4a 14             	mov    0x14(%edx),%ecx
c0101dcf:	89 48 14             	mov    %ecx,0x14(%eax)
c0101dd2:	8b 52 18             	mov    0x18(%edx),%edx
c0101dd5:	89 50 18             	mov    %edx,0x18(%eax)
	
	lock();
c0101dd8:	e8 6f fb ff ff       	call   c010194c <lock>
	ptr -> flag = TRUE;
c0101ddd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0101de0:	c6 40 24 01          	movb   $0x1,0x24(%eax)
	unlock();
c0101de4:	e8 83 fb ff ff       	call   c010196c <unlock>
}
c0101de9:	c9                   	leave  
c0101dea:	c3                   	ret    
c0101deb:	90                   	nop

c0101dec <out_byte>:
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
	return data;
}

static inline void
out_byte(uint_16 port, uint_8 data) {
c0101dec:	55                   	push   %ebp
c0101ded:	89 e5                	mov    %esp,%ebp
c0101def:	83 ec 08             	sub    $0x8,%esp
c0101df2:	8b 55 08             	mov    0x8(%ebp),%edx
c0101df5:	8b 45 0c             	mov    0xc(%ebp),%eax
c0101df8:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0101dfc:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("out %%al, %%dx" : : "a"(data), "d"(port));
c0101dff:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0101e03:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0101e07:	ee                   	out    %al,(%dx)
}
c0101e08:	c9                   	leave  
c0101e09:	c3                   	ret    

c0101e0a <timer_driver_initialize>:
static void init_alarm(void);
static void new_alarm(pid_t, int_32);
static void pop_alarm(void);


void timer_driver_initialize(void) {
c0101e0a:	55                   	push   %ebp
c0101e0b:	89 e5                	mov    %esp,%ebp
c0101e0d:	83 ec 18             	sub    $0x18,%esp

	init_100hz_timer();
c0101e10:	e8 59 01 00 00       	call   c0101f6e <init_100hz_timer>
	init_alarm();
c0101e15:	e8 fc 00 00 00       	call   c0101f16 <init_alarm>
	add_irq_handle(0, timer_intr);
c0101e1a:	c7 44 24 04 79 1e 10 	movl   $0xc0101e79,0x4(%esp)
c0101e21:	c0 
c0101e22:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0101e29:	e8 32 f1 ff ff       	call   c0100f60 <add_irq_handle>
}
c0101e2e:	c9                   	leave  
c0101e2f:	c3                   	ret    

c0101e30 <timer_driver_thread>:

void
timer_driver_thread(void) {
c0101e30:	55                   	push   %ebp
c0101e31:	89 e5                	mov    %esp,%ebp
c0101e33:	83 ec 18             	sub    $0x18,%esp

	while (TRUE) {
#ifdef DEBUG
printk("God want to receive\n");
#endif
		receive(ANY, &m);
c0101e36:	c7 44 24 04 04 67 10 	movl   $0xc0106704,0x4(%esp)
c0101e3d:	c0 
c0101e3e:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0101e45:	e8 8e fd ff ff       	call   c0101bd8 <receive>
#ifdef DEBUG	
printk("Rogar that!\n");
#endif
		switch (m.type) {
c0101e4a:	a1 0c 67 10 c0       	mov    0xc010670c,%eax
c0101e4f:	83 f8 0a             	cmp    $0xa,%eax
c0101e52:	75 23                	jne    c0101e77 <timer_driver_thread+0x47>
			case TIMER_SET_ALRM:
				lock();
c0101e54:	e8 f3 fa ff ff       	call   c010194c <lock>
				new_alarm(m.int_msg.p1, m.int_msg.p2);
c0101e59:	8b 15 14 67 10 c0    	mov    0xc0106714,%edx
c0101e5f:	a1 10 67 10 c0       	mov    0xc0106710,%eax
c0101e64:	89 54 24 04          	mov    %edx,0x4(%esp)
c0101e68:	89 04 24             	mov    %eax,(%esp)
c0101e6b:	e8 42 01 00 00       	call   c0101fb2 <new_alarm>
				unlock();
c0101e70:	e8 f7 fa ff ff       	call   c010196c <unlock>
		}
	}
c0101e75:	eb bf                	jmp    c0101e36 <timer_driver_thread+0x6>
c0101e77:	eb bd                	jmp    c0101e36 <timer_driver_thread+0x6>

c0101e79 <timer_intr>:
}

static void
timer_intr(void) {
c0101e79:	55                   	push   %ebp
c0101e7a:	89 e5                	mov    %esp,%ebp
c0101e7c:	83 ec 18             	sub    $0x18,%esp
#ifdef DEBUG
printk("Timer Interupt\n");
#endif
	static struct Message m;

	current_pcb->time_elapsed ++;
c0101e7f:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101e84:	8b 90 f8 34 00 00    	mov    0x34f8(%eax),%edx
c0101e8a:	83 c2 01             	add    $0x1,%edx
c0101e8d:	89 90 f8 34 00 00    	mov    %edx,0x34f8(%eax)
	if (current_pcb->time_elapsed % NR_PROC_TIME == 0) {
c0101e93:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0101e98:	8b 88 f8 34 00 00    	mov    0x34f8(%eax),%ecx
c0101e9e:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
c0101ea3:	89 c8                	mov    %ecx,%eax
c0101ea5:	f7 e2                	mul    %edx
c0101ea7:	c1 ea 02             	shr    $0x2,%edx
c0101eaa:	89 d0                	mov    %edx,%eax
c0101eac:	c1 e0 02             	shl    $0x2,%eax
c0101eaf:	01 d0                	add    %edx,%eax
c0101eb1:	89 ca                	mov    %ecx,%edx
c0101eb3:	29 c2                	sub    %eax,%edx
c0101eb5:	85 d2                	test   %edx,%edx
c0101eb7:	75 07                	jne    c0101ec0 <timer_intr+0x47>
		need_sched = TRUE;
c0101eb9:	c6 05 d8 53 10 c0 01 	movb   $0x1,0xc01053d8
	}
	if (alarm_queue != NULL) {
c0101ec0:	a1 e4 66 10 c0       	mov    0xc01066e4,%eax
c0101ec5:	85 c0                	test   %eax,%eax
c0101ec7:	74 4b                	je     c0101f14 <timer_intr+0x9b>
		alarm_queue->remain_time --;
c0101ec9:	a1 e4 66 10 c0       	mov    0xc01066e4,%eax
c0101ece:	8b 50 04             	mov    0x4(%eax),%edx
c0101ed1:	83 ea 01             	sub    $0x1,%edx
c0101ed4:	89 50 04             	mov    %edx,0x4(%eax)
		while (alarm_queue != NULL && alarm_queue->remain_time <= 0) {
c0101ed7:	eb 26                	jmp    c0101eff <timer_intr+0x86>
			m.type = TIMER_ALRM_FIRE;
c0101ed9:	c7 05 f0 66 10 c0 0b 	movl   $0xb,0xc01066f0
c0101ee0:	00 00 00 
#ifdef DEBUG
printk("God want to send to %d\n", alarm_queue -> pid);
#endif
			send(alarm_queue->pid, &m);
c0101ee3:	a1 e4 66 10 c0       	mov    0xc01066e4,%eax
c0101ee8:	8b 00                	mov    (%eax),%eax
c0101eea:	c7 44 24 04 e8 66 10 	movl   $0xc01066e8,0x4(%esp)
c0101ef1:	c0 
c0101ef2:	89 04 24             	mov    %eax,(%esp)
c0101ef5:	e8 c4 fb ff ff       	call   c0101abe <send>
#ifdef DEBUG
printk("after send\n");
#endif


			pop_alarm();
c0101efa:	e8 b3 01 00 00       	call   c01020b2 <pop_alarm>
	if (current_pcb->time_elapsed % NR_PROC_TIME == 0) {
		need_sched = TRUE;
	}
	if (alarm_queue != NULL) {
		alarm_queue->remain_time --;
		while (alarm_queue != NULL && alarm_queue->remain_time <= 0) {
c0101eff:	a1 e4 66 10 c0       	mov    0xc01066e4,%eax
c0101f04:	85 c0                	test   %eax,%eax
c0101f06:	74 0c                	je     c0101f14 <timer_intr+0x9b>
c0101f08:	a1 e4 66 10 c0       	mov    0xc01066e4,%eax
c0101f0d:	8b 40 04             	mov    0x4(%eax),%eax
c0101f10:	85 c0                	test   %eax,%eax
c0101f12:	7e c5                	jle    c0101ed9 <timer_intr+0x60>


			pop_alarm();
		}
	}
}
c0101f14:	c9                   	leave  
c0101f15:	c3                   	ret    

c0101f16 <init_alarm>:

static void
init_alarm(void) {
c0101f16:	55                   	push   %ebp
c0101f17:	89 e5                	mov    %esp,%ebp
c0101f19:	83 ec 10             	sub    $0x10,%esp
	int i;
	alarm_free = alarm_pool;
c0101f1c:	c7 05 e0 66 10 c0 60 	movl   $0xc0106560,0xc01066e0
c0101f23:	65 10 c0 
	alarm_queue = NULL;
c0101f26:	c7 05 e4 66 10 c0 00 	movl   $0x0,0xc01066e4
c0101f2d:	00 00 00 
	for (i = 0; i < NR_PROCESS - 1; i ++) {
c0101f30:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0101f37:	eb 2d                	jmp    c0101f66 <init_alarm+0x50>
		alarm_pool[i].next = &alarm_pool[i + 1];
c0101f39:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0101f3c:	8d 50 01             	lea    0x1(%eax),%edx
c0101f3f:	89 d0                	mov    %edx,%eax
c0101f41:	01 c0                	add    %eax,%eax
c0101f43:	01 d0                	add    %edx,%eax
c0101f45:	c1 e0 02             	shl    $0x2,%eax
c0101f48:	8d 88 60 65 10 c0    	lea    -0x3fef9aa0(%eax),%ecx
c0101f4e:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0101f51:	89 d0                	mov    %edx,%eax
c0101f53:	01 c0                	add    %eax,%eax
c0101f55:	01 d0                	add    %edx,%eax
c0101f57:	c1 e0 02             	shl    $0x2,%eax
c0101f5a:	05 60 65 10 c0       	add    $0xc0106560,%eax
c0101f5f:	89 48 08             	mov    %ecx,0x8(%eax)
static void
init_alarm(void) {
	int i;
	alarm_free = alarm_pool;
	alarm_queue = NULL;
	for (i = 0; i < NR_PROCESS - 1; i ++) {
c0101f62:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0101f66:	83 7d fc 1e          	cmpl   $0x1e,-0x4(%ebp)
c0101f6a:	7e cd                	jle    c0101f39 <init_alarm+0x23>
		alarm_pool[i].next = &alarm_pool[i + 1];
	}
}
c0101f6c:	c9                   	leave  
c0101f6d:	c3                   	ret    

c0101f6e <init_100hz_timer>:

static void
init_100hz_timer(void) {
c0101f6e:	55                   	push   %ebp
c0101f6f:	89 e5                	mov    %esp,%ebp
c0101f71:	83 ec 08             	sub    $0x8,%esp
	out_byte(0x43, 0x34);
c0101f74:	c7 44 24 04 34 00 00 	movl   $0x34,0x4(%esp)
c0101f7b:	00 
c0101f7c:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
c0101f83:	e8 64 fe ff ff       	call   c0101dec <out_byte>
	out_byte(0x40, 11932 % 256);
c0101f88:	c7 44 24 04 9c 00 00 	movl   $0x9c,0x4(%esp)
c0101f8f:	00 
c0101f90:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
c0101f97:	e8 50 fe ff ff       	call   c0101dec <out_byte>
	out_byte(0x40, 11932 / 256);
c0101f9c:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
c0101fa3:	00 
c0101fa4:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
c0101fab:	e8 3c fe ff ff       	call   c0101dec <out_byte>
}
c0101fb0:	c9                   	leave  
c0101fb1:	c3                   	ret    

c0101fb2 <new_alarm>:

static void
new_alarm(pid_t pid, int_32 second) {
c0101fb2:	55                   	push   %ebp
c0101fb3:	89 e5                	mov    %esp,%ebp
c0101fb5:	53                   	push   %ebx
c0101fb6:	83 ec 24             	sub    $0x24,%esp
	struct Alarm *ptr;
	int time = second * 100;
c0101fb9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0101fbc:	6b c0 64             	imul   $0x64,%eax,%eax
c0101fbf:	89 45 f0             	mov    %eax,-0x10(%ebp)

	ptr = alarm_free;
c0101fc2:	a1 e0 66 10 c0       	mov    0xc01066e0,%eax
c0101fc7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	alarm_free = alarm_free->next;
c0101fca:	a1 e0 66 10 c0       	mov    0xc01066e0,%eax
c0101fcf:	8b 40 08             	mov    0x8(%eax),%eax
c0101fd2:	a3 e0 66 10 c0       	mov    %eax,0xc01066e0

	ptr->remain_time = time;
c0101fd7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101fda:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0101fdd:	89 50 04             	mov    %edx,0x4(%eax)
	ptr->pid = pid;
c0101fe0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101fe3:	8b 55 08             	mov    0x8(%ebp),%edx
c0101fe6:	89 10                	mov    %edx,(%eax)

	if (alarm_queue == NULL ||
c0101fe8:	a1 e4 66 10 c0       	mov    0xc01066e4,%eax
c0101fed:	85 c0                	test   %eax,%eax
c0101fef:	74 12                	je     c0102003 <new_alarm+0x51>
		ptr->remain_time < alarm_queue->remain_time) {
c0101ff1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0101ff4:	8b 50 04             	mov    0x4(%eax),%edx
c0101ff7:	a1 e4 66 10 c0       	mov    0xc01066e4,%eax
c0101ffc:	8b 40 04             	mov    0x4(%eax),%eax
	alarm_free = alarm_free->next;

	ptr->remain_time = time;
	ptr->pid = pid;

	if (alarm_queue == NULL ||
c0101fff:	39 c2                	cmp    %eax,%edx
c0102001:	7d 16                	jge    c0102019 <new_alarm+0x67>
		ptr->remain_time < alarm_queue->remain_time) {
		ptr->next = alarm_queue;
c0102003:	8b 15 e4 66 10 c0    	mov    0xc01066e4,%edx
c0102009:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010200c:	89 50 08             	mov    %edx,0x8(%eax)
		alarm_queue = ptr;
c010200f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0102012:	a3 e4 66 10 c0       	mov    %eax,0xc01066e4
c0102017:	eb 6b                	jmp    c0102084 <new_alarm+0xd2>
	} else {
		struct Alarm *cnt = alarm_queue;
c0102019:	a1 e4 66 10 c0       	mov    0xc01066e4,%eax
c010201e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		for (; ; cnt = cnt->next) {
			ptr->remain_time -= cnt->remain_time;
c0102021:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0102024:	8b 50 04             	mov    0x4(%eax),%edx
c0102027:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010202a:	8b 40 04             	mov    0x4(%eax),%eax
c010202d:	29 c2                	sub    %eax,%edx
c010202f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0102032:	89 50 04             	mov    %edx,0x4(%eax)
			if (cnt->next == NULL ||
c0102035:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102038:	8b 40 08             	mov    0x8(%eax),%eax
c010203b:	85 c0                	test   %eax,%eax
c010203d:	74 1e                	je     c010205d <new_alarm+0xab>
				cnt->next->remain_time > ptr->remain_time) {
c010203f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102042:	8b 40 08             	mov    0x8(%eax),%eax
c0102045:	8b 50 04             	mov    0x4(%eax),%edx
c0102048:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010204b:	8b 40 04             	mov    0x4(%eax),%eax
		alarm_queue = ptr;
	} else {
		struct Alarm *cnt = alarm_queue;
		for (; ; cnt = cnt->next) {
			ptr->remain_time -= cnt->remain_time;
			if (cnt->next == NULL ||
c010204e:	39 c2                	cmp    %eax,%edx
c0102050:	7f 0b                	jg     c010205d <new_alarm+0xab>
		ptr->remain_time < alarm_queue->remain_time) {
		ptr->next = alarm_queue;
		alarm_queue = ptr;
	} else {
		struct Alarm *cnt = alarm_queue;
		for (; ; cnt = cnt->next) {
c0102052:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102055:	8b 40 08             	mov    0x8(%eax),%eax
c0102058:	89 45 f4             	mov    %eax,-0xc(%ebp)
			ptr->remain_time -= cnt->remain_time;
			if (cnt->next == NULL ||
				cnt->next->remain_time > ptr->remain_time) {
				break;
			}
		}
c010205b:	eb c4                	jmp    c0102021 <new_alarm+0x6f>
		if (cnt == NULL) panic("No insert position of timer!");
c010205d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0102061:	75 0c                	jne    c010206f <new_alarm+0xbd>
c0102063:	c7 04 24 ab 3f 10 c0 	movl   $0xc0103fab,(%esp)
c010206a:	e8 a5 e3 ff ff       	call   c0100414 <panic>
		ptr->next = cnt->next;
c010206f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102072:	8b 50 08             	mov    0x8(%eax),%edx
c0102075:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0102078:	89 50 08             	mov    %edx,0x8(%eax)
		cnt->next = ptr;
c010207b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010207e:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0102081:	89 50 08             	mov    %edx,0x8(%eax)
	}
	
	if (ptr -> next != NULL)
c0102084:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0102087:	8b 40 08             	mov    0x8(%eax),%eax
c010208a:	85 c0                	test   %eax,%eax
c010208c:	74 1e                	je     c01020ac <new_alarm+0xfa>
		ptr -> next -> remain_time -= ptr -> remain_time;
c010208e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0102091:	8b 40 08             	mov    0x8(%eax),%eax
c0102094:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0102097:	8b 52 08             	mov    0x8(%edx),%edx
c010209a:	8b 4a 04             	mov    0x4(%edx),%ecx
c010209d:	8b 55 ec             	mov    -0x14(%ebp),%edx
c01020a0:	8b 52 04             	mov    0x4(%edx),%edx
c01020a3:	89 cb                	mov    %ecx,%ebx
c01020a5:	29 d3                	sub    %edx,%ebx
c01020a7:	89 da                	mov    %ebx,%edx
c01020a9:	89 50 04             	mov    %edx,0x4(%eax)
	/*
	for (ptr = ptr->next; ptr != NULL; ptr = ptr->next) {
		ptr->remain_time -= time;
	}
	*/
}
c01020ac:	83 c4 24             	add    $0x24,%esp
c01020af:	5b                   	pop    %ebx
c01020b0:	5d                   	pop    %ebp
c01020b1:	c3                   	ret    

c01020b2 <pop_alarm>:

static void
pop_alarm(void) {
c01020b2:	55                   	push   %ebp
c01020b3:	89 e5                	mov    %esp,%ebp
c01020b5:	83 ec 10             	sub    $0x10,%esp
#ifdef DEBUG
printk("In Pop_alarm, head = %d\n", alarm_queue -> pid);
#endif
	struct Alarm *ptr;
	ptr = alarm_queue;
c01020b8:	a1 e4 66 10 c0       	mov    0xc01066e4,%eax
c01020bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
	alarm_queue = alarm_queue->next;
c01020c0:	a1 e4 66 10 c0       	mov    0xc01066e4,%eax
c01020c5:	8b 40 08             	mov    0x8(%eax),%eax
c01020c8:	a3 e4 66 10 c0       	mov    %eax,0xc01066e4
	ptr->next = alarm_free;
c01020cd:	8b 15 e0 66 10 c0    	mov    0xc01066e0,%edx
c01020d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01020d6:	89 50 08             	mov    %edx,0x8(%eax)
	alarm_free = ptr;
c01020d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01020dc:	a3 e0 66 10 c0       	mov    %eax,0xc01066e0
}
c01020e1:	c9                   	leave  
c01020e2:	c3                   	ret    
c01020e3:	90                   	nop

c01020e4 <in_byte>:
#define __X86_IO_H__

//#include "kernel.h"

static inline uint_8
in_byte(uint_16 port) {
c01020e4:	55                   	push   %ebp
c01020e5:	89 e5                	mov    %esp,%ebp
c01020e7:	53                   	push   %ebx
c01020e8:	83 ec 14             	sub    $0x14,%esp
c01020eb:	8b 45 08             	mov    0x8(%ebp),%eax
c01020ee:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	uint_8 data;
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
c01020f2:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c01020f6:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
c01020fa:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
c01020fe:	ec                   	in     (%dx),%al
c01020ff:	89 c3                	mov    %eax,%ebx
c0102101:	88 5d fb             	mov    %bl,-0x5(%ebp)
	return data;
c0102104:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
}
c0102108:	83 c4 14             	add    $0x14,%esp
c010210b:	5b                   	pop    %ebx
c010210c:	5d                   	pop    %ebp
c010210d:	c3                   	ret    

c010210e <out_byte>:
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
	return data;
}

static inline void
out_byte(uint_16 port, uint_8 data) {
c010210e:	55                   	push   %ebp
c010210f:	89 e5                	mov    %esp,%ebp
c0102111:	83 ec 08             	sub    $0x8,%esp
c0102114:	8b 55 08             	mov    0x8(%ebp),%edx
c0102117:	8b 45 0c             	mov    0xc(%ebp),%eax
c010211a:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c010211e:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("out %%al, %%dx" : : "a"(data), "d"(port));
c0102121:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0102125:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0102129:	ee                   	out    %al,(%dx)
}
c010212a:	c9                   	leave  
c010212b:	c3                   	ret    

c010212c <tty_driver_initialize>:
static void canonic_mode_getch(uint_32);
static void canonic_mode_write(struct PCB *, void *, uint_32);
static void canonic_wakeup_read(void);


void tty_driver_initialize(void) {
c010212c:	55                   	push   %ebp
c010212d:	89 e5                	mov    %esp,%ebp
c010212f:	83 ec 18             	sub    $0x18,%esp

	add_irq_handle(1, keyboard_intr);
c0102132:	c7 44 24 04 58 22 10 	movl   $0xc0102258,0x4(%esp)
c0102139:	c0 
c010213a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c0102141:	e8 1a ee ff ff       	call   c0100f60 <add_irq_handle>
	init_read_stack();
c0102146:	e8 2a 06 00 00       	call   c0102775 <init_read_stack>
}
c010214b:	c9                   	leave  
c010214c:	c3                   	ret    

c010214d <tty_driver_thread>:
	

void
tty_driver_thread(void) {
c010214d:	55                   	push   %ebp
c010214e:	89 e5                	mov    %esp,%ebp
c0102150:	83 ec 28             	sub    $0x28,%esp
c0102153:	eb 01                	jmp    c0102156 <tty_driver_thread+0x9>
						canonic_mode_write(pcb, m.dev_io.buf, m.dev_io.length);
					}
					break;
			}
		}
	}
c0102155:	90                   	nop
void
tty_driver_thread(void) {
	static struct Message m;

	while (TRUE) {
		receive(ANY, &m);
c0102156:	c7 44 24 04 dc 6f 10 	movl   $0xc0106fdc,0x4(%esp)
c010215d:	c0 
c010215e:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0102165:	e8 6e fa ff ff       	call   c0101bd8 <receive>
		if (m.src == MSG_HARD_INTR) {
c010216a:	a1 dc 6f 10 c0       	mov    0xc0106fdc,%eax
c010216f:	83 f8 80             	cmp    $0xffffff80,%eax
c0102172:	75 6d                	jne    c01021e1 <tty_driver_thread+0x94>
			uint_32 code = in_byte(0x60);
c0102174:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
c010217b:	e8 64 ff ff ff       	call   c01020e4 <in_byte>
c0102180:	0f b6 c0             	movzbl %al,%eax
c0102183:	89 45 f4             	mov    %eax,-0xc(%ebp)
			uint_32 val  = in_byte(0x61);
c0102186:	c7 04 24 61 00 00 00 	movl   $0x61,(%esp)
c010218d:	e8 52 ff ff ff       	call   c01020e4 <in_byte>
c0102192:	0f b6 c0             	movzbl %al,%eax
c0102195:	89 45 f0             	mov    %eax,-0x10(%ebp)
			out_byte(0x61, val | 0x80);
c0102198:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010219b:	83 c8 80             	or     $0xffffff80,%eax
c010219e:	0f b6 c0             	movzbl %al,%eax
c01021a1:	89 44 24 04          	mov    %eax,0x4(%esp)
c01021a5:	c7 04 24 61 00 00 00 	movl   $0x61,(%esp)
c01021ac:	e8 5d ff ff ff       	call   c010210e <out_byte>
			out_byte(0x61, val);
c01021b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01021b4:	0f b6 c0             	movzbl %al,%eax
c01021b7:	89 44 24 04          	mov    %eax,0x4(%esp)
c01021bb:	c7 04 24 61 00 00 00 	movl   $0x61,(%esp)
c01021c2:	e8 47 ff ff ff       	call   c010210e <out_byte>

			if (mode == MODE_CANONIC) {
c01021c7:	a1 e0 5b 10 c0       	mov    0xc0105be0,%eax
c01021cc:	83 f8 01             	cmp    $0x1,%eax
c01021cf:	75 84                	jne    c0102155 <tty_driver_thread+0x8>
				canonic_mode_getch(code);
c01021d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01021d4:	89 04 24             	mov    %eax,(%esp)
c01021d7:	e8 fe 01 00 00       	call   c01023da <canonic_mode_getch>
						canonic_mode_write(pcb, m.dev_io.buf, m.dev_io.length);
					}
					break;
			}
		}
	}
c01021dc:	e9 74 ff ff ff       	jmp    c0102155 <tty_driver_thread+0x8>

			if (mode == MODE_CANONIC) {
				canonic_mode_getch(code);
			}
		} else {
			switch (m.type) {
c01021e1:	a1 e4 6f 10 c0       	mov    0xc0106fe4,%eax
c01021e6:	83 f8 0c             	cmp    $0xc,%eax
c01021e9:	74 07                	je     c01021f2 <tty_driver_thread+0xa5>
c01021eb:	83 f8 0d             	cmp    $0xd,%eax
c01021ee:	74 2a                	je     c010221a <tty_driver_thread+0xcd>
c01021f0:	eb 61                	jmp    c0102253 <tty_driver_thread+0x106>
				case DEV_READ:
					read_stack_push(m.dev_io.pid, m.dev_io.buf, m.dev_io.length);
c01021f2:	8b 0d f4 6f 10 c0    	mov    0xc0106ff4,%ecx
c01021f8:	8b 15 ec 6f 10 c0    	mov    0xc0106fec,%edx
c01021fe:	a1 e8 6f 10 c0       	mov    0xc0106fe8,%eax
c0102203:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0102207:	89 54 24 04          	mov    %edx,0x4(%esp)
c010220b:	89 04 24             	mov    %eax,(%esp)
c010220e:	e8 c0 05 00 00       	call   c01027d3 <read_stack_push>
					canonic_wakeup_read();
c0102213:	e8 32 06 00 00       	call   c010284a <canonic_wakeup_read>
					break;
c0102218:	eb 39                	jmp    c0102253 <tty_driver_thread+0x106>
				case DEV_WRITE:
					if (mode == MODE_CANONIC) {
c010221a:	a1 e0 5b 10 c0       	mov    0xc0105be0,%eax
c010221f:	83 f8 01             	cmp    $0x1,%eax
c0102222:	75 2e                	jne    c0102252 <tty_driver_thread+0x105>
						struct PCB *pcb = fetch_pcb(m.dev_io.pid);
c0102224:	a1 e8 6f 10 c0       	mov    0xc0106fe8,%eax
c0102229:	89 04 24             	mov    %eax,(%esp)
c010222c:	e8 a6 ef ff ff       	call   c01011d7 <fetch_pcb>
c0102231:	89 45 ec             	mov    %eax,-0x14(%ebp)
						canonic_mode_write(pcb, m.dev_io.buf, m.dev_io.length);
c0102234:	8b 15 f4 6f 10 c0    	mov    0xc0106ff4,%edx
c010223a:	a1 ec 6f 10 c0       	mov    0xc0106fec,%eax
c010223f:	89 54 24 08          	mov    %edx,0x8(%esp)
c0102243:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102247:	8b 45 ec             	mov    -0x14(%ebp),%eax
c010224a:	89 04 24             	mov    %eax,(%esp)
c010224d:	e8 65 04 00 00       	call   c01026b7 <canonic_mode_write>
					}
					break;
c0102252:	90                   	nop
			}
		}
	}
c0102253:	e9 fd fe ff ff       	jmp    c0102155 <tty_driver_thread+0x8>

c0102258 <keyboard_intr>:
}

void
keyboard_intr(void) {
c0102258:	55                   	push   %ebp
c0102259:	89 e5                	mov    %esp,%ebp
c010225b:	83 ec 18             	sub    $0x18,%esp
	static struct Message m;
	send(TTY, &m);
c010225e:	a1 c4 b6 1d c0       	mov    0xc01db6c4,%eax
c0102263:	c7 44 24 04 c0 6f 10 	movl   $0xc0106fc0,0x4(%esp)
c010226a:	c0 
c010226b:	89 04 24             	mov    %eax,(%esp)
c010226e:	e8 4b f8 ff ff       	call   c0101abe <send>
}
c0102273:	c9                   	leave  
c0102274:	c3                   	ret    

c0102275 <get_ascii>:
	   '"',  '~',   0 ,  '|',  'Z',  'X',  'C',  'V',  'B',  'N',
	   'M',  '<',  '>',  '?',   0 ,   0 ,   0 ,  ' '},
};

static char
get_ascii(int code) {
c0102275:	55                   	push   %ebp
c0102276:	89 e5                	mov    %esp,%ebp
c0102278:	83 ec 10             	sub    $0x10,%esp
	int index;

	switch (code) {
c010227b:	8b 45 08             	mov    0x8(%ebp),%eax
c010227e:	83 f8 3a             	cmp    $0x3a,%eax
c0102281:	74 50                	je     c01022d3 <get_ascii+0x5e>
c0102283:	83 f8 3a             	cmp    $0x3a,%eax
c0102286:	7f 0c                	jg     c0102294 <get_ascii+0x1f>
c0102288:	83 f8 2a             	cmp    $0x2a,%eax
c010228b:	74 1e                	je     c01022ab <get_ascii+0x36>
c010228d:	83 f8 36             	cmp    $0x36,%eax
c0102290:	74 19                	je     c01022ab <get_ascii+0x36>
c0102292:	eb 5b                	jmp    c01022ef <get_ascii+0x7a>
c0102294:	3d b6 00 00 00       	cmp    $0xb6,%eax
c0102299:	74 24                	je     c01022bf <get_ascii+0x4a>
c010229b:	3d ba 00 00 00       	cmp    $0xba,%eax
c01022a0:	74 3f                	je     c01022e1 <get_ascii+0x6c>
c01022a2:	3d aa 00 00 00       	cmp    $0xaa,%eax
c01022a7:	74 16                	je     c01022bf <get_ascii+0x4a>
c01022a9:	eb 44                	jmp    c01022ef <get_ascii+0x7a>
		case LSHIFT_DOWN: case RSHIFT_DOWN:
			shift_level ++;
c01022ab:	a1 20 67 10 c0       	mov    0xc0106720,%eax
c01022b0:	83 c0 01             	add    $0x1,%eax
c01022b3:	a3 20 67 10 c0       	mov    %eax,0xc0106720
			return 0;
c01022b8:	b8 00 00 00 00       	mov    $0x0,%eax
c01022bd:	eb 7b                	jmp    c010233a <get_ascii+0xc5>
		case LSHIFT_UP: case RSHIFT_UP:
			shift_level --;
c01022bf:	a1 20 67 10 c0       	mov    0xc0106720,%eax
c01022c4:	83 e8 01             	sub    $0x1,%eax
c01022c7:	a3 20 67 10 c0       	mov    %eax,0xc0106720
			return 0;
c01022cc:	b8 00 00 00 00       	mov    $0x0,%eax
c01022d1:	eb 67                	jmp    c010233a <get_ascii+0xc5>
		case CAPS_ON:
			caps_on = TRUE;
c01022d3:	c6 05 24 67 10 c0 01 	movb   $0x1,0xc0106724
			return 0;
c01022da:	b8 00 00 00 00       	mov    $0x0,%eax
c01022df:	eb 59                	jmp    c010233a <get_ascii+0xc5>
		case CAPS_OFF:
			caps_on = FALSE;
c01022e1:	c6 05 24 67 10 c0 00 	movb   $0x0,0xc0106724
			return 0;
c01022e8:	b8 00 00 00 00       	mov    $0x0,%eax
c01022ed:	eb 4b                	jmp    c010233a <get_ascii+0xc5>
	}

	index = shift_level > 0;
c01022ef:	a1 20 67 10 c0       	mov    0xc0106720,%eax
c01022f4:	85 c0                	test   %eax,%eax
c01022f6:	0f 9f c0             	setg   %al
c01022f9:	0f b6 c0             	movzbl %al,%eax
c01022fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (key_maps[0][code] >= 'a' && key_maps[0][code] <= 'z') {
c01022ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0102302:	8b 04 85 e0 53 10 c0 	mov    -0x3fefac20(,%eax,4),%eax
c0102309:	83 f8 60             	cmp    $0x60,%eax
c010230c:	7e 1c                	jle    c010232a <get_ascii+0xb5>
c010230e:	8b 45 08             	mov    0x8(%ebp),%eax
c0102311:	8b 04 85 e0 53 10 c0 	mov    -0x3fefac20(,%eax,4),%eax
c0102318:	83 f8 7a             	cmp    $0x7a,%eax
c010231b:	7f 0d                	jg     c010232a <get_ascii+0xb5>
		index ^= caps_on;
c010231d:	0f b6 05 24 67 10 c0 	movzbl 0xc0106724,%eax
c0102324:	0f b6 c0             	movzbl %al,%eax
c0102327:	31 45 fc             	xor    %eax,-0x4(%ebp)
	}
	return key_maps[index][code];
c010232a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c010232d:	c1 e0 08             	shl    $0x8,%eax
c0102330:	03 45 08             	add    0x8(%ebp),%eax
c0102333:	8b 04 85 e0 53 10 c0 	mov    -0x3fefac20(,%eax,4),%eax
}
c010233a:	c9                   	leave  
c010233b:	c3                   	ret    

c010233c <update_input>:

static void
update_input(void) {
c010233c:	55                   	push   %ebp
c010233d:	89 e5                	mov    %esp,%ebp
c010233f:	83 ec 28             	sub    $0x28,%esp
	int i;
	if (dirty == TRUE) {
c0102342:	0f b6 05 25 67 10 c0 	movzbl 0xc0106725,%eax
c0102349:	3c 01                	cmp    $0x1,%al
c010234b:	0f 85 87 00 00 00    	jne    c01023d8 <update_input+0x9c>
		dirty = FALSE;
c0102351:	c6 05 25 67 10 c0 00 	movb   $0x0,0xc0106725
		console_printc('\n');
c0102358:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c010235f:	e8 34 e0 ff ff       	call   c0100398 <console_printc>
		for (i = 0; i < cursor_pos; i ++) {
c0102364:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c010236b:	eb 1a                	jmp    c0102387 <update_input+0x4b>
			console_printc(input_buffer[i]);
c010236d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102370:	05 40 67 10 c0       	add    $0xc0106740,%eax
c0102375:	0f b6 00             	movzbl (%eax),%eax
c0102378:	0f be c0             	movsbl %al,%eax
c010237b:	89 04 24             	mov    %eax,(%esp)
c010237e:	e8 15 e0 ff ff       	call   c0100398 <console_printc>
update_input(void) {
	int i;
	if (dirty == TRUE) {
		dirty = FALSE;
		console_printc('\n');
		for (i = 0; i < cursor_pos; i ++) {
c0102383:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0102387:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c010238c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c010238f:	7c dc                	jl     c010236d <update_input+0x31>
			console_printc(input_buffer[i]);
		}
		for (i = cursor_pos; i < input_length; i ++) {
c0102391:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c0102396:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0102399:	eb 1a                	jmp    c01023b5 <update_input+0x79>
			console_printc(input_buffer[i]);
c010239b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010239e:	05 40 67 10 c0       	add    $0xc0106740,%eax
c01023a3:	0f b6 00             	movzbl (%eax),%eax
c01023a6:	0f be c0             	movsbl %al,%eax
c01023a9:	89 04 24             	mov    %eax,(%esp)
c01023ac:	e8 e7 df ff ff       	call   c0100398 <console_printc>
		dirty = FALSE;
		console_printc('\n');
		for (i = 0; i < cursor_pos; i ++) {
			console_printc(input_buffer[i]);
		}
		for (i = cursor_pos; i < input_length; i ++) {
c01023b1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01023b5:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c01023ba:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c01023bd:	7c dc                	jl     c010239b <update_input+0x5f>
			console_printc(input_buffer[i]);
		}
		cursor_left(input_length - cursor_pos);
c01023bf:	8b 15 40 69 10 c0    	mov    0xc0106940,%edx
c01023c5:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c01023ca:	89 d1                	mov    %edx,%ecx
c01023cc:	29 c1                	sub    %eax,%ecx
c01023ce:	89 c8                	mov    %ecx,%eax
c01023d0:	89 04 24             	mov    %eax,(%esp)
c01023d3:	e8 c8 dd ff ff       	call   c01001a0 <cursor_left>
	}
}
c01023d8:	c9                   	leave  
c01023d9:	c3                   	ret    

c01023da <canonic_mode_getch>:

static void
canonic_mode_getch(uint_32 code) {
c01023da:	55                   	push   %ebp
c01023db:	89 e5                	mov    %esp,%ebp
c01023dd:	83 ec 28             	sub    $0x28,%esp
	char ch = get_ascii(code);
c01023e0:	8b 45 08             	mov    0x8(%ebp),%eax
c01023e3:	89 04 24             	mov    %eax,(%esp)
c01023e6:	e8 8a fe ff ff       	call   c0102275 <get_ascii>
c01023eb:	88 45 f3             	mov    %al,-0xd(%ebp)
	int i;

	update_input();
c01023ee:	e8 49 ff ff ff       	call   c010233c <update_input>
	if (ch != 0) {
c01023f3:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c01023f7:	0f 84 b8 00 00 00    	je     c01024b5 <canonic_mode_getch+0xdb>
		console_printc(ch);
c01023fd:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
c0102401:	89 04 24             	mov    %eax,(%esp)
c0102404:	e8 8f df ff ff       	call   c0100398 <console_printc>
		for (i = input_length; i > cursor_pos; i --) {
c0102409:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c010240e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0102411:	eb 1c                	jmp    c010242f <canonic_mode_getch+0x55>
			input_buffer[i] = input_buffer[i - 1];
c0102413:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102416:	83 e8 01             	sub    $0x1,%eax
c0102419:	0f b6 80 40 67 10 c0 	movzbl -0x3fef98c0(%eax),%eax
c0102420:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102423:	81 c2 40 67 10 c0    	add    $0xc0106740,%edx
c0102429:	88 02                	mov    %al,(%edx)
	int i;

	update_input();
	if (ch != 0) {
		console_printc(ch);
		for (i = input_length; i > cursor_pos; i --) {
c010242b:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c010242f:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c0102434:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0102437:	7f da                	jg     c0102413 <canonic_mode_getch+0x39>
			input_buffer[i] = input_buffer[i - 1];
		}
		input_buffer[++ input_length] = 0;
c0102439:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c010243e:	83 c0 01             	add    $0x1,%eax
c0102441:	a3 40 69 10 c0       	mov    %eax,0xc0106940
c0102446:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c010244b:	c6 80 40 67 10 c0 00 	movb   $0x0,-0x3fef98c0(%eax)
		input_buffer[cursor_pos ++] = ch;
c0102452:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c0102457:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
c010245b:	88 90 40 67 10 c0    	mov    %dl,-0x3fef98c0(%eax)
c0102461:	83 c0 01             	add    $0x1,%eax
c0102464:	a3 44 69 10 c0       	mov    %eax,0xc0106944
		for (i = cursor_pos; i < input_length; i ++) {
c0102469:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c010246e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0102471:	eb 1a                	jmp    c010248d <canonic_mode_getch+0xb3>
			console_printc(input_buffer[i]);
c0102473:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102476:	05 40 67 10 c0       	add    $0xc0106740,%eax
c010247b:	0f b6 00             	movzbl (%eax),%eax
c010247e:	0f be c0             	movsbl %al,%eax
c0102481:	89 04 24             	mov    %eax,(%esp)
c0102484:	e8 0f df ff ff       	call   c0100398 <console_printc>
		for (i = input_length; i > cursor_pos; i --) {
			input_buffer[i] = input_buffer[i - 1];
		}
		input_buffer[++ input_length] = 0;
		input_buffer[cursor_pos ++] = ch;
		for (i = cursor_pos; i < input_length; i ++) {
c0102489:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010248d:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c0102492:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0102495:	7c dc                	jl     c0102473 <canonic_mode_getch+0x99>
			console_printc(input_buffer[i]);
		}
		cursor_left(input_length - cursor_pos);
c0102497:	8b 15 40 69 10 c0    	mov    0xc0106940,%edx
c010249d:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c01024a2:	89 d1                	mov    %edx,%ecx
c01024a4:	29 c1                	sub    %eax,%ecx
c01024a6:	89 c8                	mov    %ecx,%eax
c01024a8:	89 04 24             	mov    %eax,(%esp)
c01024ab:	e8 f0 dc ff ff       	call   c01001a0 <cursor_left>
c01024b0:	e9 00 02 00 00       	jmp    c01026b5 <canonic_mode_getch+0x2db>
	} else {
		switch (code) {
c01024b5:	8b 45 08             	mov    0x8(%ebp),%eax
c01024b8:	83 f8 1c             	cmp    $0x1c,%eax
c01024bb:	0f 84 43 01 00 00    	je     c0102604 <canonic_mode_getch+0x22a>
c01024c1:	83 f8 1c             	cmp    $0x1c,%eax
c01024c4:	77 0a                	ja     c01024d0 <canonic_mode_getch+0xf6>
c01024c6:	83 f8 0e             	cmp    $0xe,%eax
c01024c9:	74 1c                	je     c01024e7 <canonic_mode_getch+0x10d>
c01024cb:	e9 e5 01 00 00       	jmp    c01026b5 <canonic_mode_getch+0x2db>
c01024d0:	83 f8 4b             	cmp    $0x4b,%eax
c01024d3:	0f 84 cf 00 00 00    	je     c01025a8 <canonic_mode_getch+0x1ce>
c01024d9:	83 f8 4d             	cmp    $0x4d,%eax
c01024dc:	0f 84 f1 00 00 00    	je     c01025d3 <canonic_mode_getch+0x1f9>
c01024e2:	e9 ce 01 00 00       	jmp    c01026b5 <canonic_mode_getch+0x2db>
			case BACK:
				if (cursor_pos > 0) {
c01024e7:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c01024ec:	85 c0                	test   %eax,%eax
c01024ee:	0f 8e ba 01 00 00    	jle    c01026ae <canonic_mode_getch+0x2d4>
					for (i = cursor_pos - 1; i < input_length; i ++) {
c01024f4:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c01024f9:	83 e8 01             	sub    $0x1,%eax
c01024fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
c01024ff:	eb 1c                	jmp    c010251d <canonic_mode_getch+0x143>
						input_buffer[i] = input_buffer[i + 1];
c0102501:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102504:	83 c0 01             	add    $0x1,%eax
c0102507:	0f b6 80 40 67 10 c0 	movzbl -0x3fef98c0(%eax),%eax
c010250e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0102511:	81 c2 40 67 10 c0    	add    $0xc0106740,%edx
c0102517:	88 02                	mov    %al,(%edx)
		cursor_left(input_length - cursor_pos);
	} else {
		switch (code) {
			case BACK:
				if (cursor_pos > 0) {
					for (i = cursor_pos - 1; i < input_length; i ++) {
c0102519:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c010251d:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c0102522:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0102525:	7c da                	jl     c0102501 <canonic_mode_getch+0x127>
						input_buffer[i] = input_buffer[i + 1];
					}
					input_length --;
c0102527:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c010252c:	83 e8 01             	sub    $0x1,%eax
c010252f:	a3 40 69 10 c0       	mov    %eax,0xc0106940
					cursor_pos --;
c0102534:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c0102539:	83 e8 01             	sub    $0x1,%eax
c010253c:	a3 44 69 10 c0       	mov    %eax,0xc0106944
					cursor_left(1);
c0102541:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c0102548:	e8 53 dc ff ff       	call   c01001a0 <cursor_left>
					for (i = cursor_pos; i < input_length; i ++) {
c010254d:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c0102552:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0102555:	eb 1a                	jmp    c0102571 <canonic_mode_getch+0x197>
						console_printc(input_buffer[i]);
c0102557:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010255a:	05 40 67 10 c0       	add    $0xc0106740,%eax
c010255f:	0f b6 00             	movzbl (%eax),%eax
c0102562:	0f be c0             	movsbl %al,%eax
c0102565:	89 04 24             	mov    %eax,(%esp)
c0102568:	e8 2b de ff ff       	call   c0100398 <console_printc>
						input_buffer[i] = input_buffer[i + 1];
					}
					input_length --;
					cursor_pos --;
					cursor_left(1);
					for (i = cursor_pos; i < input_length; i ++) {
c010256d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0102571:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c0102576:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0102579:	7c dc                	jl     c0102557 <canonic_mode_getch+0x17d>
						console_printc(input_buffer[i]);
					}
					console_printc(' ');
c010257b:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
c0102582:	e8 11 de ff ff       	call   c0100398 <console_printc>
					cursor_left(input_length - cursor_pos + 1);
c0102587:	8b 15 40 69 10 c0    	mov    0xc0106940,%edx
c010258d:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c0102592:	89 d1                	mov    %edx,%ecx
c0102594:	29 c1                	sub    %eax,%ecx
c0102596:	89 c8                	mov    %ecx,%eax
c0102598:	83 c0 01             	add    $0x1,%eax
c010259b:	89 04 24             	mov    %eax,(%esp)
c010259e:	e8 fd db ff ff       	call   c01001a0 <cursor_left>
				}
				break;
c01025a3:	e9 06 01 00 00       	jmp    c01026ae <canonic_mode_getch+0x2d4>
			case KEY_LEFT:
				if (cursor_pos > 0) {
c01025a8:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c01025ad:	85 c0                	test   %eax,%eax
c01025af:	0f 8e fc 00 00 00    	jle    c01026b1 <canonic_mode_getch+0x2d7>
					cursor_pos --;
c01025b5:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c01025ba:	83 e8 01             	sub    $0x1,%eax
c01025bd:	a3 44 69 10 c0       	mov    %eax,0xc0106944
					cursor_left(1);
c01025c2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c01025c9:	e8 d2 db ff ff       	call   c01001a0 <cursor_left>
				}
				break;
c01025ce:	e9 de 00 00 00       	jmp    c01026b1 <canonic_mode_getch+0x2d7>
			case KEY_RIGHT:
				if (cursor_pos < input_length) {
c01025d3:	8b 15 44 69 10 c0    	mov    0xc0106944,%edx
c01025d9:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c01025de:	39 c2                	cmp    %eax,%edx
c01025e0:	0f 8d ce 00 00 00    	jge    c01026b4 <canonic_mode_getch+0x2da>
					cursor_pos ++;
c01025e6:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c01025eb:	83 c0 01             	add    $0x1,%eax
c01025ee:	a3 44 69 10 c0       	mov    %eax,0xc0106944
					cursor_right(1);
c01025f3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
c01025fa:	e8 fe db ff ff       	call   c01001fd <cursor_right>
				}
				break;
c01025ff:	e9 b0 00 00 00       	jmp    c01026b4 <canonic_mode_getch+0x2da>
			case ENTER:
				input_buffer[input_length] = '\n';
c0102604:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c0102609:	c6 80 40 67 10 c0 0a 	movb   $0xa,-0x3fef98c0(%eax)
				input_buffer[++ input_length] = 0;
c0102610:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c0102615:	83 c0 01             	add    $0x1,%eax
c0102618:	a3 40 69 10 c0       	mov    %eax,0xc0106940
c010261d:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c0102622:	c6 80 40 67 10 c0 00 	movb   $0x0,-0x3fef98c0(%eax)
				for (i = 0; i <= input_length; i ++) {
c0102629:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0102630:	eb 3e                	jmp    c0102670 <canonic_mode_getch+0x296>
					input_pool[r ++] = input_buffer[i];
c0102632:	a1 64 6d 10 c0       	mov    0xc0106d64,%eax
c0102637:	8b 55 f4             	mov    -0xc(%ebp),%edx
c010263a:	81 c2 40 67 10 c0    	add    $0xc0106740,%edx
c0102640:	0f b6 12             	movzbl (%edx),%edx
c0102643:	88 90 60 69 10 c0    	mov    %dl,-0x3fef96a0(%eax)
c0102649:	83 c0 01             	add    $0x1,%eax
c010264c:	a3 64 6d 10 c0       	mov    %eax,0xc0106d64
					r %= NR_INPUT_POOL;
c0102651:	a1 64 6d 10 c0       	mov    0xc0106d64,%eax
c0102656:	89 c2                	mov    %eax,%edx
c0102658:	c1 fa 1f             	sar    $0x1f,%edx
c010265b:	c1 ea 16             	shr    $0x16,%edx
c010265e:	01 d0                	add    %edx,%eax
c0102660:	25 ff 03 00 00       	and    $0x3ff,%eax
c0102665:	29 d0                	sub    %edx,%eax
c0102667:	a3 64 6d 10 c0       	mov    %eax,0xc0106d64
				}
				break;
			case ENTER:
				input_buffer[input_length] = '\n';
				input_buffer[++ input_length] = 0;
				for (i = 0; i <= input_length; i ++) {
c010266c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0102670:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c0102675:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0102678:	7e b8                	jle    c0102632 <canonic_mode_getch+0x258>
					input_pool[r ++] = input_buffer[i];
					r %= NR_INPUT_POOL;
				}
				canonic_wakeup_read();
c010267a:	e8 cb 01 00 00       	call   c010284a <canonic_wakeup_read>
				console_printc('\n');
c010267f:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0102686:	e8 0d dd ff ff       	call   c0100398 <console_printc>
				input_buffer[cursor_pos = 0] = 0;
c010268b:	c7 05 44 69 10 c0 00 	movl   $0x0,0xc0106944
c0102692:	00 00 00 
c0102695:	a1 44 69 10 c0       	mov    0xc0106944,%eax
c010269a:	c6 80 40 67 10 c0 00 	movb   $0x0,-0x3fef98c0(%eax)
				input_length = 0;
c01026a1:	c7 05 40 69 10 c0 00 	movl   $0x0,0xc0106940
c01026a8:	00 00 00 
				break;
c01026ab:	90                   	nop
c01026ac:	eb 07                	jmp    c01026b5 <canonic_mode_getch+0x2db>
						console_printc(input_buffer[i]);
					}
					console_printc(' ');
					cursor_left(input_length - cursor_pos + 1);
				}
				break;
c01026ae:	90                   	nop
c01026af:	eb 04                	jmp    c01026b5 <canonic_mode_getch+0x2db>
			case KEY_LEFT:
				if (cursor_pos > 0) {
					cursor_pos --;
					cursor_left(1);
				}
				break;
c01026b1:	90                   	nop
c01026b2:	eb 01                	jmp    c01026b5 <canonic_mode_getch+0x2db>
			case KEY_RIGHT:
				if (cursor_pos < input_length) {
					cursor_pos ++;
					cursor_right(1);
				}
				break;
c01026b4:	90                   	nop
				input_buffer[cursor_pos = 0] = 0;
				input_length = 0;
				break;
		}
	}
}
c01026b5:	c9                   	leave  
c01026b6:	c3                   	ret    

c01026b7 <canonic_mode_write>:

static void
canonic_mode_write(struct PCB *pcb, void *buf, uint_32 length) {
c01026b7:	55                   	push   %ebp
c01026b8:	89 e5                	mov    %esp,%ebp
c01026ba:	83 ec 28             	sub    $0x28,%esp
	uint_32 i, j, count;
	static struct Message m;

	for (i = 0; i < length; i += NR_OUTPUT_BUF) {
c01026bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01026c4:	eb 74                	jmp    c010273a <canonic_mode_write+0x83>
		count = (length - i >= NR_OUTPUT_BUF) ? NR_OUTPUT_BUF : length - i;
c01026c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01026c9:	8b 55 10             	mov    0x10(%ebp),%edx
c01026cc:	89 d1                	mov    %edx,%ecx
c01026ce:	29 c1                	sub    %eax,%ecx
c01026d0:	89 c8                	mov    %ecx,%eax
c01026d2:	ba 00 01 00 00       	mov    $0x100,%edx
c01026d7:	3d 00 01 00 00       	cmp    $0x100,%eax
c01026dc:	0f 47 c2             	cmova  %edx,%eax
c01026df:	89 45 ec             	mov    %eax,-0x14(%ebp)
		copy_to_kernel(pcb, output_buffer, buf + i, count);
c01026e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01026e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01026e8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c01026eb:	01 ca                	add    %ecx,%edx
c01026ed:	89 44 24 0c          	mov    %eax,0xc(%esp)
c01026f1:	89 54 24 08          	mov    %edx,0x8(%esp)
c01026f5:	c7 44 24 04 40 68 10 	movl   $0xc0106840,0x4(%esp)
c01026fc:	c0 
c01026fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0102700:	89 04 24             	mov    %eax,(%esp)
c0102703:	e8 b2 eb ff ff       	call   c01012ba <copy_to_kernel>
		for (j = 0; j < count; j ++) {
c0102708:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010270f:	eb 1a                	jmp    c010272b <canonic_mode_write+0x74>
			console_printc( ((char*)output_buffer)[j] );
c0102711:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102714:	05 40 68 10 c0       	add    $0xc0106840,%eax
c0102719:	0f b6 00             	movzbl (%eax),%eax
c010271c:	0f be c0             	movsbl %al,%eax
c010271f:	89 04 24             	mov    %eax,(%esp)
c0102722:	e8 71 dc ff ff       	call   c0100398 <console_printc>
	static struct Message m;

	for (i = 0; i < length; i += NR_OUTPUT_BUF) {
		count = (length - i >= NR_OUTPUT_BUF) ? NR_OUTPUT_BUF : length - i;
		copy_to_kernel(pcb, output_buffer, buf + i, count);
		for (j = 0; j < count; j ++) {
c0102727:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010272b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010272e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0102731:	72 de                	jb     c0102711 <canonic_mode_write+0x5a>
static void
canonic_mode_write(struct PCB *pcb, void *buf, uint_32 length) {
	uint_32 i, j, count;
	static struct Message m;

	for (i = 0; i < length; i += NR_OUTPUT_BUF) {
c0102733:	81 45 f4 00 01 00 00 	addl   $0x100,-0xc(%ebp)
c010273a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010273d:	3b 45 10             	cmp    0x10(%ebp),%eax
c0102740:	72 84                	jb     c01026c6 <canonic_mode_write+0xf>
		copy_to_kernel(pcb, output_buffer, buf + i, count);
		for (j = 0; j < count; j ++) {
			console_printc( ((char*)output_buffer)[j] );
		}
	}
	if (input_length != 0) {
c0102742:	a1 40 69 10 c0       	mov    0xc0106940,%eax
c0102747:	85 c0                	test   %eax,%eax
c0102749:	74 07                	je     c0102752 <canonic_mode_write+0x9b>
		dirty = TRUE;
c010274b:	c6 05 25 67 10 c0 01 	movb   $0x1,0xc0106725
	}

	m.int_msg.p1 = length;
c0102752:	8b 45 10             	mov    0x10(%ebp),%eax
c0102755:	a3 b0 6f 10 c0       	mov    %eax,0xc0106fb0
	send(pcb->pid, &m);
c010275a:	8b 45 08             	mov    0x8(%ebp),%eax
c010275d:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c0102763:	c7 44 24 04 a4 6f 10 	movl   $0xc0106fa4,0x4(%esp)
c010276a:	c0 
c010276b:	89 04 24             	mov    %eax,(%esp)
c010276e:	e8 4b f3 ff ff       	call   c0101abe <send>
}
c0102773:	c9                   	leave  
c0102774:	c3                   	ret    

c0102775 <init_read_stack>:

static void
init_read_stack(void) {
c0102775:	55                   	push   %ebp
c0102776:	89 e5                	mov    %esp,%ebp
c0102778:	83 ec 10             	sub    $0x10,%esp
	int i;
	for (i = 0; i < NR_PROCESS - 1; i ++) {
c010277b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0102782:	eb 21                	jmp    c01027a5 <init_read_stack+0x30>
		read_pool[i].next = &read_pool[i + 1];
c0102784:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102787:	83 c0 01             	add    $0x1,%eax
c010278a:	c1 e0 04             	shl    $0x4,%eax
c010278d:	8d 90 80 6d 10 c0    	lea    -0x3fef9280(%eax),%edx
c0102793:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102796:	c1 e0 04             	shl    $0x4,%eax
c0102799:	05 80 6d 10 c0       	add    $0xc0106d80,%eax
c010279e:	89 50 0c             	mov    %edx,0xc(%eax)
}

static void
init_read_stack(void) {
	int i;
	for (i = 0; i < NR_PROCESS - 1; i ++) {
c01027a1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01027a5:	83 7d fc 1e          	cmpl   $0x1e,-0x4(%ebp)
c01027a9:	7e d9                	jle    c0102784 <init_read_stack+0xf>
		read_pool[i].next = &read_pool[i + 1];
	}
	read_pool[i].next = NULL;
c01027ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01027ae:	c1 e0 04             	shl    $0x4,%eax
c01027b1:	05 80 6d 10 c0       	add    $0xc0106d80,%eax
c01027b6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	free = read_pool;
c01027bd:	c7 05 80 6f 10 c0 80 	movl   $0xc0106d80,0xc0106f80
c01027c4:	6d 10 c0 
	top = NULL;
c01027c7:	c7 05 84 6f 10 c0 00 	movl   $0x0,0xc0106f84
c01027ce:	00 00 00 
}
c01027d1:	c9                   	leave  
c01027d2:	c3                   	ret    

c01027d3 <read_stack_push>:

static void
read_stack_push(pid_t pid, void *buf, uint_32 length) {
c01027d3:	55                   	push   %ebp
c01027d4:	89 e5                	mov    %esp,%ebp
c01027d6:	83 ec 10             	sub    $0x10,%esp
	struct ReadStack *ptr = free;
c01027d9:	a1 80 6f 10 c0       	mov    0xc0106f80,%eax
c01027de:	89 45 fc             	mov    %eax,-0x4(%ebp)
	free = free->next;
c01027e1:	a1 80 6f 10 c0       	mov    0xc0106f80,%eax
c01027e6:	8b 40 0c             	mov    0xc(%eax),%eax
c01027e9:	a3 80 6f 10 c0       	mov    %eax,0xc0106f80
	ptr->next = top;
c01027ee:	8b 15 84 6f 10 c0    	mov    0xc0106f84,%edx
c01027f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01027f7:	89 50 0c             	mov    %edx,0xc(%eax)
	top = ptr;
c01027fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01027fd:	a3 84 6f 10 c0       	mov    %eax,0xc0106f84
	top->pid = pid;
c0102802:	a1 84 6f 10 c0       	mov    0xc0106f84,%eax
c0102807:	8b 55 08             	mov    0x8(%ebp),%edx
c010280a:	89 10                	mov    %edx,(%eax)
	top->buf = buf;
c010280c:	a1 84 6f 10 c0       	mov    0xc0106f84,%eax
c0102811:	8b 55 0c             	mov    0xc(%ebp),%edx
c0102814:	89 50 04             	mov    %edx,0x4(%eax)
	top->length = length;
c0102817:	a1 84 6f 10 c0       	mov    0xc0106f84,%eax
c010281c:	8b 55 10             	mov    0x10(%ebp),%edx
c010281f:	89 50 08             	mov    %edx,0x8(%eax)
}
c0102822:	c9                   	leave  
c0102823:	c3                   	ret    

c0102824 <read_stack_pop>:
static void
read_stack_pop(struct ReadStack *ptr) {
c0102824:	55                   	push   %ebp
c0102825:	89 e5                	mov    %esp,%ebp
	top = top->next;
c0102827:	a1 84 6f 10 c0       	mov    0xc0106f84,%eax
c010282c:	8b 40 0c             	mov    0xc(%eax),%eax
c010282f:	a3 84 6f 10 c0       	mov    %eax,0xc0106f84
	ptr->next = free;
c0102834:	8b 15 80 6f 10 c0    	mov    0xc0106f80,%edx
c010283a:	8b 45 08             	mov    0x8(%ebp),%eax
c010283d:	89 50 0c             	mov    %edx,0xc(%eax)
	free = ptr;
c0102840:	8b 45 08             	mov    0x8(%ebp),%eax
c0102843:	a3 80 6f 10 c0       	mov    %eax,0xc0106f80
}
c0102848:	5d                   	pop    %ebp
c0102849:	c3                   	ret    

c010284a <canonic_wakeup_read>:

static void
canonic_wakeup_read(void) {
c010284a:	55                   	push   %ebp
c010284b:	89 e5                	mov    %esp,%ebp
c010284d:	56                   	push   %esi
c010284e:	53                   	push   %ebx
c010284f:	83 ec 20             	sub    $0x20,%esp
	int i, nread = 0;
c0102852:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	static struct Message m;

	if (top != NULL && f != r) {
c0102859:	a1 84 6f 10 c0       	mov    0xc0106f84,%eax
c010285e:	85 c0                	test   %eax,%eax
c0102860:	0f 84 09 01 00 00    	je     c010296f <canonic_wakeup_read+0x125>
c0102866:	8b 15 60 6d 10 c0    	mov    0xc0106d60,%edx
c010286c:	a1 64 6d 10 c0       	mov    0xc0106d64,%eax
c0102871:	39 c2                	cmp    %eax,%edx
c0102873:	0f 84 f6 00 00 00    	je     c010296f <canonic_wakeup_read+0x125>
		for (i = 0; i < top->length && input_pool[f] != 0; i ++) {
c0102879:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0102880:	eb 6b                	jmp    c01028ed <canonic_wakeup_read+0xa3>
			copy_from_kernel(fetch_pcb(top->pid),
c0102882:	a1 60 6d 10 c0       	mov    0xc0106d60,%eax
c0102887:	8d b0 60 69 10 c0    	lea    -0x3fef96a0(%eax),%esi
					top->buf + i, input_pool + f, 1);
c010288d:	a1 84 6f 10 c0       	mov    0xc0106f84,%eax
c0102892:	8b 50 04             	mov    0x4(%eax),%edx
	int i, nread = 0;
	static struct Message m;

	if (top != NULL && f != r) {
		for (i = 0; i < top->length && input_pool[f] != 0; i ++) {
			copy_from_kernel(fetch_pcb(top->pid),
c0102895:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102898:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c010289b:	a1 84 6f 10 c0       	mov    0xc0106f84,%eax
c01028a0:	8b 00                	mov    (%eax),%eax
c01028a2:	89 04 24             	mov    %eax,(%esp)
c01028a5:	e8 2d e9 ff ff       	call   c01011d7 <fetch_pcb>
c01028aa:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
c01028b1:	00 
c01028b2:	89 74 24 08          	mov    %esi,0x8(%esp)
c01028b6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
c01028ba:	89 04 24             	mov    %eax,(%esp)
c01028bd:	e8 2c e9 ff ff       	call   c01011ee <copy_from_kernel>
					top->buf + i, input_pool + f, 1);
			f = (f + 1) % NR_INPUT_POOL;
c01028c2:	a1 60 6d 10 c0       	mov    0xc0106d60,%eax
c01028c7:	8d 50 01             	lea    0x1(%eax),%edx
c01028ca:	89 d0                	mov    %edx,%eax
c01028cc:	c1 f8 1f             	sar    $0x1f,%eax
c01028cf:	c1 e8 16             	shr    $0x16,%eax
c01028d2:	01 c2                	add    %eax,%edx
c01028d4:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
c01028da:	89 d1                	mov    %edx,%ecx
c01028dc:	29 c1                	sub    %eax,%ecx
c01028de:	89 c8                	mov    %ecx,%eax
c01028e0:	a3 60 6d 10 c0       	mov    %eax,0xc0106d60
			nread ++;
c01028e5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
canonic_wakeup_read(void) {
	int i, nread = 0;
	static struct Message m;

	if (top != NULL && f != r) {
		for (i = 0; i < top->length && input_pool[f] != 0; i ++) {
c01028e9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c01028ed:	8b 55 f4             	mov    -0xc(%ebp),%edx
c01028f0:	a1 84 6f 10 c0       	mov    0xc0106f84,%eax
c01028f5:	8b 40 08             	mov    0x8(%eax),%eax
c01028f8:	39 c2                	cmp    %eax,%edx
c01028fa:	73 14                	jae    c0102910 <canonic_wakeup_read+0xc6>
c01028fc:	a1 60 6d 10 c0       	mov    0xc0106d60,%eax
c0102901:	0f b6 80 60 69 10 c0 	movzbl -0x3fef96a0(%eax),%eax
c0102908:	84 c0                	test   %al,%al
c010290a:	0f 85 72 ff ff ff    	jne    c0102882 <canonic_wakeup_read+0x38>
			copy_from_kernel(fetch_pcb(top->pid),
					top->buf + i, input_pool + f, 1);
			f = (f + 1) % NR_INPUT_POOL;
			nread ++;
		}
		if (input_pool[f] == 0) {
c0102910:	a1 60 6d 10 c0       	mov    0xc0106d60,%eax
c0102915:	0f b6 80 60 69 10 c0 	movzbl -0x3fef96a0(%eax),%eax
c010291c:	84 c0                	test   %al,%al
c010291e:	75 23                	jne    c0102943 <canonic_wakeup_read+0xf9>
			f = (f + 1) % NR_INPUT_POOL;
c0102920:	a1 60 6d 10 c0       	mov    0xc0106d60,%eax
c0102925:	8d 50 01             	lea    0x1(%eax),%edx
c0102928:	89 d0                	mov    %edx,%eax
c010292a:	c1 f8 1f             	sar    $0x1f,%eax
c010292d:	c1 e8 16             	shr    $0x16,%eax
c0102930:	01 c2                	add    %eax,%edx
c0102932:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
c0102938:	89 d1                	mov    %edx,%ecx
c010293a:	29 c1                	sub    %eax,%ecx
c010293c:	89 c8                	mov    %ecx,%eax
c010293e:	a3 60 6d 10 c0       	mov    %eax,0xc0106d60
		}
		m.int_msg.p1 = nread;
c0102943:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102946:	a3 94 6f 10 c0       	mov    %eax,0xc0106f94
		send(top->pid, &m);
c010294b:	a1 84 6f 10 c0       	mov    0xc0106f84,%eax
c0102950:	8b 00                	mov    (%eax),%eax
c0102952:	c7 44 24 04 88 6f 10 	movl   $0xc0106f88,0x4(%esp)
c0102959:	c0 
c010295a:	89 04 24             	mov    %eax,(%esp)
c010295d:	e8 5c f1 ff ff       	call   c0101abe <send>
		read_stack_pop(top);
c0102962:	a1 84 6f 10 c0       	mov    0xc0106f84,%eax
c0102967:	89 04 24             	mov    %eax,(%esp)
c010296a:	e8 b5 fe ff ff       	call   c0102824 <read_stack_pop>
	}
}
c010296f:	83 c4 20             	add    $0x20,%esp
c0102972:	5b                   	pop    %ebx
c0102973:	5e                   	pop    %esi
c0102974:	5d                   	pop    %ebp
c0102975:	c3                   	ret    
c0102976:	90                   	nop
c0102977:	90                   	nop

c0102978 <in_byte>:
#define __X86_IO_H__

//#include "kernel.h"

static inline uint_8
in_byte(uint_16 port) {
c0102978:	55                   	push   %ebp
c0102979:	89 e5                	mov    %esp,%ebp
c010297b:	53                   	push   %ebx
c010297c:	83 ec 14             	sub    $0x14,%esp
c010297f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102982:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	uint_8 data;
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
c0102986:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c010298a:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
c010298e:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
c0102992:	ec                   	in     (%dx),%al
c0102993:	89 c3                	mov    %eax,%ebx
c0102995:	88 5d fb             	mov    %bl,-0x5(%ebp)
	return data;
c0102998:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
}
c010299c:	83 c4 14             	add    $0x14,%esp
c010299f:	5b                   	pop    %ebx
c01029a0:	5d                   	pop    %ebp
c01029a1:	c3                   	ret    

c01029a2 <in_long>:

static inline uint_32
in_long(uint_16 port) {
c01029a2:	55                   	push   %ebp
c01029a3:	89 e5                	mov    %esp,%ebp
c01029a5:	53                   	push   %ebx
c01029a6:	83 ec 14             	sub    $0x14,%esp
c01029a9:	8b 45 08             	mov    0x8(%ebp),%eax
c01029ac:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	uint_32 data;
	asm volatile("in %1, %0" : "=a"(data) : "d"(port));
c01029b0:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
c01029b4:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
c01029b8:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
c01029bc:	ed                   	in     (%dx),%eax
c01029bd:	89 c3                	mov    %eax,%ebx
c01029bf:	89 5d f8             	mov    %ebx,-0x8(%ebp)
	return data;
c01029c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
c01029c5:	83 c4 14             	add    $0x14,%esp
c01029c8:	5b                   	pop    %ebx
c01029c9:	5d                   	pop    %ebp
c01029ca:	c3                   	ret    

c01029cb <out_byte>:

static inline void
out_byte(uint_16 port, uint_8 data) {
c01029cb:	55                   	push   %ebp
c01029cc:	89 e5                	mov    %esp,%ebp
c01029ce:	83 ec 08             	sub    $0x8,%esp
c01029d1:	8b 55 08             	mov    0x8(%ebp),%edx
c01029d4:	8b 45 0c             	mov    0xc(%ebp),%eax
c01029d7:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c01029db:	88 45 f8             	mov    %al,-0x8(%ebp)
	asm volatile("out %%al, %%dx" : : "a"(data), "d"(port));
c01029de:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c01029e2:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c01029e6:	ee                   	out    %al,(%dx)
}
c01029e7:	c9                   	leave  
c01029e8:	c3                   	ret    

c01029e9 <out_long>:

static inline void
out_long(uint_16 port, uint_32 data) {
c01029e9:	55                   	push   %ebp
c01029ea:	89 e5                	mov    %esp,%ebp
c01029ec:	83 ec 04             	sub    $0x4,%esp
c01029ef:	8b 45 08             	mov    0x8(%ebp),%eax
c01029f2:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	asm volatile("out %%eax, %%dx" : : "a"(data), "d"(port));
c01029f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c01029f9:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c01029fd:	ef                   	out    %eax,(%dx)
}
c01029fe:	c9                   	leave  
c01029ff:	c3                   	ret    

c0102a00 <ide_driver_initialize>:
};
static struct SectorCache cache[NR_SEC_CACHE];
static inline void cache_init(void);


void ide_driver_initialize(void) {
c0102a00:	55                   	push   %ebp
c0102a01:	89 e5                	mov    %esp,%ebp
c0102a03:	83 ec 18             	sub    $0x18,%esp
	
	add_irq_handle(14, ide_intr);
c0102a06:	c7 44 24 04 43 2c 10 	movl   $0xc0102c43,0x4(%esp)
c0102a0d:	c0 
c0102a0e:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
c0102a15:	e8 46 e5 ff ff       	call   c0100f60 <add_irq_handle>
	add_irq_handle(0 , time_intr);
c0102a1a:	c7 44 24 04 6a 2c 10 	movl   $0xc0102c6a,0x4(%esp)
c0102a21:	c0 
c0102a22:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0102a29:	e8 32 e5 ff ff       	call   c0100f60 <add_irq_handle>
	cache_init();
c0102a2e:	e8 29 04 00 00       	call   c0102e5c <cache_init>
}
c0102a33:	c9                   	leave  
c0102a34:	c3                   	ret    

c0102a35 <ide_driver_thread>:


void
ide_driver_thread(void) {
c0102a35:	55                   	push   %ebp
c0102a36:	89 e5                	mov    %esp,%ebp
c0102a38:	83 ec 38             	sub    $0x38,%esp
c0102a3b:	eb 01                	jmp    c0102a3e <ide_driver_thread+0x9>
			}
			m.type = -1;
			m.int_msg.p1 = i;
			send(m.src, &m);
		}
	}
c0102a3d:	90                   	nop
void
ide_driver_thread(void) {
	static struct Message m;

	while (TRUE) {
		receive(ANY, &m);
c0102a3e:	c7 44 24 04 6c 72 11 	movl   $0xc011726c,0x4(%esp)
c0102a45:	c0 
c0102a46:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0102a4d:	e8 86 f1 ff ff       	call   c0101bd8 <receive>
		if (m.src == MSG_HARD_INTR) {
c0102a52:	a1 6c 72 11 c0       	mov    0xc011726c,%eax
c0102a57:	83 f8 80             	cmp    $0xffffff80,%eax
c0102a5a:	0f 85 a0 00 00 00    	jne    c0102b00 <ide_driver_thread+0xcb>
			if (m.type == IDE_WRITEBACK) {
c0102a60:	a1 74 72 11 c0       	mov    0xc0117274,%eax
c0102a65:	83 f8 02             	cmp    $0x2,%eax
c0102a68:	0f 85 81 00 00 00    	jne    c0102aef <ide_driver_thread+0xba>
				int i;
				for (i = 0; i < NR_SEC_CACHE; i ++) {
c0102a6e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0102a75:	eb 6d                	jmp    c0102ae4 <ide_driver_thread+0xaf>
					if (cache[i].dirty == TRUE) {
c0102a77:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102a7a:	c1 e0 03             	shl    $0x3,%eax
c0102a7d:	89 c2                	mov    %eax,%edx
c0102a7f:	c1 e2 06             	shl    $0x6,%edx
c0102a82:	01 d0                	add    %edx,%eax
c0102a84:	05 00 70 10 c0       	add    $0xc0107000,%eax
c0102a89:	0f b6 40 05          	movzbl 0x5(%eax),%eax
c0102a8d:	3c 01                	cmp    $0x1,%al
c0102a8f:	75 4f                	jne    c0102ae0 <ide_driver_thread+0xab>
						ide_prepare(cache[i].sector);
c0102a91:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102a94:	c1 e0 03             	shl    $0x3,%eax
c0102a97:	89 c2                	mov    %eax,%edx
c0102a99:	c1 e2 06             	shl    $0x6,%edx
c0102a9c:	01 d0                	add    %edx,%eax
c0102a9e:	05 00 70 10 c0       	add    $0xc0107000,%eax
c0102aa3:	8b 00                	mov    (%eax),%eax
c0102aa5:	89 04 24             	mov    %eax,(%esp)
c0102aa8:	e8 11 02 00 00       	call   c0102cbe <ide_prepare>
						do_write(&cache[i].content);
c0102aad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102ab0:	c1 e0 03             	shl    $0x3,%eax
c0102ab3:	89 c2                	mov    %eax,%edx
c0102ab5:	c1 e2 06             	shl    $0x6,%edx
c0102ab8:	01 d0                	add    %edx,%eax
c0102aba:	05 00 70 10 c0       	add    $0xc0107000,%eax
c0102abf:	83 c0 06             	add    $0x6,%eax
c0102ac2:	89 04 24             	mov    %eax,(%esp)
c0102ac5:	e8 28 03 00 00       	call   c0102df2 <do_write>
						cache[i].dirty = FALSE;
c0102aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102acd:	c1 e0 03             	shl    $0x3,%eax
c0102ad0:	89 c2                	mov    %eax,%edx
c0102ad2:	c1 e2 06             	shl    $0x6,%edx
c0102ad5:	01 d0                	add    %edx,%eax
c0102ad7:	05 00 70 10 c0       	add    $0xc0107000,%eax
c0102adc:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	while (TRUE) {
		receive(ANY, &m);
		if (m.src == MSG_HARD_INTR) {
			if (m.type == IDE_WRITEBACK) {
				int i;
				for (i = 0; i < NR_SEC_CACHE; i ++) {
c0102ae0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0102ae4:	83 7d f4 7e          	cmpl   $0x7e,-0xc(%ebp)
c0102ae8:	7e 8d                	jle    c0102a77 <ide_driver_thread+0x42>
c0102aea:	e9 4f 01 00 00       	jmp    c0102c3e <ide_driver_thread+0x209>
						do_write(&cache[i].content);
						cache[i].dirty = FALSE;
					}
				}
			} else {
				panic("IDE interrupt is leaking");
c0102aef:	c7 04 24 c8 3f 10 c0 	movl   $0xc0103fc8,(%esp)
c0102af6:	e8 19 d9 ff ff       	call   c0100414 <panic>
			}
			m.type = -1;
			m.int_msg.p1 = i;
			send(m.src, &m);
		}
	}
c0102afb:	e9 3d ff ff ff       	jmp    c0102a3d <ide_driver_thread+0x8>
					}
				}
			} else {
				panic("IDE interrupt is leaking");
			}
		} else if (m.type == DEV_READ) {
c0102b00:	a1 74 72 11 c0       	mov    0xc0117274,%eax
c0102b05:	83 f8 0c             	cmp    $0xc,%eax
c0102b08:	0f 85 8f 00 00 00    	jne    c0102b9d <ide_driver_thread+0x168>
			//printk("IDE driver receive request!\n");
			//printk("rr\n");
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
c0102b0e:	a1 6c 72 11 c0       	mov    0xc011726c,%eax
c0102b13:	89 04 24             	mov    %eax,(%esp)
c0102b16:	e8 bc e6 ff ff       	call   c01011d7 <fetch_pcb>
c0102b1b:	89 45 e8             	mov    %eax,-0x18(%ebp)
			for (i = 0; i < m.dev_io.length; i ++) {
c0102b1e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0102b25:	eb 40                	jmp    c0102b67 <ide_driver_thread+0x132>
				data = read_byte(m.dev_io.offset + i);
c0102b27:	a1 80 72 11 c0       	mov    0xc0117280,%eax
c0102b2c:	03 45 f0             	add    -0x10(%ebp),%eax
c0102b2f:	89 04 24             	mov    %eax,(%esp)
c0102b32:	e8 13 04 00 00       	call   c0102f4a <read_byte>
c0102b37:	0f b6 c0             	movzbl %al,%eax
c0102b3a:	89 45 e0             	mov    %eax,-0x20(%ebp)
				copy_from_kernel(pcb, m.dev_io.buf + i, &data, 1);
c0102b3d:	a1 7c 72 11 c0       	mov    0xc011727c,%eax
c0102b42:	03 45 f0             	add    -0x10(%ebp),%eax
c0102b45:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
c0102b4c:	00 
c0102b4d:	8d 55 e0             	lea    -0x20(%ebp),%edx
c0102b50:	89 54 24 08          	mov    %edx,0x8(%esp)
c0102b54:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102b58:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0102b5b:	89 04 24             	mov    %eax,(%esp)
c0102b5e:	e8 8b e6 ff ff       	call   c01011ee <copy_from_kernel>
		} else if (m.type == DEV_READ) {
			//printk("IDE driver receive request!\n");
			//printk("rr\n");
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
			for (i = 0; i < m.dev_io.length; i ++) {
c0102b63:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0102b67:	a1 84 72 11 c0       	mov    0xc0117284,%eax
c0102b6c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0102b6f:	77 b6                	ja     c0102b27 <ide_driver_thread+0xf2>
				data = read_byte(m.dev_io.offset + i);
				copy_from_kernel(pcb, m.dev_io.buf + i, &data, 1);
			}
			m.type = -1;
c0102b71:	c7 05 74 72 11 c0 ff 	movl   $0xffffffff,0xc0117274
c0102b78:	ff ff ff 
			m.int_msg.p1 = i;
c0102b7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102b7e:	a3 78 72 11 c0       	mov    %eax,0xc0117278
			send(m.src, &m);
c0102b83:	a1 6c 72 11 c0       	mov    0xc011726c,%eax
c0102b88:	c7 44 24 04 6c 72 11 	movl   $0xc011726c,0x4(%esp)
c0102b8f:	c0 
c0102b90:	89 04 24             	mov    %eax,(%esp)
c0102b93:	e8 26 ef ff ff       	call   c0101abe <send>
			}
			m.type = -1;
			m.int_msg.p1 = i;
			send(m.src, &m);
		}
	}
c0102b98:	e9 a0 fe ff ff       	jmp    c0102a3d <ide_driver_thread+0x8>
			}
			m.type = -1;
			m.int_msg.p1 = i;
			send(m.src, &m);
			//printk("ss\n");
		} else if (m.type == DEV_WRITE) {
c0102b9d:	a1 74 72 11 c0       	mov    0xc0117274,%eax
c0102ba2:	83 f8 0d             	cmp    $0xd,%eax
c0102ba5:	0f 85 92 fe ff ff    	jne    c0102a3d <ide_driver_thread+0x8>
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
c0102bab:	a1 6c 72 11 c0       	mov    0xc011726c,%eax
c0102bb0:	89 04 24             	mov    %eax,(%esp)
c0102bb3:	e8 1f e6 ff ff       	call   c01011d7 <fetch_pcb>
c0102bb8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			for (i = 0; i < m.dev_io.length; i ++) {
c0102bbb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0102bc2:	eb 44                	jmp    c0102c08 <ide_driver_thread+0x1d3>
				copy_to_kernel(pcb, &data, m.dev_io.buf + i, 1);
c0102bc4:	a1 7c 72 11 c0       	mov    0xc011727c,%eax
c0102bc9:	03 45 ec             	add    -0x14(%ebp),%eax
c0102bcc:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
c0102bd3:	00 
c0102bd4:	89 44 24 08          	mov    %eax,0x8(%esp)
c0102bd8:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0102bdb:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102bdf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0102be2:	89 04 24             	mov    %eax,(%esp)
c0102be5:	e8 d0 e6 ff ff       	call   c01012ba <copy_to_kernel>
				write_byte(m.dev_io.offset + i, data);
c0102bea:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0102bed:	0f b6 d0             	movzbl %al,%edx
c0102bf0:	a1 80 72 11 c0       	mov    0xc0117280,%eax
c0102bf5:	03 45 ec             	add    -0x14(%ebp),%eax
c0102bf8:	89 54 24 04          	mov    %edx,0x4(%esp)
c0102bfc:	89 04 24             	mov    %eax,(%esp)
c0102bff:	e8 78 03 00 00       	call   c0102f7c <write_byte>
			send(m.src, &m);
			//printk("ss\n");
		} else if (m.type == DEV_WRITE) {
			uint_32 i, data;
			struct PCB *pcb = fetch_pcb(m.src);
			for (i = 0; i < m.dev_io.length; i ++) {
c0102c04:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0102c08:	a1 84 72 11 c0       	mov    0xc0117284,%eax
c0102c0d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0102c10:	77 b2                	ja     c0102bc4 <ide_driver_thread+0x18f>
				copy_to_kernel(pcb, &data, m.dev_io.buf + i, 1);
				write_byte(m.dev_io.offset + i, data);
			}
			m.type = -1;
c0102c12:	c7 05 74 72 11 c0 ff 	movl   $0xffffffff,0xc0117274
c0102c19:	ff ff ff 
			m.int_msg.p1 = i;
c0102c1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0102c1f:	a3 78 72 11 c0       	mov    %eax,0xc0117278
			send(m.src, &m);
c0102c24:	a1 6c 72 11 c0       	mov    0xc011726c,%eax
c0102c29:	c7 44 24 04 6c 72 11 	movl   $0xc011726c,0x4(%esp)
c0102c30:	c0 
c0102c31:	89 04 24             	mov    %eax,(%esp)
c0102c34:	e8 85 ee ff ff       	call   c0101abe <send>
		}
	}
c0102c39:	e9 ff fd ff ff       	jmp    c0102a3d <ide_driver_thread+0x8>
c0102c3e:	e9 fa fd ff ff       	jmp    c0102a3d <ide_driver_thread+0x8>

c0102c43 <ide_intr>:
}


static void
ide_intr(void) {
c0102c43:	55                   	push   %ebp
c0102c44:	89 e5                	mov    %esp,%ebp
c0102c46:	83 ec 18             	sub    $0x18,%esp
	static struct Message m;
	m.type = IDE_READY;
c0102c49:	c7 05 58 72 11 c0 01 	movl   $0x1,0xc0117258
c0102c50:	00 00 00 
	send(IDE, &m);
c0102c53:	a1 c8 b6 1d c0       	mov    0xc01db6c8,%eax
c0102c58:	c7 44 24 04 50 72 11 	movl   $0xc0117250,0x4(%esp)
c0102c5f:	c0 
c0102c60:	89 04 24             	mov    %eax,(%esp)
c0102c63:	e8 56 ee ff ff       	call   c0101abe <send>
}
c0102c68:	c9                   	leave  
c0102c69:	c3                   	ret    

c0102c6a <time_intr>:


static void
time_intr(void) {
c0102c6a:	55                   	push   %ebp
c0102c6b:	89 e5                	mov    %esp,%ebp
c0102c6d:	83 ec 18             	sub    $0x18,%esp
	static struct Message m;
	static uint_32 counter = 0;
	counter = (counter + 1) % WRITEBACK_TIME;
c0102c70:	a1 30 72 11 c0       	mov    0xc0117230,%eax
c0102c75:	8d 48 01             	lea    0x1(%eax),%ecx
c0102c78:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c0102c7d:	89 c8                	mov    %ecx,%eax
c0102c7f:	f7 e2                	mul    %edx
c0102c81:	89 d0                	mov    %edx,%eax
c0102c83:	c1 e8 05             	shr    $0x5,%eax
c0102c86:	6b c0 64             	imul   $0x64,%eax,%eax
c0102c89:	89 ca                	mov    %ecx,%edx
c0102c8b:	29 c2                	sub    %eax,%edx
c0102c8d:	89 d0                	mov    %edx,%eax
c0102c8f:	a3 30 72 11 c0       	mov    %eax,0xc0117230
	if (counter == 0) {
c0102c94:	a1 30 72 11 c0       	mov    0xc0117230,%eax
c0102c99:	85 c0                	test   %eax,%eax
c0102c9b:	75 1f                	jne    c0102cbc <time_intr+0x52>
		m.type = IDE_WRITEBACK;
c0102c9d:	c7 05 3c 72 11 c0 02 	movl   $0x2,0xc011723c
c0102ca4:	00 00 00 
		send(IDE, &m);
c0102ca7:	a1 c8 b6 1d c0       	mov    0xc01db6c8,%eax
c0102cac:	c7 44 24 04 34 72 11 	movl   $0xc0117234,0x4(%esp)
c0102cb3:	c0 
c0102cb4:	89 04 24             	mov    %eax,(%esp)
c0102cb7:	e8 02 ee ff ff       	call   c0101abe <send>
	}
}
c0102cbc:	c9                   	leave  
c0102cbd:	c3                   	ret    

c0102cbe <ide_prepare>:


static inline void
ide_prepare(uint_32 sector) {
c0102cbe:	55                   	push   %ebp
c0102cbf:	89 e5                	mov    %esp,%ebp
c0102cc1:	83 ec 28             	sub    $0x28,%esp
	int r;
	r = in_byte(IDE_PORT_BASE + 7);
c0102cc4:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
c0102ccb:	e8 a8 fc ff ff       	call   c0102978 <in_byte>
c0102cd0:	0f b6 c0             	movzbl %al,%eax
c0102cd3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if ( (r & (0x80 | 0x40)) != 0x40)
c0102cd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102cd9:	25 c0 00 00 00       	and    $0xc0,%eax
c0102cde:	83 f8 40             	cmp    $0x40,%eax
c0102ce1:	74 0c                	je     c0102cef <ide_prepare+0x31>
		panic("IDE NOT READY");
c0102ce3:	c7 04 24 e1 3f 10 c0 	movl   $0xc0103fe1,(%esp)
c0102cea:	e8 25 d7 ff ff       	call   c0100414 <panic>

	out_byte(IDE_PORT_CTRL, 0);
c0102cef:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0102cf6:	00 
c0102cf7:	c7 04 24 f6 03 00 00 	movl   $0x3f6,(%esp)
c0102cfe:	e8 c8 fc ff ff       	call   c01029cb <out_byte>
	out_byte(IDE_PORT_BASE + 2, 1);
c0102d03:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
c0102d0a:	00 
c0102d0b:	c7 04 24 f2 01 00 00 	movl   $0x1f2,(%esp)
c0102d12:	e8 b4 fc ff ff       	call   c01029cb <out_byte>
	out_byte(IDE_PORT_BASE + 3, sector & 0xFF);
c0102d17:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d1a:	0f b6 c0             	movzbl %al,%eax
c0102d1d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102d21:	c7 04 24 f3 01 00 00 	movl   $0x1f3,(%esp)
c0102d28:	e8 9e fc ff ff       	call   c01029cb <out_byte>
	out_byte(IDE_PORT_BASE + 4, (sector >> 8) & 0xFF);
c0102d2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d30:	c1 e8 08             	shr    $0x8,%eax
c0102d33:	0f b6 c0             	movzbl %al,%eax
c0102d36:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102d3a:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
c0102d41:	e8 85 fc ff ff       	call   c01029cb <out_byte>
	out_byte(IDE_PORT_BASE + 5, (sector >> 16) & 0xFF);
c0102d46:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d49:	c1 e8 10             	shr    $0x10,%eax
c0102d4c:	0f b6 c0             	movzbl %al,%eax
c0102d4f:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102d53:	c7 04 24 f5 01 00 00 	movl   $0x1f5,(%esp)
c0102d5a:	e8 6c fc ff ff       	call   c01029cb <out_byte>
	out_byte(IDE_PORT_BASE + 6, 0xE0 | ((sector >> 24) & 0xFF));
c0102d5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102d62:	c1 e8 18             	shr    $0x18,%eax
c0102d65:	83 c8 e0             	or     $0xffffffe0,%eax
c0102d68:	0f b6 c0             	movzbl %al,%eax
c0102d6b:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102d6f:	c7 04 24 f6 01 00 00 	movl   $0x1f6,(%esp)
c0102d76:	e8 50 fc ff ff       	call   c01029cb <out_byte>
}
c0102d7b:	c9                   	leave  
c0102d7c:	c3                   	ret    

c0102d7d <issue_read>:



static inline void
issue_read(void) {
c0102d7d:	55                   	push   %ebp
c0102d7e:	89 e5                	mov    %esp,%ebp
c0102d80:	83 ec 08             	sub    $0x8,%esp
	out_byte(IDE_PORT_BASE + 7, 0x20);
c0102d83:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
c0102d8a:	00 
c0102d8b:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
c0102d92:	e8 34 fc ff ff       	call   c01029cb <out_byte>
}
c0102d97:	c9                   	leave  
c0102d98:	c3                   	ret    

c0102d99 <do_read>:


static void
do_read(void *buf) {
c0102d99:	55                   	push   %ebp
c0102d9a:	89 e5                	mov    %esp,%ebp
c0102d9c:	53                   	push   %ebx
c0102d9d:	83 ec 24             	sub    $0x24,%esp
	int i;
	static struct Message m;
	do {
		receive(MSG_HARD_INTR, &m);
c0102da0:	c7 44 24 04 14 72 11 	movl   $0xc0117214,0x4(%esp)
c0102da7:	c0 
c0102da8:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c0102daf:	e8 24 ee ff ff       	call   c0101bd8 <receive>
	} while (m.type != IDE_READY);
c0102db4:	a1 1c 72 11 c0       	mov    0xc011721c,%eax
c0102db9:	83 f8 01             	cmp    $0x1,%eax
c0102dbc:	75 e2                	jne    c0102da0 <do_read+0x7>

	for (i = 0; i < 512 / sizeof(uint_32); i ++) {
c0102dbe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0102dc5:	eb 1d                	jmp    c0102de4 <do_read+0x4b>
		*(((uint_32*)buf) + i) = in_long(IDE_PORT_BASE);
c0102dc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102dca:	c1 e0 02             	shl    $0x2,%eax
c0102dcd:	89 c3                	mov    %eax,%ebx
c0102dcf:	03 5d 08             	add    0x8(%ebp),%ebx
c0102dd2:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
c0102dd9:	e8 c4 fb ff ff       	call   c01029a2 <in_long>
c0102dde:	89 03                	mov    %eax,(%ebx)
	static struct Message m;
	do {
		receive(MSG_HARD_INTR, &m);
	} while (m.type != IDE_READY);

	for (i = 0; i < 512 / sizeof(uint_32); i ++) {
c0102de0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0102de4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102de7:	83 f8 7f             	cmp    $0x7f,%eax
c0102dea:	76 db                	jbe    c0102dc7 <do_read+0x2e>
		*(((uint_32*)buf) + i) = in_long(IDE_PORT_BASE);
	}
}
c0102dec:	83 c4 24             	add    $0x24,%esp
c0102def:	5b                   	pop    %ebx
c0102df0:	5d                   	pop    %ebp
c0102df1:	c3                   	ret    

c0102df2 <do_write>:

static void
do_write(void *buf) {
c0102df2:	55                   	push   %ebp
c0102df3:	89 e5                	mov    %esp,%ebp
c0102df5:	83 ec 28             	sub    $0x28,%esp
	int i;
	static struct Message m;
	out_byte(IDE_PORT_BASE + 7, 0x30);
c0102df8:	c7 44 24 04 30 00 00 	movl   $0x30,0x4(%esp)
c0102dff:	00 
c0102e00:	c7 04 24 f7 01 00 00 	movl   $0x1f7,(%esp)
c0102e07:	e8 bf fb ff ff       	call   c01029cb <out_byte>
	for (i = 0; i < 512 / sizeof(uint_32); i ++) {
c0102e0c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0102e13:	eb 1f                	jmp    c0102e34 <do_write+0x42>
		out_long(IDE_PORT_BASE, *(((uint_32*)buf) + i));
c0102e15:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102e18:	c1 e0 02             	shl    $0x2,%eax
c0102e1b:	03 45 08             	add    0x8(%ebp),%eax
c0102e1e:	8b 00                	mov    (%eax),%eax
c0102e20:	89 44 24 04          	mov    %eax,0x4(%esp)
c0102e24:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
c0102e2b:	e8 b9 fb ff ff       	call   c01029e9 <out_long>
static void
do_write(void *buf) {
	int i;
	static struct Message m;
	out_byte(IDE_PORT_BASE + 7, 0x30);
	for (i = 0; i < 512 / sizeof(uint_32); i ++) {
c0102e30:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0102e34:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102e37:	83 f8 7f             	cmp    $0x7f,%eax
c0102e3a:	76 d9                	jbe    c0102e15 <do_write+0x23>
		out_long(IDE_PORT_BASE, *(((uint_32*)buf) + i));
	}
	do {
		receive(MSG_HARD_INTR, &m);
c0102e3c:	c7 44 24 04 f8 71 11 	movl   $0xc01171f8,0x4(%esp)
c0102e43:	c0 
c0102e44:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c0102e4b:	e8 88 ed ff ff       	call   c0101bd8 <receive>
	} while (m.type != IDE_READY);
c0102e50:	a1 00 72 11 c0       	mov    0xc0117200,%eax
c0102e55:	83 f8 01             	cmp    $0x1,%eax
c0102e58:	75 e2                	jne    c0102e3c <do_write+0x4a>
}
c0102e5a:	c9                   	leave  
c0102e5b:	c3                   	ret    

c0102e5c <cache_init>:

static inline void
cache_init(void) {
c0102e5c:	55                   	push   %ebp
c0102e5d:	89 e5                	mov    %esp,%ebp
c0102e5f:	83 ec 10             	sub    $0x10,%esp
	int i;
	for (i = 0; i < NR_SEC_CACHE; i ++) {
c0102e62:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0102e69:	eb 1a                	jmp    c0102e85 <cache_init+0x29>
		cache[i].used = FALSE;
c0102e6b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0102e6e:	c1 e0 03             	shl    $0x3,%eax
c0102e71:	89 c2                	mov    %eax,%edx
c0102e73:	c1 e2 06             	shl    $0x6,%edx
c0102e76:	01 d0                	add    %edx,%eax
c0102e78:	05 00 70 10 c0       	add    $0xc0107000,%eax
c0102e7d:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}

static inline void
cache_init(void) {
	int i;
	for (i = 0; i < NR_SEC_CACHE; i ++) {
c0102e81:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0102e85:	83 7d fc 7e          	cmpl   $0x7e,-0x4(%ebp)
c0102e89:	7e e0                	jle    c0102e6b <cache_init+0xf>
		cache[i].used = FALSE;
	}
}
c0102e8b:	c9                   	leave  
c0102e8c:	c3                   	ret    

c0102e8d <cache_fetch>:

static struct SectorCache *
cache_fetch(uint_32 sector) {
c0102e8d:	55                   	push   %ebp
c0102e8e:	89 e5                	mov    %esp,%ebp
c0102e90:	83 ec 28             	sub    $0x28,%esp
	struct SectorCache *ptr = &cache[sector % NR_SEC_CACHE];
c0102e93:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0102e96:	ba 11 08 04 02       	mov    $0x2040811,%edx
c0102e9b:	89 c8                	mov    %ecx,%eax
c0102e9d:	f7 e2                	mul    %edx
c0102e9f:	89 c8                	mov    %ecx,%eax
c0102ea1:	29 d0                	sub    %edx,%eax
c0102ea3:	d1 e8                	shr    %eax
c0102ea5:	01 d0                	add    %edx,%eax
c0102ea7:	89 c2                	mov    %eax,%edx
c0102ea9:	c1 ea 06             	shr    $0x6,%edx
c0102eac:	89 d0                	mov    %edx,%eax
c0102eae:	c1 e0 07             	shl    $0x7,%eax
c0102eb1:	29 d0                	sub    %edx,%eax
c0102eb3:	89 ca                	mov    %ecx,%edx
c0102eb5:	29 c2                	sub    %eax,%edx
c0102eb7:	89 d0                	mov    %edx,%eax
c0102eb9:	c1 e0 03             	shl    $0x3,%eax
c0102ebc:	89 c2                	mov    %eax,%edx
c0102ebe:	c1 e2 06             	shl    $0x6,%edx
c0102ec1:	01 d0                	add    %edx,%eax
c0102ec3:	05 00 70 10 c0       	add    $0xc0107000,%eax
c0102ec8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (ptr->used == TRUE && ptr->sector == sector) {
c0102ecb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102ece:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0102ed2:	3c 01                	cmp    $0x1,%al
c0102ed4:	75 0a                	jne    c0102ee0 <cache_fetch+0x53>
c0102ed6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102ed9:	8b 00                	mov    (%eax),%eax
c0102edb:	3b 45 08             	cmp    0x8(%ebp),%eax
c0102ede:	74 65                	je     c0102f45 <cache_fetch+0xb8>
		/* cache hit, do nothing */
	} else {
		if (ptr->used == TRUE && ptr->dirty == TRUE) {
c0102ee0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102ee3:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0102ee7:	3c 01                	cmp    $0x1,%al
c0102ee9:	75 26                	jne    c0102f11 <cache_fetch+0x84>
c0102eeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102eee:	0f b6 40 05          	movzbl 0x5(%eax),%eax
c0102ef2:	3c 01                	cmp    $0x1,%al
c0102ef4:	75 1b                	jne    c0102f11 <cache_fetch+0x84>
			/* write back */
			ide_prepare(ptr->sector);
c0102ef6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102ef9:	8b 00                	mov    (%eax),%eax
c0102efb:	89 04 24             	mov    %eax,(%esp)
c0102efe:	e8 bb fd ff ff       	call   c0102cbe <ide_prepare>
			do_write(&ptr->content);
c0102f03:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102f06:	83 c0 06             	add    $0x6,%eax
c0102f09:	89 04 24             	mov    %eax,(%esp)
c0102f0c:	e8 e1 fe ff ff       	call   c0102df2 <do_write>
		}
		/* issue a read command */
		ide_prepare(sector);
c0102f11:	8b 45 08             	mov    0x8(%ebp),%eax
c0102f14:	89 04 24             	mov    %eax,(%esp)
c0102f17:	e8 a2 fd ff ff       	call   c0102cbe <ide_prepare>
		issue_read();
c0102f1c:	e8 5c fe ff ff       	call   c0102d7d <issue_read>
		do_read(&ptr->content);
c0102f21:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102f24:	83 c0 06             	add    $0x6,%eax
c0102f27:	89 04 24             	mov    %eax,(%esp)
c0102f2a:	e8 6a fe ff ff       	call   c0102d99 <do_read>
		ptr->used = TRUE;
c0102f2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102f32:	c6 40 04 01          	movb   $0x1,0x4(%eax)
		ptr->sector = sector;
c0102f36:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102f39:	8b 55 08             	mov    0x8(%ebp),%edx
c0102f3c:	89 10                	mov    %edx,(%eax)
		ptr->dirty = FALSE;
c0102f3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102f41:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	}
	return ptr;
c0102f45:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0102f48:	c9                   	leave  
c0102f49:	c3                   	ret    

c0102f4a <read_byte>:

static uint_8
read_byte(uint_32 offset) {
c0102f4a:	55                   	push   %ebp
c0102f4b:	89 e5                	mov    %esp,%ebp
c0102f4d:	83 ec 28             	sub    $0x28,%esp
	uint_32 sector = offset >> 9;
c0102f50:	8b 45 08             	mov    0x8(%ebp),%eax
c0102f53:	c1 e8 09             	shr    $0x9,%eax
c0102f56:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct SectorCache *ptr = cache_fetch(sector);
c0102f59:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102f5c:	89 04 24             	mov    %eax,(%esp)
c0102f5f:	e8 29 ff ff ff       	call   c0102e8d <cache_fetch>
c0102f64:	89 45 f0             	mov    %eax,-0x10(%ebp)
	return ptr->content[offset & 511];
c0102f67:	8b 45 08             	mov    0x8(%ebp),%eax
c0102f6a:	89 c2                	mov    %eax,%edx
c0102f6c:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
c0102f72:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102f75:	0f b6 44 10 06       	movzbl 0x6(%eax,%edx,1),%eax
}
c0102f7a:	c9                   	leave  
c0102f7b:	c3                   	ret    

c0102f7c <write_byte>:
static void
write_byte(uint_32 offset, uint_8 data) {
c0102f7c:	55                   	push   %ebp
c0102f7d:	89 e5                	mov    %esp,%ebp
c0102f7f:	83 ec 38             	sub    $0x38,%esp
c0102f82:	8b 45 0c             	mov    0xc(%ebp),%eax
c0102f85:	88 45 e4             	mov    %al,-0x1c(%ebp)
	uint_32 sector = offset >> 9;
c0102f88:	8b 45 08             	mov    0x8(%ebp),%eax
c0102f8b:	c1 e8 09             	shr    $0x9,%eax
c0102f8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct SectorCache *ptr = cache_fetch(sector);
c0102f91:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0102f94:	89 04 24             	mov    %eax,(%esp)
c0102f97:	e8 f1 fe ff ff       	call   c0102e8d <cache_fetch>
c0102f9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr->content[offset & 511] = data;
c0102f9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0102fa2:	89 c1                	mov    %eax,%ecx
c0102fa4:	81 e1 ff 01 00 00    	and    $0x1ff,%ecx
c0102faa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102fad:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0102fb1:	88 54 08 06          	mov    %dl,0x6(%eax,%ecx,1)
	ptr->dirty = TRUE;
c0102fb5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0102fb8:	c6 40 05 01          	movb   $0x1,0x5(%eax)
}
c0102fbc:	c9                   	leave  
c0102fbd:	c3                   	ret    
c0102fbe:	90                   	nop
c0102fbf:	90                   	nop

c0102fc0 <init_drivers>:
#include "kernel.h"

void init_drivers(void) {
c0102fc0:	55                   	push   %ebp
c0102fc1:	89 e5                	mov    %esp,%ebp
c0102fc3:	83 ec 08             	sub    $0x8,%esp

	timer_driver_initialize();
c0102fc6:	e8 3f ee ff ff       	call   c0101e0a <timer_driver_initialize>
	tty_driver_initialize();
c0102fcb:	e8 5c f1 ff ff       	call   c010212c <tty_driver_initialize>
	ide_driver_initialize();
c0102fd0:	e8 2b fa ff ff       	call   c0102a00 <ide_driver_initialize>
}
c0102fd5:	c9                   	leave  
c0102fd6:	c3                   	ret    
c0102fd7:	90                   	nop

c0102fd8 <FileManagement>:

pid_t	FM;

static uint_32 do_read(uint_32 file_name, char *buffer, uint_32 offset, uint_32 length);

void FileManagement(void) {
c0102fd8:	55                   	push   %ebp
c0102fd9:	89 e5                	mov    %esp,%ebp
c0102fdb:	53                   	push   %ebx
c0102fdc:	83 ec 14             	sub    $0x14,%esp
c0102fdf:	eb 01                	jmp    c0102fe2 <FileManagement+0xa>
			m.type = -1;
			m.int_msg.p1 = read_size;
			send(m.src, &m);
			printk("send to %d\n", m.src);
		}
	}
c0102fe1:	90                   	nop

	static struct Message m;
	static uint_32 read_size;

	while (TRUE) {
		receive(ANY, &m);
c0102fe2:	c7 44 24 04 a4 72 11 	movl   $0xc01172a4,0x4(%esp)
c0102fe9:	c0 
c0102fea:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0102ff1:	e8 e2 eb ff ff       	call   c0101bd8 <receive>
		if (m.type == FM_READ)
c0102ff6:	a1 ac 72 11 c0       	mov    0xc01172ac,%eax
c0102ffb:	83 f8 0e             	cmp    $0xe,%eax
c0102ffe:	75 e1                	jne    c0102fe1 <FileManagement+0x9>
		{
			read_size = do_read(m.fm_msg.file_name, m.fm_msg.buf, m.fm_msg.offset, m.fm_msg.length);
c0103000:	8b 1d bc 72 11 c0    	mov    0xc01172bc,%ebx
c0103006:	8b 0d b8 72 11 c0    	mov    0xc01172b8,%ecx
c010300c:	8b 15 b4 72 11 c0    	mov    0xc01172b4,%edx
c0103012:	a1 b0 72 11 c0       	mov    0xc01172b0,%eax
c0103017:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
c010301b:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c010301f:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103023:	89 04 24             	mov    %eax,(%esp)
c0103026:	e8 48 00 00 00       	call   c0103073 <do_read>
c010302b:	a3 c0 72 11 c0       	mov    %eax,0xc01172c0
	//	panic("notify!\n");
			m.type = -1;
c0103030:	c7 05 ac 72 11 c0 ff 	movl   $0xffffffff,0xc01172ac
c0103037:	ff ff ff 
			m.int_msg.p1 = read_size;
c010303a:	a1 c0 72 11 c0       	mov    0xc01172c0,%eax
c010303f:	a3 b0 72 11 c0       	mov    %eax,0xc01172b0
			send(m.src, &m);
c0103044:	a1 a4 72 11 c0       	mov    0xc01172a4,%eax
c0103049:	c7 44 24 04 a4 72 11 	movl   $0xc01172a4,0x4(%esp)
c0103050:	c0 
c0103051:	89 04 24             	mov    %eax,(%esp)
c0103054:	e8 65 ea ff ff       	call   c0101abe <send>
			printk("send to %d\n", m.src);
c0103059:	a1 a4 72 11 c0       	mov    0xc01172a4,%eax
c010305e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103062:	c7 04 24 ef 3f 10 c0 	movl   $0xc0103fef,(%esp)
c0103069:	e8 7e d3 ff ff       	call   c01003ec <printk>
		}
	}
c010306e:	e9 6e ff ff ff       	jmp    c0102fe1 <FileManagement+0x9>

c0103073 <do_read>:


}

static uint_32 do_read(uint_32 file_name, char *buffer, uint_32 offset, uint_32 length) {
c0103073:	55                   	push   %ebp
c0103074:	89 e5                	mov    %esp,%ebp
c0103076:	83 ec 18             	sub    $0x18,%esp

	static struct Message m;

	m.type = DEV_READ;
c0103079:	c7 05 90 72 11 c0 0c 	movl   $0xc,0xc0117290
c0103080:	00 00 00 
	m.dev_io.pid = current_pcb -> pid;
c0103083:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0103088:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c010308e:	a3 94 72 11 c0       	mov    %eax,0xc0117294
	m.dev_io.buf = buffer;
c0103093:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103096:	a3 98 72 11 c0       	mov    %eax,0xc0117298
	m.dev_io.offset = offset + Kernel_Size + (file_name - 1) * File_Size;
c010309b:	8b 45 08             	mov    0x8(%ebp),%eax
c010309e:	c1 e0 10             	shl    $0x10,%eax
c01030a1:	03 45 10             	add    0x10(%ebp),%eax
c01030a4:	05 00 00 0f 00       	add    $0xf0000,%eax
c01030a9:	a3 9c 72 11 c0       	mov    %eax,0xc011729c
	m.dev_io.length = length;
c01030ae:	8b 45 14             	mov    0x14(%ebp),%eax
c01030b1:	a3 a0 72 11 c0       	mov    %eax,0xc01172a0

	send(IDE, &m);
c01030b6:	a1 c8 b6 1d c0       	mov    0xc01db6c8,%eax
c01030bb:	c7 44 24 04 88 72 11 	movl   $0xc0117288,0x4(%esp)
c01030c2:	c0 
c01030c3:	89 04 24             	mov    %eax,(%esp)
c01030c6:	e8 f3 e9 ff ff       	call   c0101abe <send>
	receive(IDE, &m);
c01030cb:	a1 c8 b6 1d c0       	mov    0xc01db6c8,%eax
c01030d0:	c7 44 24 04 88 72 11 	movl   $0xc0117288,0x4(%esp)
c01030d7:	c0 
c01030d8:	89 04 24             	mov    %eax,(%esp)
c01030db:	e8 f8 ea ff ff       	call   c0101bd8 <receive>

	return m.int_msg.p1;
c01030e0:	a1 94 72 11 c0       	mov    0xc0117294,%eax
}
c01030e5:	c9                   	leave  
c01030e6:	c3                   	ret    
c01030e7:	90                   	nop

c01030e8 <MemoryManagement>:

void allocate_page(struct PCB *pcb, void *start, uint_32 length);

void free_page(struct PCB *pcb, void *start, uint_32 length);

void MemoryManagement(void) {
c01030e8:	55                   	push   %ebp
c01030e9:	89 e5                	mov    %esp,%ebp
c01030eb:	83 ec 18             	sub    $0x18,%esp
c01030ee:	eb 01                	jmp    c01030f1 <MemoryManagement+0x9>
		{
			free_page(m.mm_msg.target_pcb, (void *)m.mm_msg.start, m.mm_msg.length);
			m.type = -1;
			send(m.src, &m);
		}
	}
c01030f0:	90                   	nop
void MemoryManagement(void) {

	static struct Message m;

	while (TRUE) {
		receive(ANY, &m);
c01030f1:	c7 44 24 04 c4 72 11 	movl   $0xc01172c4,0x4(%esp)
c01030f8:	c0 
c01030f9:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0103100:	e8 d3 ea ff ff       	call   c0101bd8 <receive>
		if (m.type == MM_ALLOCATE)
c0103105:	a1 cc 72 11 c0       	mov    0xc01172cc,%eax
c010310a:	83 f8 0a             	cmp    $0xa,%eax
c010310d:	75 43                	jne    c0103152 <MemoryManagement+0x6a>
		{
			allocate_page(m.mm_msg.target_pcb, (void *)m.mm_msg.start, m.mm_msg.length);
c010310f:	8b 0d d8 72 11 c0    	mov    0xc01172d8,%ecx
c0103115:	a1 d4 72 11 c0       	mov    0xc01172d4,%eax
c010311a:	89 c2                	mov    %eax,%edx
c010311c:	a1 d0 72 11 c0       	mov    0xc01172d0,%eax
c0103121:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0103125:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103129:	89 04 24             	mov    %eax,(%esp)
c010312c:	e8 50 01 00 00       	call   c0103281 <allocate_page>
			m.type = -1;
c0103131:	c7 05 cc 72 11 c0 ff 	movl   $0xffffffff,0xc01172cc
c0103138:	ff ff ff 
			send(m.src, &m);
c010313b:	a1 c4 72 11 c0       	mov    0xc01172c4,%eax
c0103140:	c7 44 24 04 c4 72 11 	movl   $0xc01172c4,0x4(%esp)
c0103147:	c0 
c0103148:	89 04 24             	mov    %eax,(%esp)
c010314b:	e8 6e e9 ff ff       	call   c0101abe <send>
		{
			free_page(m.mm_msg.target_pcb, (void *)m.mm_msg.start, m.mm_msg.length);
			m.type = -1;
			send(m.src, &m);
		}
	}
c0103150:	eb 9e                	jmp    c01030f0 <MemoryManagement+0x8>
		{
			allocate_page(m.mm_msg.target_pcb, (void *)m.mm_msg.start, m.mm_msg.length);
			m.type = -1;
			send(m.src, &m);
		}
		else if (m.type == MM_FREE)
c0103152:	a1 cc 72 11 c0       	mov    0xc01172cc,%eax
c0103157:	83 f8 0b             	cmp    $0xb,%eax
c010315a:	75 94                	jne    c01030f0 <MemoryManagement+0x8>
		{
			free_page(m.mm_msg.target_pcb, (void *)m.mm_msg.start, m.mm_msg.length);
c010315c:	8b 0d d8 72 11 c0    	mov    0xc01172d8,%ecx
c0103162:	a1 d4 72 11 c0       	mov    0xc01172d4,%eax
c0103167:	89 c2                	mov    %eax,%edx
c0103169:	a1 d0 72 11 c0       	mov    0xc01172d0,%eax
c010316e:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0103172:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103176:	89 04 24             	mov    %eax,(%esp)
c0103179:	e8 21 02 00 00       	call   c010339f <free_page>
			m.type = -1;
c010317e:	c7 05 cc 72 11 c0 ff 	movl   $0xffffffff,0xc01172cc
c0103185:	ff ff ff 
			send(m.src, &m);
c0103188:	a1 c4 72 11 c0       	mov    0xc01172c4,%eax
c010318d:	c7 44 24 04 c4 72 11 	movl   $0xc01172c4,0x4(%esp)
c0103194:	c0 
c0103195:	89 04 24             	mov    %eax,(%esp)
c0103198:	e8 21 e9 ff ff       	call   c0101abe <send>
		}
	}
c010319d:	e9 4e ff ff ff       	jmp    c01030f0 <MemoryManagement+0x8>

c01031a2 <init_mm>:

}

void init_mm(void) {
c01031a2:	55                   	push   %ebp
c01031a3:	89 e5                	mov    %esp,%ebp
c01031a5:	83 ec 10             	sub    $0x10,%esp
	int i;
	for (i = 0; i < NR_PPAGE_ENTRY; ++ i)
c01031a8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c01031af:	eb 0f                	jmp    c01031c0 <init_mm+0x1e>
		Ppage_flag[i] = TRUE;
c01031b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c01031b4:	05 00 b7 1d c0       	add    $0xc01db700,%eax
c01031b9:	c6 00 01             	movb   $0x1,(%eax)

}

void init_mm(void) {
	int i;
	for (i = 0; i < NR_PPAGE_ENTRY; ++ i)
c01031bc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c01031c0:	81 7d fc ff 6f 00 00 	cmpl   $0x6fff,-0x4(%ebp)
c01031c7:	7e e8                	jle    c01031b1 <init_mm+0xf>
		Ppage_flag[i] = TRUE;

}
c01031c9:	c9                   	leave  
c01031ca:	c3                   	ret    

c01031cb <id_to_pa>:


//return Physical Address
static inline uint_32 id_to_pa(uint_32 id) {
c01031cb:	55                   	push   %ebp
c01031cc:	89 e5                	mov    %esp,%ebp
	return (USER_MEM_LOW + id * PAGE_SIZE);
c01031ce:	8b 45 08             	mov    0x8(%ebp),%eax
c01031d1:	05 00 10 00 00       	add    $0x1000,%eax
c01031d6:	c1 e0 0c             	shl    $0xc,%eax
}
c01031d9:	5d                   	pop    %ebp
c01031da:	c3                   	ret    

c01031db <pa_to_id>:


//Physical Address to Physical Memory Flag ID
static inline uint_32 pa_to_id(uint_32 pa) {
c01031db:	55                   	push   %ebp
c01031dc:	89 e5                	mov    %esp,%ebp
	return ((pa - USER_MEM_LOW) / PAGE_SIZE);
c01031de:	8b 45 08             	mov    0x8(%ebp),%eax
c01031e1:	2d 00 00 00 01       	sub    $0x1000000,%eax
c01031e6:	c1 e8 0c             	shr    $0xc,%eax
}
c01031e9:	5d                   	pop    %ebp
c01031ea:	c3                   	ret    

c01031eb <allocate_memory>:


//allocate physical memory, exclude kernel space, 16MB --> 128MB
//need better algorithm!
static inline void * allocate_memory(void) {
c01031eb:	55                   	push   %ebp
c01031ec:	89 e5                	mov    %esp,%ebp
c01031ee:	83 ec 28             	sub    $0x28,%esp
	int i;
	for (i = 0; i < NR_PPAGE_ENTRY; ++ i)
c01031f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c01031f8:	eb 2b                	jmp    c0103225 <allocate_memory+0x3a>
		if (Ppage_flag[i] == TRUE)
c01031fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01031fd:	05 00 b7 1d c0       	add    $0xc01db700,%eax
c0103202:	0f b6 00             	movzbl (%eax),%eax
c0103205:	3c 01                	cmp    $0x1,%al
c0103207:	75 18                	jne    c0103221 <allocate_memory+0x36>
		{
			Ppage_flag[i] = FALSE;
c0103209:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010320c:	05 00 b7 1d c0       	add    $0xc01db700,%eax
c0103211:	c6 00 00             	movb   $0x0,(%eax)
			return (void *)id_to_pa(i);
c0103214:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103217:	89 04 24             	mov    %eax,(%esp)
c010321a:	e8 ac ff ff ff       	call   c01031cb <id_to_pa>
c010321f:	eb 1e                	jmp    c010323f <allocate_memory+0x54>

//allocate physical memory, exclude kernel space, 16MB --> 128MB
//need better algorithm!
static inline void * allocate_memory(void) {
	int i;
	for (i = 0; i < NR_PPAGE_ENTRY; ++ i)
c0103221:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0103225:	81 7d f4 ff 6f 00 00 	cmpl   $0x6fff,-0xc(%ebp)
c010322c:	7e cc                	jle    c01031fa <allocate_memory+0xf>
		if (Ppage_flag[i] == TRUE)
		{
			Ppage_flag[i] = FALSE;
			return (void *)id_to_pa(i);
		}
	panic("Physical Page is full!\n");
c010322e:	c7 04 24 fc 3f 10 c0 	movl   $0xc0103ffc,(%esp)
c0103235:	e8 da d1 ff ff       	call   c0100414 <panic>
	return (void *)0;	//just for compile
c010323a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c010323f:	c9                   	leave  
c0103240:	c3                   	ret    

c0103241 <free_memory>:

//free physical memory
//need better algorithm!
static inline void free_memory(void *addr) {
c0103241:	55                   	push   %ebp
c0103242:	89 e5                	mov    %esp,%ebp
c0103244:	83 ec 04             	sub    $0x4,%esp
	Ppage_flag[pa_to_id((uint_32)addr)] = TRUE;
c0103247:	8b 45 08             	mov    0x8(%ebp),%eax
c010324a:	89 04 24             	mov    %eax,(%esp)
c010324d:	e8 89 ff ff ff       	call   c01031db <pa_to_id>
c0103252:	c6 80 00 b7 1d c0 01 	movb   $0x1,-0x3fe24900(%eax)
}
c0103259:	c9                   	leave  
c010325a:	c3                   	ret    

c010325b <Page_Directory_Fault>:


static inline boolean Page_Directory_Fault(struct PageDirectoryEntry *ptr) {
c010325b:	55                   	push   %ebp
c010325c:	89 e5                	mov    %esp,%ebp
	return ((ptr -> present == 0) ? TRUE : FALSE);
c010325e:	8b 45 08             	mov    0x8(%ebp),%eax
c0103261:	0f b6 00             	movzbl (%eax),%eax
c0103264:	83 e0 01             	and    $0x1,%eax
c0103267:	84 c0                	test   %al,%al
c0103269:	0f 94 c0             	sete   %al
}
c010326c:	5d                   	pop    %ebp
c010326d:	c3                   	ret    

c010326e <Page_Table_Fault>:


static inline boolean Page_Table_Fault(struct PageTableEntry *ptr) {
c010326e:	55                   	push   %ebp
c010326f:	89 e5                	mov    %esp,%ebp
	return ((ptr -> present == 0) ? TRUE : FALSE);
c0103271:	8b 45 08             	mov    0x8(%ebp),%eax
c0103274:	0f b6 00             	movzbl (%eax),%eax
c0103277:	83 e0 01             	and    $0x1,%eax
c010327a:	84 c0                	test   %al,%al
c010327c:	0f 94 c0             	sete   %al
}
c010327f:	5d                   	pop    %ebp
c0103280:	c3                   	ret    

c0103281 <allocate_page>:


//length:	unit = 4KB
void allocate_page(struct PCB *pcb, void *start, uint_32 length) {
c0103281:	55                   	push   %ebp
c0103282:	89 e5                	mov    %esp,%ebp
c0103284:	83 ec 38             	sub    $0x38,%esp
	*/
	
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent, *init_ptr;

	uint_32 pde = ((uint_32)start) >> 22;
c0103287:	8b 45 0c             	mov    0xc(%ebp),%eax
c010328a:	c1 e8 16             	shr    $0x16,%eax
c010328d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint_32 pte = (((uint_32)start) >> 12) & 0x3FF;
c0103290:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103293:	c1 e8 0c             	shr    $0xc,%eax
c0103296:	25 ff 03 00 00       	and    $0x3ff,%eax
c010329b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	pdir = (struct PageDirectoryEntry *)(pcb -> pagedir);
c010329e:	8b 45 08             	mov    0x8(%ebp),%eax
c01032a1:	05 00 40 00 00       	add    $0x4000,%eax
c01032a6:	89 45 e0             	mov    %eax,-0x20(%ebp)

	void				*addr;

	int i;
	
	while (length != 0)
c01032a9:	e9 e5 00 00 00       	jmp    c0103393 <allocate_page+0x112>
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
c01032ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01032b1:	c1 e0 02             	shl    $0x2,%eax
c01032b4:	03 45 e0             	add    -0x20(%ebp),%eax
c01032b7:	89 04 24             	mov    %eax,(%esp)
c01032ba:	e8 9c ff ff ff       	call   c010325b <Page_Directory_Fault>
c01032bf:	3c 01                	cmp    $0x1,%al
c01032c1:	75 53                	jne    c0103316 <allocate_page+0x95>
		{
			addr = allocate_memory();
c01032c3:	e8 23 ff ff ff       	call   c01031eb <allocate_memory>
c01032c8:	89 45 dc             	mov    %eax,-0x24(%ebp)
			make_pde(pdir + pde, addr);
c01032cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c01032ce:	c1 e0 02             	shl    $0x2,%eax
c01032d1:	03 45 e0             	add    -0x20(%ebp),%eax
c01032d4:	8b 55 dc             	mov    -0x24(%ebp),%edx
c01032d7:	89 54 24 04          	mov    %edx,0x4(%esp)
c01032db:	89 04 24             	mov    %eax,(%esp)
c01032de:	e8 59 d6 ff ff       	call   c010093c <make_pde>
			pent = (struct PageTableEntry *)addr;
c01032e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
c01032e6:	89 45 f4             	mov    %eax,-0xc(%ebp)

			init_ptr = pent;
c01032e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01032ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (i = 0; i < NR_PTE_ENTRY; ++ i)
c01032ef:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c01032f6:	eb 13                	jmp    c010330b <allocate_page+0x8a>
			{
				make_invalid_pte(init_ptr);
c01032f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01032fb:	89 04 24             	mov    %eax,(%esp)
c01032fe:	e8 2b d6 ff ff       	call   c010092e <make_invalid_pte>
				++ init_ptr;
c0103303:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
			addr = allocate_memory();
			make_pde(pdir + pde, addr);
			pent = (struct PageTableEntry *)addr;

			init_ptr = pent;
			for (i = 0; i < NR_PTE_ENTRY; ++ i)
c0103307:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c010330b:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
c0103312:	7e e4                	jle    c01032f8 <allocate_page+0x77>
c0103314:	eb 14                	jmp    c010332a <allocate_page+0xa9>
				make_invalid_pte(init_ptr);
				++ init_ptr;
			}
		}
		else
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
c0103316:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0103319:	c1 e0 02             	shl    $0x2,%eax
c010331c:	03 45 e0             	add    -0x20(%ebp),%eax
c010331f:	8b 00                	mov    (%eax),%eax
c0103321:	c1 e8 0c             	shr    $0xc,%eax
c0103324:	c1 e0 0c             	shl    $0xc,%eax
c0103327:	89 45 f4             	mov    %eax,-0xc(%ebp)
		
		pent = pent + pte;
c010332a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010332d:	c1 e0 02             	shl    $0x2,%eax
c0103330:	01 45 f4             	add    %eax,-0xc(%ebp)

		for (i = pte; i < NR_PTE_ENTRY; ++ i)
c0103333:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103336:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0103339:	eb 41                	jmp    c010337c <allocate_page+0xfb>
		{
			if (Page_Table_Fault(pent) == FALSE)
c010333b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010333e:	89 04 24             	mov    %eax,(%esp)
c0103341:	e8 28 ff ff ff       	call   c010326e <Page_Table_Fault>
c0103346:	84 c0                	test   %al,%al
c0103348:	75 0c                	jne    c0103356 <allocate_page+0xd5>
				panic("Virtual Page Overlap!\n");
c010334a:	c7 04 24 14 40 10 c0 	movl   $0xc0104014,(%esp)
c0103351:	e8 be d0 ff ff       	call   c0100414 <panic>

			make_pte(pent, allocate_memory());
c0103356:	e8 90 fe ff ff       	call   c01031eb <allocate_memory>
c010335b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010335f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103362:	89 04 24             	mov    %eax,(%esp)
c0103365:	e8 23 d6 ff ff       	call   c010098d <make_pte>
			-- length;
c010336a:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
			if (length == 0) break;
c010336e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0103372:	74 13                	je     c0103387 <allocate_page+0x106>
			++ pent;
c0103374:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
		else
			pent = (struct PageTableEntry *)(((pdir + pde) -> page_frame) << 12);
		
		pent = pent + pte;

		for (i = pte; i < NR_PTE_ENTRY; ++ i)
c0103378:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c010337c:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
c0103383:	7e b6                	jle    c010333b <allocate_page+0xba>
c0103385:	eb 01                	jmp    c0103388 <allocate_page+0x107>
			if (Page_Table_Fault(pent) == FALSE)
				panic("Virtual Page Overlap!\n");

			make_pte(pent, allocate_memory());
			-- length;
			if (length == 0) break;
c0103387:	90                   	nop
			++ pent;
		}
		++ pde;
c0103388:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
		pte = 0;
c010338c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	void				*addr;

	int i;
	
	while (length != 0)
c0103393:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0103397:	0f 85 11 ff ff ff    	jne    c01032ae <allocate_page+0x2d>
		}
		++ pde;
		pte = 0;
	}
	
}
c010339d:	c9                   	leave  
c010339e:	c3                   	ret    

c010339f <free_page>:


//length:	unit = 4KB
void free_page(struct PCB *pcb, void *start, uint_32 length) {
c010339f:	55                   	push   %ebp
c01033a0:	89 e5                	mov    %esp,%ebp
c01033a2:	83 ec 38             	sub    $0x38,%esp
	*/
	
	struct PageDirectoryEntry	*pdir;
	struct PageTableEntry		*pent;

	uint_32 pde = ((uint_32)start) >> 22;
c01033a5:	8b 45 0c             	mov    0xc(%ebp),%eax
c01033a8:	c1 e8 16             	shr    $0x16,%eax
c01033ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint_32 pte = (((uint_32)start) >> 12) & 0x3FF;
c01033ae:	8b 45 0c             	mov    0xc(%ebp),%eax
c01033b1:	c1 e8 0c             	shr    $0xc,%eax
c01033b4:	25 ff 03 00 00       	and    $0x3ff,%eax
c01033b9:	89 45 f0             	mov    %eax,-0x10(%ebp)

	pdir = (struct PageDirectoryEntry *)(pcb -> pagedir);
c01033bc:	8b 45 08             	mov    0x8(%ebp),%eax
c01033bf:	05 00 40 00 00       	add    $0x4000,%eax
c01033c4:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	boolean clean_pd;
	int i;
	
	while (length != 0)
c01033c7:	e9 3b 01 00 00       	jmp    c0103507 <free_page+0x168>
	{
		if (Page_Directory_Fault(pdir + pde) == TRUE)
c01033cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01033cf:	c1 e0 02             	shl    $0x2,%eax
c01033d2:	03 45 e4             	add    -0x1c(%ebp),%eax
c01033d5:	89 04 24             	mov    %eax,(%esp)
c01033d8:	e8 7e fe ff ff       	call   c010325b <Page_Directory_Fault>
c01033dd:	3c 01                	cmp    $0x1,%al
c01033df:	75 0c                	jne    c01033ed <free_page+0x4e>
			panic("Free Unused Page!\n");
c01033e1:	c7 04 24 2b 40 10 c0 	movl   $0xc010402b,(%esp)
c01033e8:	e8 27 d0 ff ff       	call   c0100414 <panic>
		pent = (struct PageTableEntry *)((pdir + pde) -> page_frame << 12);
c01033ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01033f0:	c1 e0 02             	shl    $0x2,%eax
c01033f3:	03 45 e4             	add    -0x1c(%ebp),%eax
c01033f6:	8b 00                	mov    (%eax),%eax
c01033f8:	c1 e8 0c             	shr    $0xc,%eax
c01033fb:	c1 e0 0c             	shl    $0xc,%eax
c01033fe:	89 45 e0             	mov    %eax,-0x20(%ebp)

		clean_pd = TRUE;
c0103401:	c6 45 ef 01          	movb   $0x1,-0x11(%ebp)
		for (i = 0; i < pte; ++ i)
c0103405:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c010340c:	eb 1f                	jmp    c010342d <free_page+0x8e>
			if (Page_Table_Fault(pent + i) == FALSE)
c010340e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103411:	c1 e0 02             	shl    $0x2,%eax
c0103414:	03 45 e0             	add    -0x20(%ebp),%eax
c0103417:	89 04 24             	mov    %eax,(%esp)
c010341a:	e8 4f fe ff ff       	call   c010326e <Page_Table_Fault>
c010341f:	84 c0                	test   %al,%al
c0103421:	75 06                	jne    c0103429 <free_page+0x8a>
			{
				clean_pd = FALSE;
c0103423:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
				break;
c0103427:	eb 0c                	jmp    c0103435 <free_page+0x96>
		if (Page_Directory_Fault(pdir + pde) == TRUE)
			panic("Free Unused Page!\n");
		pent = (struct PageTableEntry *)((pdir + pde) -> page_frame << 12);

		clean_pd = TRUE;
		for (i = 0; i < pte; ++ i)
c0103429:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c010342d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103430:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0103433:	72 d9                	jb     c010340e <free_page+0x6f>
				clean_pd = FALSE;
				break;
			}


		for (i = pte; i < NR_PTE_ENTRY; ++ i)
c0103435:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103438:	89 45 e8             	mov    %eax,-0x18(%ebp)
c010343b:	eb 59                	jmp    c0103496 <free_page+0xf7>
		{
			if (Page_Table_Fault(pent + i) == TRUE)
c010343d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103440:	c1 e0 02             	shl    $0x2,%eax
c0103443:	03 45 e0             	add    -0x20(%ebp),%eax
c0103446:	89 04 24             	mov    %eax,(%esp)
c0103449:	e8 20 fe ff ff       	call   c010326e <Page_Table_Fault>
c010344e:	3c 01                	cmp    $0x1,%al
c0103450:	75 0c                	jne    c010345e <free_page+0xbf>
				panic("Free Unused Page!\n");
c0103452:	c7 04 24 2b 40 10 c0 	movl   $0xc010402b,(%esp)
c0103459:	e8 b6 cf ff ff       	call   c0100414 <panic>
			free_memory((void *)((pent + i) -> page_frame << 12));
c010345e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103461:	c1 e0 02             	shl    $0x2,%eax
c0103464:	03 45 e0             	add    -0x20(%ebp),%eax
c0103467:	8b 00                	mov    (%eax),%eax
c0103469:	c1 e8 0c             	shr    $0xc,%eax
c010346c:	c1 e0 0c             	shl    $0xc,%eax
c010346f:	89 04 24             	mov    %eax,(%esp)
c0103472:	e8 ca fd ff ff       	call   c0103241 <free_memory>
			make_invalid_pte(pent + i);
c0103477:	8b 45 e8             	mov    -0x18(%ebp),%eax
c010347a:	c1 e0 02             	shl    $0x2,%eax
c010347d:	03 45 e0             	add    -0x20(%ebp),%eax
c0103480:	89 04 24             	mov    %eax,(%esp)
c0103483:	e8 a6 d4 ff ff       	call   c010092e <make_invalid_pte>
			-- length;
c0103488:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
			if (length == 0) break;
c010348c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0103490:	74 0f                	je     c01034a1 <free_page+0x102>
				clean_pd = FALSE;
				break;
			}


		for (i = pte; i < NR_PTE_ENTRY; ++ i)
c0103492:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c0103496:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
c010349d:	7e 9e                	jle    c010343d <free_page+0x9e>
			-- length;
			if (length == 0) break;
		}
		

		for ( ; i < NR_PTE_ENTRY; ++ i)
c010349f:	eb 22                	jmp    c01034c3 <free_page+0x124>
			if (Page_Table_Fault(pent + i) == TRUE)
				panic("Free Unused Page!\n");
			free_memory((void *)((pent + i) -> page_frame << 12));
			make_invalid_pte(pent + i);
			-- length;
			if (length == 0) break;
c01034a1:	90                   	nop
		}
		

		for ( ; i < NR_PTE_ENTRY; ++ i)
c01034a2:	eb 1f                	jmp    c01034c3 <free_page+0x124>
			if (Page_Table_Fault(pent + i) == FALSE)
c01034a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01034a7:	c1 e0 02             	shl    $0x2,%eax
c01034aa:	03 45 e0             	add    -0x20(%ebp),%eax
c01034ad:	89 04 24             	mov    %eax,(%esp)
c01034b0:	e8 b9 fd ff ff       	call   c010326e <Page_Table_Fault>
c01034b5:	84 c0                	test   %al,%al
c01034b7:	75 06                	jne    c01034bf <free_page+0x120>
			{
				clean_pd = FALSE;
c01034b9:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
				break;
c01034bd:	eb 0d                	jmp    c01034cc <free_page+0x12d>
			-- length;
			if (length == 0) break;
		}
		

		for ( ; i < NR_PTE_ENTRY; ++ i)
c01034bf:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
c01034c3:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
c01034ca:	7e d8                	jle    c01034a4 <free_page+0x105>
				clean_pd = FALSE;
				break;
			}


		if (clean_pd == TRUE)
c01034cc:	80 7d ef 01          	cmpb   $0x1,-0x11(%ebp)
c01034d0:	75 2a                	jne    c01034fc <free_page+0x15d>
		{
			free_memory((void *)((pdir + pde) -> page_frame << 12));
c01034d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01034d5:	c1 e0 02             	shl    $0x2,%eax
c01034d8:	03 45 e4             	add    -0x1c(%ebp),%eax
c01034db:	8b 00                	mov    (%eax),%eax
c01034dd:	c1 e8 0c             	shr    $0xc,%eax
c01034e0:	c1 e0 0c             	shl    $0xc,%eax
c01034e3:	89 04 24             	mov    %eax,(%esp)
c01034e6:	e8 56 fd ff ff       	call   c0103241 <free_memory>
			make_invalid_pde(pdir + pde);
c01034eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01034ee:	c1 e0 02             	shl    $0x2,%eax
c01034f1:	03 45 e4             	add    -0x1c(%ebp),%eax
c01034f4:	89 04 24             	mov    %eax,(%esp)
c01034f7:	e8 24 d4 ff ff       	call   c0100920 <make_invalid_pde>
		}

		++ pde;
c01034fc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
		pte = 0;
c0103500:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	pdir = (struct PageDirectoryEntry *)(pcb -> pagedir);

	boolean clean_pd;
	int i;
	
	while (length != 0)
c0103507:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c010350b:	0f 85 bb fe ff ff    	jne    c01033cc <free_page+0x2d>

		++ pde;
		pte = 0;
	}
	
}
c0103511:	c9                   	leave  
c0103512:	c3                   	ret    

c0103513 <init_user_page>:



void init_user_page(struct PCB *pcb) {
c0103513:	55                   	push   %ebp
c0103514:	89 e5                	mov    %esp,%ebp
c0103516:	83 ec 38             	sub    $0x38,%esp

	void				*addr;

//	uint_32				PT_offset;

	printk("enter init_user_page\n");
c0103519:	c7 04 24 3e 40 10 c0 	movl   $0xc010403e,(%esp)
c0103520:	e8 c7 ce ff ff       	call   c01003ec <printk>

	pdir = (struct PageDirectoryEntry *)(pcb -> pagedir);
c0103525:	8b 45 08             	mov    0x8(%ebp),%eax
c0103528:	05 00 40 00 00       	add    $0x4000,%eax
c010352d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	//PT_offset = (uint_32)va_to_pa(pcb -> pagetable);

	int i, j;

	//initialize page table
	for (i = 0; i < NR_PDE_ENTRY; ++ i)
c0103530:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0103537:	eb 15                	jmp    c010354e <init_user_page+0x3b>
		make_invalid_pde(pdir + i);
c0103539:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010353c:	c1 e0 02             	shl    $0x2,%eax
c010353f:	03 45 e8             	add    -0x18(%ebp),%eax
c0103542:	89 04 24             	mov    %eax,(%esp)
c0103545:	e8 d6 d3 ff ff       	call   c0100920 <make_invalid_pde>
	//PT_offset = (uint_32)va_to_pa(pcb -> pagetable);

	int i, j;

	//initialize page table
	for (i = 0; i < NR_PDE_ENTRY; ++ i)
c010354a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c010354e:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
c0103555:	7e e2                	jle    c0103539 <init_user_page+0x26>
		make_invalid_pde(pdir + i);

	printk("initialize page table.................Successful!\n");
c0103557:	c7 04 24 54 40 10 c0 	movl   $0xc0104054,(%esp)
c010355e:	e8 89 ce ff ff       	call   c01003ec <printk>
	//for kernel space
	for (i = 0; i < USER_MEM_LOW / PD_SIZE; ++ i)
c0103563:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c010356a:	eb 64                	jmp    c01035d0 <init_user_page+0xbd>
	{
		addr = allocate_memory();
c010356c:	e8 7a fc ff ff       	call   c01031eb <allocate_memory>
c0103571:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		make_pde(pdir + (i + KOFFSET / PD_SIZE), addr);
c0103574:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103577:	05 00 03 00 00       	add    $0x300,%eax
c010357c:	c1 e0 02             	shl    $0x2,%eax
c010357f:	03 45 e8             	add    -0x18(%ebp),%eax
c0103582:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0103585:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103589:	89 04 24             	mov    %eax,(%esp)
c010358c:	e8 ab d3 ff ff       	call   c010093c <make_pde>
		pent = (struct PageTableEntry *)addr;
c0103591:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103594:	89 45 f4             	mov    %eax,-0xc(%ebp)
		for (j = 0; j < NR_PTE_ENTRY; ++ j)
c0103597:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c010359e:	eb 23                	jmp    c01035c3 <init_user_page+0xb0>
		{
			make_pte(pent, (void *)((i * NR_PTE_ENTRY + j) << 12));
c01035a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01035a3:	c1 e0 0a             	shl    $0xa,%eax
c01035a6:	03 45 ec             	add    -0x14(%ebp),%eax
c01035a9:	c1 e0 0c             	shl    $0xc,%eax
c01035ac:	89 44 24 04          	mov    %eax,0x4(%esp)
c01035b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01035b3:	89 04 24             	mov    %eax,(%esp)
c01035b6:	e8 d2 d3 ff ff       	call   c010098d <make_pte>
			++ pent;
c01035bb:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
	for (i = 0; i < USER_MEM_LOW / PD_SIZE; ++ i)
	{
		addr = allocate_memory();
		make_pde(pdir + (i + KOFFSET / PD_SIZE), addr);
		pent = (struct PageTableEntry *)addr;
		for (j = 0; j < NR_PTE_ENTRY; ++ j)
c01035bf:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c01035c3:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
c01035ca:	7e d4                	jle    c01035a0 <init_user_page+0x8d>
	for (i = 0; i < NR_PDE_ENTRY; ++ i)
		make_invalid_pde(pdir + i);

	printk("initialize page table.................Successful!\n");
	//for kernel space
	for (i = 0; i < USER_MEM_LOW / PD_SIZE; ++ i)
c01035cc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c01035d0:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
c01035d4:	7e 96                	jle    c010356c <init_user_page+0x59>
			make_pte(pent, (void *)((i * NR_PTE_ENTRY + j) << 12));
			++ pent;
		}
	}

	printk("set kernel space page table...............Successful\n");
c01035d6:	c7 04 24 88 40 10 c0 	movl   $0xc0104088,(%esp)
c01035dd:	e8 0a ce ff ff       	call   c01003ec <printk>

	//for user space
	
	//allocate a user stack, below 0xC0000000, 4KB
	allocate_page(pcb, (void *)0xC0000000 - 1, 1);
c01035e2:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c01035e9:	00 
c01035ea:	c7 44 24 04 ff ff ff 	movl   $0xbfffffff,0x4(%esp)
c01035f1:	bf 
c01035f2:	8b 45 08             	mov    0x8(%ebp),%eax
c01035f5:	89 04 24             	mov    %eax,(%esp)
c01035f8:	e8 84 fc ff ff       	call   c0103281 <allocate_page>
	
	printk("set user stack page table...............Successful\n");
c01035fd:	c7 04 24 c0 40 10 c0 	movl   $0xc01040c0,(%esp)
c0103604:	e8 e3 cd ff ff       	call   c01003ec <printk>

	*(uint_32*)&(pcb -> cr3) = 0;
c0103609:	8b 45 08             	mov    0x8(%ebp),%eax
c010360c:	83 c0 08             	add    $0x8,%eax
c010360f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(pcb -> cr3).page_directory_base = ((uint_32)va_to_pa(pdir)) >> 12;
c0103615:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103618:	05 00 00 00 40       	add    $0x40000000,%eax
c010361d:	c1 e8 0c             	shr    $0xc,%eax
c0103620:	89 c2                	mov    %eax,%edx
c0103622:	81 e2 ff ff 0f 00    	and    $0xfffff,%edx
c0103628:	8b 45 08             	mov    0x8(%ebp),%eax
c010362b:	89 d1                	mov    %edx,%ecx
c010362d:	c1 e1 0c             	shl    $0xc,%ecx
c0103630:	8b 50 08             	mov    0x8(%eax),%edx
c0103633:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0103639:	09 ca                	or     %ecx,%edx
c010363b:	89 50 08             	mov    %edx,0x8(%eax)
	printk("set CR3 register...............Successful\n");
c010363e:	c7 04 24 f4 40 10 c0 	movl   $0xc01040f4,(%esp)
c0103645:	e8 a2 cd ff ff       	call   c01003ec <printk>
	printk("exit init_user_page..............Successful\n");
c010364a:	c7 04 24 20 41 10 c0 	movl   $0xc0104120,(%esp)
c0103651:	e8 96 cd ff ff       	call   c01003ec <printk>
}
c0103656:	c9                   	leave  
c0103657:	c3                   	ret    

c0103658 <load_init_proc>:
#include "kernel.h"

pid_t	PM;

void load_init_proc(uint_32 file_name, struct PCB *pcb) {
c0103658:	55                   	push   %ebp
c0103659:	89 e5                	mov    %esp,%ebp
c010365b:	81 ec 08 21 00 00    	sub    $0x2108,%esp
	struct ELFHeader *elf;
	struct ProgramHeader *ph, *eph;

	uint_32	va;

	printk("enter load_init_proc ...........Successful\n");
c0103661:	c7 04 24 50 41 10 c0 	movl   $0xc0104150,(%esp)
c0103668:	e8 7f cd ff ff       	call   c01003ec <printk>
	printk("send FM read request ...........Successful\n");
c010366d:	c7 04 24 7c 41 10 c0 	movl   $0xc010417c,(%esp)
c0103674:	e8 73 cd ff ff       	call   c01003ec <printk>
	m.type = FM_READ;
c0103679:	c7 05 04 73 11 c0 0e 	movl   $0xe,0xc0117304
c0103680:	00 00 00 
	m.fm_msg.file_name = file_name;
c0103683:	8b 45 08             	mov    0x8(%ebp),%eax
c0103686:	a3 08 73 11 c0       	mov    %eax,0xc0117308
	m.fm_msg.buf = buf;
c010368b:	8d 85 78 ef ff ff    	lea    -0x1088(%ebp),%eax
c0103691:	a3 0c 73 11 c0       	mov    %eax,0xc011730c
	m.fm_msg.offset = 0;
c0103696:	c7 05 10 73 11 c0 00 	movl   $0x0,0xc0117310
c010369d:	00 00 00 
	m.fm_msg.length = 4096;
c01036a0:	c7 05 14 73 11 c0 00 	movl   $0x1000,0xc0117314
c01036a7:	10 00 00 

	send(FM, &m);
c01036aa:	a1 cc b6 1d c0       	mov    0xc01db6cc,%eax
c01036af:	c7 44 24 04 fc 72 11 	movl   $0xc01172fc,0x4(%esp)
c01036b6:	c0 
c01036b7:	89 04 24             	mov    %eax,(%esp)
c01036ba:	e8 ff e3 ff ff       	call   c0101abe <send>
	receive(FM, &m);
c01036bf:	a1 cc b6 1d c0       	mov    0xc01db6cc,%eax
c01036c4:	c7 44 24 04 fc 72 11 	movl   $0xc01172fc,0x4(%esp)
c01036cb:	c0 
c01036cc:	89 04 24             	mov    %eax,(%esp)
c01036cf:	e8 04 e5 ff ff       	call   c0101bd8 <receive>
	printk("received ...........Successful\n");
c01036d4:	c7 04 24 a8 41 10 c0 	movl   $0xc01041a8,(%esp)
c01036db:	e8 0c cd ff ff       	call   c01003ec <printk>
	//panic("sb\n");
 
	printk("Read ELF header\n"); 
c01036e0:	c7 04 24 c8 41 10 c0 	movl   $0xc01041c8,(%esp)
c01036e7:	e8 00 cd ff ff       	call   c01003ec <printk>
	elf = (struct ELFHeader *)buf;
c01036ec:	8d 85 78 ef ff ff    	lea    -0x1088(%ebp),%eax
c01036f2:	89 45 e8             	mov    %eax,-0x18(%ebp)

	ph = (struct ProgramHeader *)((char *)elf + elf -> phoff);
c01036f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c01036f8:	8b 40 1c             	mov    0x1c(%eax),%eax
c01036fb:	03 45 e8             	add    -0x18(%ebp),%eax
c01036fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
	eph = ph + elf -> phnum;
c0103701:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103704:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
c0103708:	0f b7 c0             	movzwl %ax,%eax
c010370b:	c1 e0 05             	shl    $0x5,%eax
c010370e:	03 45 f4             	add    -0xc(%ebp),%eax
c0103711:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	printk("begin %x, end %x\n", ph, eph);
c0103714:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103717:	89 44 24 08          	mov    %eax,0x8(%esp)
c010371b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010371e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103722:	c7 04 24 d9 41 10 c0 	movl   $0xc01041d9,(%esp)
c0103729:	e8 be cc ff ff       	call   c01003ec <printk>
	for (; ph < eph; ++ ph) {
c010372e:	e9 88 01 00 00       	jmp    c01038bb <load_init_proc+0x263>
		printk("****************************\n");
c0103733:	c7 04 24 eb 41 10 c0 	movl   $0xc01041eb,(%esp)
c010373a:	e8 ad cc ff ff       	call   c01003ec <printk>
		printk("current: %x\n", ph);
c010373f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103742:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103746:	c7 04 24 09 42 10 c0 	movl   $0xc0104209,(%esp)
c010374d:	e8 9a cc ff ff       	call   c01003ec <printk>
		va = (uint_32)ph -> vaddr;
c0103752:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103755:	8b 40 08             	mov    0x8(%eax),%eax
c0103758:	89 45 e0             	mov    %eax,-0x20(%ebp)

		printk("virtual address: %x\n", va);
c010375b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010375e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103762:	c7 04 24 16 42 10 c0 	movl   $0xc0104216,(%esp)
c0103769:	e8 7e cc ff ff       	call   c01003ec <printk>
		m.type = FM_READ;
c010376e:	c7 05 04 73 11 c0 0e 	movl   $0xe,0xc0117304
c0103775:	00 00 00 
		m.fm_msg.file_name = file_name;
c0103778:	8b 45 08             	mov    0x8(%ebp),%eax
c010377b:	a3 08 73 11 c0       	mov    %eax,0xc0117308
		m.fm_msg.buf = segment_buf;
c0103780:	8d 85 10 df ff ff    	lea    -0x20f0(%ebp),%eax
c0103786:	a3 0c 73 11 c0       	mov    %eax,0xc011730c
		m.fm_msg.offset = ph -> off;
c010378b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010378e:	8b 40 04             	mov    0x4(%eax),%eax
c0103791:	a3 10 73 11 c0       	mov    %eax,0xc0117310
		m.fm_msg.length = ph -> filesz;
c0103796:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103799:	8b 40 10             	mov    0x10(%eax),%eax
c010379c:	a3 14 73 11 c0       	mov    %eax,0xc0117314

		printk("send FM read request, file name = %d, offset = %d, length = %d\n", file_name, ph -> off, ph -> filesz);
c01037a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01037a4:	8b 50 10             	mov    0x10(%eax),%edx
c01037a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01037aa:	8b 40 04             	mov    0x4(%eax),%eax
c01037ad:	89 54 24 0c          	mov    %edx,0xc(%esp)
c01037b1:	89 44 24 08          	mov    %eax,0x8(%esp)
c01037b5:	8b 45 08             	mov    0x8(%ebp),%eax
c01037b8:	89 44 24 04          	mov    %eax,0x4(%esp)
c01037bc:	c7 04 24 2c 42 10 c0 	movl   $0xc010422c,(%esp)
c01037c3:	e8 24 cc ff ff       	call   c01003ec <printk>
		send(FM, &m);
c01037c8:	a1 cc b6 1d c0       	mov    0xc01db6cc,%eax
c01037cd:	c7 44 24 04 fc 72 11 	movl   $0xc01172fc,0x4(%esp)
c01037d4:	c0 
c01037d5:	89 04 24             	mov    %eax,(%esp)
c01037d8:	e8 e1 e2 ff ff       	call   c0101abe <send>
		receive(FM, &m);
c01037dd:	a1 cc b6 1d c0       	mov    0xc01db6cc,%eax
c01037e2:	c7 44 24 04 fc 72 11 	movl   $0xc01172fc,0x4(%esp)
c01037e9:	c0 
c01037ea:	89 04 24             	mov    %eax,(%esp)
c01037ed:	e8 e6 e3 ff ff       	call   c0101bd8 <receive>

		printk("received from FM ...........Successful\n");
c01037f2:	c7 04 24 6c 42 10 c0 	movl   $0xc010426c,(%esp)
c01037f9:	e8 ee cb ff ff       	call   c01003ec <printk>

		m.type = MM_ALLOCATE;
c01037fe:	c7 05 04 73 11 c0 0a 	movl   $0xa,0xc0117304
c0103805:	00 00 00 
		m.mm_msg.target_pcb = pcb;
c0103808:	8b 45 0c             	mov    0xc(%ebp),%eax
c010380b:	a3 08 73 11 c0       	mov    %eax,0xc0117308
		m.mm_msg.start = va;
c0103810:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0103813:	a3 0c 73 11 c0       	mov    %eax,0xc011730c
		m.mm_msg.length = ph -> memsz;
c0103818:	8b 45 f4             	mov    -0xc(%ebp),%eax
c010381b:	8b 40 14             	mov    0x14(%eax),%eax
c010381e:	a3 10 73 11 c0       	mov    %eax,0xc0117310

		printk("send MM read request, target_pcb = %d, va = %d, length = %d\n", pcb -> pid, va,  ph -> memsz);
c0103823:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103826:	8b 50 14             	mov    0x14(%eax),%edx
c0103829:	8b 45 0c             	mov    0xc(%ebp),%eax
c010382c:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c0103832:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0103836:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0103839:	89 54 24 08          	mov    %edx,0x8(%esp)
c010383d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103841:	c7 04 24 94 42 10 c0 	movl   $0xc0104294,(%esp)
c0103848:	e8 9f cb ff ff       	call   c01003ec <printk>

		send(MM, &m);
c010384d:	a1 e0 b6 1d c0       	mov    0xc01db6e0,%eax
c0103852:	c7 44 24 04 fc 72 11 	movl   $0xc01172fc,0x4(%esp)
c0103859:	c0 
c010385a:	89 04 24             	mov    %eax,(%esp)
c010385d:	e8 5c e2 ff ff       	call   c0101abe <send>
		receive(MM, &m);
c0103862:	a1 e0 b6 1d c0       	mov    0xc01db6e0,%eax
c0103867:	c7 44 24 04 fc 72 11 	movl   $0xc01172fc,0x4(%esp)
c010386e:	c0 
c010386f:	89 04 24             	mov    %eax,(%esp)
c0103872:	e8 61 e3 ff ff       	call   c0101bd8 <receive>

		printk("received from MM .........Successful\n");
c0103877:	c7 04 24 d4 42 10 c0 	movl   $0xc01042d4,(%esp)
c010387e:	e8 69 cb ff ff       	call   c01003ec <printk>
		copy_from_kernel(pcb, (void *)va, segment_buf, ph -> filesz);
c0103883:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103886:	8b 40 10             	mov    0x10(%eax),%eax
c0103889:	89 c2                	mov    %eax,%edx
c010388b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c010388e:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0103892:	8d 95 10 df ff ff    	lea    -0x20f0(%ebp),%edx
c0103898:	89 54 24 08          	mov    %edx,0x8(%esp)
c010389c:	89 44 24 04          	mov    %eax,0x4(%esp)
c01038a0:	8b 45 0c             	mov    0xc(%ebp),%eax
c01038a3:	89 04 24             	mov    %eax,(%esp)
c01038a6:	e8 43 d9 ff ff       	call   c01011ee <copy_from_kernel>
		printk("copy program segments from kernel to user space.............Successful\n");
c01038ab:	c7 04 24 fc 42 10 c0 	movl   $0xc01042fc,(%esp)
c01038b2:	e8 35 cb ff ff       	call   c01003ec <printk>
	elf = (struct ELFHeader *)buf;

	ph = (struct ProgramHeader *)((char *)elf + elf -> phoff);
	eph = ph + elf -> phnum;
	printk("begin %x, end %x\n", ph, eph);
	for (; ph < eph; ++ ph) {
c01038b7:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
c01038bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c01038be:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c01038c1:	0f 82 6c fe ff ff    	jb     c0103733 <load_init_proc+0xdb>
		printk("received from MM .........Successful\n");
		copy_from_kernel(pcb, (void *)va, segment_buf, ph -> filesz);
		printk("copy program segments from kernel to user space.............Successful\n");
	}

	printk("Finish analyse ELF header\n");
c01038c7:	c7 04 24 44 43 10 c0 	movl   $0xc0104344,(%esp)
c01038ce:	e8 19 cb ff ff       	call   c01003ec <printk>
	//initialize user stack
	uint_32	stack_ptr = 0xC0000000 - 4;
c01038d3:	c7 45 f0 fc ff ff bf 	movl   $0xbffffffc,-0x10(%ebp)
	uint_32 key;

	//eflags
	key = (1 << 9);
c01038da:	c7 85 0c df ff ff 00 	movl   $0x200,-0x20f4(%ebp)
c01038e1:	02 00 00 
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c01038e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01038e7:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c01038ee:	00 
c01038ef:	8d 95 0c df ff ff    	lea    -0x20f4(%ebp),%edx
c01038f5:	89 54 24 08          	mov    %edx,0x8(%esp)
c01038f9:	89 44 24 04          	mov    %eax,0x4(%esp)
c01038fd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103900:	89 04 24             	mov    %eax,(%esp)
c0103903:	e8 e6 d8 ff ff       	call   c01011ee <copy_from_kernel>
	stack_ptr -= 4;
c0103908:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)

	//%cs	
	key = 8;
c010390c:	c7 85 0c df ff ff 08 	movl   $0x8,-0x20f4(%ebp)
c0103913:	00 00 00 
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0103916:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103919:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c0103920:	00 
c0103921:	8d 95 0c df ff ff    	lea    -0x20f4(%ebp),%edx
c0103927:	89 54 24 08          	mov    %edx,0x8(%esp)
c010392b:	89 44 24 04          	mov    %eax,0x4(%esp)
c010392f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103932:	89 04 24             	mov    %eax,(%esp)
c0103935:	e8 b4 d8 ff ff       	call   c01011ee <copy_from_kernel>
	stack_ptr -= 4;
c010393a:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)

	//%eip
	key = elf -> entry;
c010393e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0103941:	8b 40 18             	mov    0x18(%eax),%eax
c0103944:	89 85 0c df ff ff    	mov    %eax,-0x20f4(%ebp)
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c010394a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c010394d:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c0103954:	00 
c0103955:	8d 95 0c df ff ff    	lea    -0x20f4(%ebp),%edx
c010395b:	89 54 24 08          	mov    %edx,0x8(%esp)
c010395f:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103963:	8b 45 0c             	mov    0xc(%ebp),%eax
c0103966:	89 04 24             	mov    %eax,(%esp)
c0103969:	e8 80 d8 ff ff       	call   c01011ee <copy_from_kernel>
	stack_ptr -= 4;
c010396e:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)

	//TrapFrame
	uint_32 i;
	key = 0;
c0103972:	c7 85 0c df ff ff 00 	movl   $0x0,-0x20f4(%ebp)
c0103979:	00 00 00 
	for (i = 0; i < 9; ++ i)
c010397c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0103983:	eb 2c                	jmp    c01039b1 <load_init_proc+0x359>
	{
		copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c0103985:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103988:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c010398f:	00 
c0103990:	8d 95 0c df ff ff    	lea    -0x20f4(%ebp),%edx
c0103996:	89 54 24 08          	mov    %edx,0x8(%esp)
c010399a:	89 44 24 04          	mov    %eax,0x4(%esp)
c010399e:	8b 45 0c             	mov    0xc(%ebp),%eax
c01039a1:	89 04 24             	mov    %eax,(%esp)
c01039a4:	e8 45 d8 ff ff       	call   c01011ee <copy_from_kernel>
		stack_ptr -= 4;
c01039a9:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
	stack_ptr -= 4;

	//TrapFrame
	uint_32 i;
	key = 0;
	for (i = 0; i < 9; ++ i)
c01039ad:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c01039b1:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
c01039b5:	76 ce                	jbe    c0103985 <load_init_proc+0x32d>
		copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
		stack_ptr -= 4;
	}

	//Initialize current_pcb -> esp
	pcb -> esp = (void *)stack_ptr;
c01039b7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c01039ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c01039bd:	89 10                	mov    %edx,(%eax)

	key = stack_ptr + 4;
c01039bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01039c2:	83 c0 04             	add    $0x4,%eax
c01039c5:	89 85 0c df ff ff    	mov    %eax,-0x20f4(%ebp)
	copy_from_kernel(pcb, (void *)stack_ptr, (void *)&key, 4);
c01039cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c01039ce:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
c01039d5:	00 
c01039d6:	8d 95 0c df ff ff    	lea    -0x20f4(%ebp),%edx
c01039dc:	89 54 24 08          	mov    %edx,0x8(%esp)
c01039e0:	89 44 24 04          	mov    %eax,0x4(%esp)
c01039e4:	8b 45 0c             	mov    0xc(%ebp),%eax
c01039e7:	89 04 24             	mov    %eax,(%esp)
c01039ea:	e8 ff d7 ff ff       	call   c01011ee <copy_from_kernel>
	stack_ptr -= 4;
c01039ef:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
}
c01039f3:	c9                   	leave  
c01039f4:	c3                   	ret    

c01039f5 <Create_uthread>:

void Create_uthread(uint_32 file_name) {
c01039f5:	55                   	push   %ebp
c01039f6:	89 e5                	mov    %esp,%ebp
c01039f8:	83 ec 28             	sub    $0x28,%esp

	lock();
c01039fb:	e8 4c df ff ff       	call   c010194c <lock>
	int new = Find_Empty_PCB();
c0103a00:	e8 93 d7 ff ff       	call   c0101198 <Find_Empty_PCB>
c0103a05:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (new == PROC_FULL)
c0103a08:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0103a0c:	75 0c                	jne    c0103a1a <Create_uthread+0x25>
		panic("Process Table is Full!\n");
c0103a0e:	c7 04 24 5f 43 10 c0 	movl   $0xc010435f,(%esp)
c0103a15:	e8 fa c9 ff ff       	call   c0100414 <panic>

	struct PCB *new_pcb = Proc + new;
c0103a1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0103a1d:	89 d0                	mov    %edx,%eax
c0103a1f:	c1 e0 02             	shl    $0x2,%eax
c0103a22:	01 d0                	add    %edx,%eax
c0103a24:	c1 e0 0c             	shl    $0xc,%eax
c0103a27:	05 00 a0 13 c0       	add    $0xc013a000,%eax
c0103a2c:	89 45 f0             	mov    %eax,-0x10(%ebp)

	new_pcb -> pid = new;
c0103a2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103a32:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0103a35:	89 90 1c 20 00 00    	mov    %edx,0x201c(%eax)
	new_pcb -> flag = FALSE;
c0103a3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103a3e:	c6 80 14 20 00 00 00 	movb   $0x0,0x2014(%eax)

	new_pcb -> time_elapsed = 0;
c0103a45:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103a48:	c7 80 f8 34 00 00 00 	movl   $0x0,0x34f8(%eax)
c0103a4f:	00 00 00 

	init_message_pool(new_pcb);
c0103a52:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103a55:	89 04 24             	mov    %eax,(%esp)
c0103a58:	e8 29 d9 ff ff       	call   c0101386 <init_message_pool>

	printk("New pid = %d\n", new_pcb -> pid);
c0103a5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103a60:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c0103a66:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103a6a:	c7 04 24 77 43 10 c0 	movl   $0xc0104377,(%esp)
c0103a71:	e8 76 c9 ff ff       	call   c01003ec <printk>


	init_user_page(new_pcb);
c0103a76:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103a79:	89 04 24             	mov    %eax,(%esp)
c0103a7c:	e8 92 fa ff ff       	call   c0103513 <init_user_page>

	unlock();
c0103a81:	e8 e6 de ff ff       	call   c010196c <unlock>

	load_init_proc(file_name, new_pcb);
c0103a86:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103a89:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103a8d:	8b 45 08             	mov    0x8(%ebp),%eax
c0103a90:	89 04 24             	mov    %eax,(%esp)
c0103a93:	e8 c0 fb ff ff       	call   c0103658 <load_init_proc>

	//initialize kernel stack
	new_pcb -> kstack_top = (void *)((uint_32)(new_pcb -> kstack) + STACK_SIZE - 4);
c0103a98:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103a9b:	83 c0 0c             	add    $0xc,%eax
c0103a9e:	05 fc 1f 00 00       	add    $0x1ffc,%eax
c0103aa3:	89 c2                	mov    %eax,%edx
c0103aa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103aa8:	89 50 04             	mov    %edx,0x4(%eax)
	
	//initialize user stack
	//	Completed in load_init_proc

	//Ready to Schedule
	lock();
c0103aab:	e8 9c de ff ff       	call   c010194c <lock>

	new_pcb -> next = init;
c0103ab0:	8b 15 00 a0 1d c0    	mov    0xc01da000,%edx
c0103ab6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103ab9:	89 90 0c 20 00 00    	mov    %edx,0x200c(%eax)
	new_pcb -> prev = init -> prev;
c0103abf:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c0103ac4:	8b 90 10 20 00 00    	mov    0x2010(%eax),%edx
c0103aca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103acd:	89 90 10 20 00 00    	mov    %edx,0x2010(%eax)
	init -> prev -> next = new_pcb;
c0103ad3:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c0103ad8:	8b 80 10 20 00 00    	mov    0x2010(%eax),%eax
c0103ade:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0103ae1:	89 90 0c 20 00 00    	mov    %edx,0x200c(%eax)
	init -> prev = new_pcb;
c0103ae7:	a1 00 a0 1d c0       	mov    0xc01da000,%eax
c0103aec:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0103aef:	89 90 10 20 00 00    	mov    %edx,0x2010(%eax)
	new_pcb -> status = STATUS_WAITING;
c0103af5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0103af8:	c7 80 18 20 00 00 00 	movl   $0x0,0x2018(%eax)
c0103aff:	00 00 00 

	unlock();
c0103b02:	e8 65 de ff ff       	call   c010196c <unlock>
}
c0103b07:	c9                   	leave  
c0103b08:	c3                   	ret    

c0103b09 <ProcessManagement>:


void ProcessManagement(void) {
c0103b09:	55                   	push   %ebp
c0103b0a:	89 e5                	mov    %esp,%ebp
c0103b0c:	83 ec 18             	sub    $0x18,%esp
c0103b0f:	eb 01                	jmp    c0103b12 <ProcessManagement+0x9>
		{
			Create_uthread(m.pm_msg.file_name);			
			m.type = -1;
			send(m.src, &m);
		}
	}
c0103b11:	90                   	nop
void ProcessManagement(void) {

	static struct Message m;		

	while (TRUE) {
		receive(ANY, &m);
c0103b12:	c7 44 24 04 e0 72 11 	movl   $0xc01172e0,0x4(%esp)
c0103b19:	c0 
c0103b1a:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
c0103b21:	e8 b2 e0 ff ff       	call   c0101bd8 <receive>
		if (m.type == PM_LOAD_PROC)
c0103b26:	a1 e8 72 11 c0       	mov    0xc01172e8,%eax
c0103b2b:	3d aa 00 00 00       	cmp    $0xaa,%eax
c0103b30:	75 df                	jne    c0103b11 <ProcessManagement+0x8>
		{
			Create_uthread(m.pm_msg.file_name);			
c0103b32:	a1 ec 72 11 c0       	mov    0xc01172ec,%eax
c0103b37:	89 04 24             	mov    %eax,(%esp)
c0103b3a:	e8 b6 fe ff ff       	call   c01039f5 <Create_uthread>
			m.type = -1;
c0103b3f:	c7 05 e8 72 11 c0 ff 	movl   $0xffffffff,0xc01172e8
c0103b46:	ff ff ff 
			send(m.src, &m);
c0103b49:	a1 e0 72 11 c0       	mov    0xc01172e0,%eax
c0103b4e:	c7 44 24 04 e0 72 11 	movl   $0xc01172e0,0x4(%esp)
c0103b55:	c0 
c0103b56:	89 04 24             	mov    %eax,(%esp)
c0103b59:	e8 60 df ff ff       	call   c0101abe <send>
		}
	}
c0103b5e:	eb b1                	jmp    c0103b11 <ProcessManagement+0x8>

c0103b60 <test_timer_f>:
#include "kernel.h"

void test_timer_f(void) {
c0103b60:	55                   	push   %ebp
c0103b61:	89 e5                	mov    %esp,%ebp
c0103b63:	83 ec 38             	sub    $0x38,%esp

	struct Message m;

	while (1)
	{
		m.type = TIMER_SET_ALRM;
c0103b66:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%ebp)
		m.int_msg.p1 = current_pcb -> pid;
c0103b6d:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0103b72:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c0103b78:	89 45 e8             	mov    %eax,-0x18(%ebp)
		m.int_msg.p2 = 4;
c0103b7b:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)

		send(TIMER, &m);
c0103b82:	a1 c0 b6 1d c0       	mov    0xc01db6c0,%eax
c0103b87:	8d 55 dc             	lea    -0x24(%ebp),%edx
c0103b8a:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103b8e:	89 04 24             	mov    %eax,(%esp)
c0103b91:	e8 28 df ff ff       	call   c0101abe <send>

		receive(MSG_HARD_INTR, &m);
c0103b96:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0103b99:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103b9d:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c0103ba4:	e8 2f e0 ff ff       	call   c0101bd8 <receive>

		if (m.type == TIMER_ALRM_FIRE)
c0103ba9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103bac:	83 f8 0b             	cmp    $0xb,%eax
c0103baf:	75 0c                	jne    c0103bbd <test_timer_f+0x5d>
			printk("F");
c0103bb1:	c7 04 24 85 43 10 c0 	movl   $0xc0104385,(%esp)
c0103bb8:	e8 2f c8 ff ff       	call   c01003ec <printk>

		send(4, &m);
c0103bbd:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0103bc0:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103bc4:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c0103bcb:	e8 ee de ff ff       	call   c0101abe <send>

	}
c0103bd0:	eb 94                	jmp    c0103b66 <test_timer_f+0x6>

c0103bd2 <test_timer_u>:
}


void test_timer_u(void) {
c0103bd2:	55                   	push   %ebp
c0103bd3:	89 e5                	mov    %esp,%ebp
c0103bd5:	83 ec 38             	sub    $0x38,%esp

	struct Message m;

	while (1)
	{
		receive(3, &m);
c0103bd8:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0103bdb:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103bdf:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c0103be6:	e8 ed df ff ff       	call   c0101bd8 <receive>

		m.type = TIMER_SET_ALRM;
c0103beb:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%ebp)
		m.int_msg.p1 = current_pcb -> pid;
c0103bf2:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0103bf7:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c0103bfd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		m.int_msg.p2 = 1;
c0103c00:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

		send(TIMER, &m);
c0103c07:	a1 c0 b6 1d c0       	mov    0xc01db6c0,%eax
c0103c0c:	8d 55 dc             	lea    -0x24(%ebp),%edx
c0103c0f:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103c13:	89 04 24             	mov    %eax,(%esp)
c0103c16:	e8 a3 de ff ff       	call   c0101abe <send>

		receive(MSG_HARD_INTR, &m);
c0103c1b:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0103c1e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103c22:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c0103c29:	e8 aa df ff ff       	call   c0101bd8 <receive>

		if (m.type == TIMER_ALRM_FIRE)
c0103c2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103c31:	83 f8 0b             	cmp    $0xb,%eax
c0103c34:	75 0c                	jne    c0103c42 <test_timer_u+0x70>
			printk("U");
c0103c36:	c7 04 24 87 43 10 c0 	movl   $0xc0104387,(%esp)
c0103c3d:	e8 aa c7 ff ff       	call   c01003ec <printk>

		send(5, &m);
c0103c42:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0103c45:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103c49:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c0103c50:	e8 69 de ff ff       	call   c0101abe <send>

	}
c0103c55:	eb 81                	jmp    c0103bd8 <test_timer_u+0x6>

c0103c57 <test_timer_c>:
}



void test_timer_c(void) {
c0103c57:	55                   	push   %ebp
c0103c58:	89 e5                	mov    %esp,%ebp
c0103c5a:	83 ec 38             	sub    $0x38,%esp

	struct Message m;

	while (1)
	{
		receive(4, &m);
c0103c5d:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0103c60:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103c64:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
c0103c6b:	e8 68 df ff ff       	call   c0101bd8 <receive>

		m.type = TIMER_SET_ALRM;
c0103c70:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%ebp)
		m.int_msg.p1 = current_pcb -> pid;
c0103c77:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0103c7c:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c0103c82:	89 45 e8             	mov    %eax,-0x18(%ebp)
		m.int_msg.p2 = 1;
c0103c85:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

		send(TIMER, &m);
c0103c8c:	a1 c0 b6 1d c0       	mov    0xc01db6c0,%eax
c0103c91:	8d 55 dc             	lea    -0x24(%ebp),%edx
c0103c94:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103c98:	89 04 24             	mov    %eax,(%esp)
c0103c9b:	e8 1e de ff ff       	call   c0101abe <send>

		receive(MSG_HARD_INTR, &m);
c0103ca0:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0103ca3:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103ca7:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c0103cae:	e8 25 df ff ff       	call   c0101bd8 <receive>

		if (m.type == TIMER_ALRM_FIRE)
c0103cb3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103cb6:	83 f8 0b             	cmp    $0xb,%eax
c0103cb9:	75 0c                	jne    c0103cc7 <test_timer_c+0x70>
			printk("C");
c0103cbb:	c7 04 24 89 43 10 c0 	movl   $0xc0104389,(%esp)
c0103cc2:	e8 25 c7 ff ff       	call   c01003ec <printk>

		send(6, &m);
c0103cc7:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0103cca:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103cce:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
c0103cd5:	e8 e4 dd ff ff       	call   c0101abe <send>

	}
c0103cda:	eb 81                	jmp    c0103c5d <test_timer_c+0x6>

c0103cdc <test_timer_k>:
}


void test_timer_k(void) {
c0103cdc:	55                   	push   %ebp
c0103cdd:	89 e5                	mov    %esp,%ebp
c0103cdf:	83 ec 38             	sub    $0x38,%esp
c0103ce2:	eb 01                	jmp    c0103ce5 <test_timer_k+0x9>
		receive(MSG_HARD_INTR, &m);

		if (m.type == TIMER_ALRM_FIRE)
			printk("K");

	}
c0103ce4:	90                   	nop

	struct Message m;

	while (1)
	{
		receive(5, &m);
c0103ce5:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0103ce8:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103cec:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
c0103cf3:	e8 e0 de ff ff       	call   c0101bd8 <receive>

		m.type = TIMER_SET_ALRM;
c0103cf8:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%ebp)
		m.int_msg.p1 = current_pcb -> pid;
c0103cff:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0103d04:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c0103d0a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		m.int_msg.p2 = 1;
c0103d0d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

		send(TIMER, &m);
c0103d14:	a1 c0 b6 1d c0       	mov    0xc01db6c0,%eax
c0103d19:	8d 55 dc             	lea    -0x24(%ebp),%edx
c0103d1c:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103d20:	89 04 24             	mov    %eax,(%esp)
c0103d23:	e8 96 dd ff ff       	call   c0101abe <send>

		receive(MSG_HARD_INTR, &m);
c0103d28:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0103d2b:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103d2f:	c7 04 24 80 ff ff ff 	movl   $0xffffff80,(%esp)
c0103d36:	e8 9d de ff ff       	call   c0101bd8 <receive>

		if (m.type == TIMER_ALRM_FIRE)
c0103d3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103d3e:	83 f8 0b             	cmp    $0xb,%eax
c0103d41:	75 a1                	jne    c0103ce4 <test_timer_k+0x8>
			printk("K");
c0103d43:	c7 04 24 8b 43 10 c0 	movl   $0xc010438b,(%esp)
c0103d4a:	e8 9d c6 ff ff       	call   c01003ec <printk>

	}
c0103d4f:	eb 93                	jmp    c0103ce4 <test_timer_k+0x8>
c0103d51:	90                   	nop
c0103d52:	90                   	nop
c0103d53:	90                   	nop

c0103d54 <test_tty>:
#include "kernel.h"

#define Buffer_Size	128

void test_tty(void) {
c0103d54:	55                   	push   %ebp
c0103d55:	89 e5                	mov    %esp,%ebp
c0103d57:	81 ec b8 00 00 00    	sub    $0xb8,%esp
	char buf[Buffer_Size];
	int i;
	
	while (1) {

		m.type = DEV_READ;
c0103d5d:	c7 45 e0 0c 00 00 00 	movl   $0xc,-0x20(%ebp)
		m.dev_io.pid = current_pcb -> pid;
c0103d64:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0103d69:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c0103d6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		m.dev_io.length = Buffer_Size;// - 1;
c0103d72:	c7 45 f0 80 00 00 00 	movl   $0x80,-0x10(%ebp)
		m.dev_io.buf = buf;
c0103d79:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
c0103d7f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		

		send(TTY, &m);
c0103d82:	a1 c4 b6 1d c0       	mov    0xc01db6c4,%eax
c0103d87:	8d 55 d8             	lea    -0x28(%ebp),%edx
c0103d8a:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103d8e:	89 04 24             	mov    %eax,(%esp)
c0103d91:	e8 28 dd ff ff       	call   c0101abe <send>
		receive(TTY, &m);
c0103d96:	a1 c4 b6 1d c0       	mov    0xc01db6c4,%eax
c0103d9b:	8d 55 d8             	lea    -0x28(%ebp),%edx
c0103d9e:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103da2:	89 04 24             	mov    %eax,(%esp)
c0103da5:	e8 2e de ff ff       	call   c0101bd8 <receive>

		for (i = 0; i < m.int_msg.p1; ++ i)
c0103daa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0103db1:	eb 40                	jmp    c0103df3 <test_tty+0x9f>
			if ('a' <= buf[i] && buf[i] <= 'z')
c0103db3:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
c0103db9:	03 45 f4             	add    -0xc(%ebp),%eax
c0103dbc:	0f b6 00             	movzbl (%eax),%eax
c0103dbf:	3c 60                	cmp    $0x60,%al
c0103dc1:	7e 2c                	jle    c0103def <test_tty+0x9b>
c0103dc3:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
c0103dc9:	03 45 f4             	add    -0xc(%ebp),%eax
c0103dcc:	0f b6 00             	movzbl (%eax),%eax
c0103dcf:	3c 7a                	cmp    $0x7a,%al
c0103dd1:	7f 1c                	jg     c0103def <test_tty+0x9b>
				buf[i] = buf[i] - 'a' + 'A';
c0103dd3:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
c0103dd9:	03 45 f4             	add    -0xc(%ebp),%eax
c0103ddc:	0f b6 00             	movzbl (%eax),%eax
c0103ddf:	83 e8 20             	sub    $0x20,%eax
c0103de2:	89 c2                	mov    %eax,%edx
c0103de4:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
c0103dea:	03 45 f4             	add    -0xc(%ebp),%eax
c0103ded:	88 10                	mov    %dl,(%eax)
		

		send(TTY, &m);
		receive(TTY, &m);

		for (i = 0; i < m.int_msg.p1; ++ i)
c0103def:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0103df3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0103df6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0103df9:	7f b8                	jg     c0103db3 <test_tty+0x5f>
			if ('a' <= buf[i] && buf[i] <= 'z')
				buf[i] = buf[i] - 'a' + 'A';

		m.type = DEV_WRITE;
c0103dfb:	c7 45 e0 0d 00 00 00 	movl   $0xd,-0x20(%ebp)
		m.dev_io.pid = current_pcb -> pid;
c0103e02:	a1 04 a0 1d c0       	mov    0xc01da004,%eax
c0103e07:	8b 80 1c 20 00 00    	mov    0x201c(%eax),%eax
c0103e0d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		m.dev_io.length = i;
c0103e10:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0103e13:	89 45 f0             	mov    %eax,-0x10(%ebp)
		m.dev_io.buf = buf;
c0103e16:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
c0103e1c:	89 45 e8             	mov    %eax,-0x18(%ebp)

		send(TTY, &m);
c0103e1f:	a1 c4 b6 1d c0       	mov    0xc01db6c4,%eax
c0103e24:	8d 55 d8             	lea    -0x28(%ebp),%edx
c0103e27:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103e2b:	89 04 24             	mov    %eax,(%esp)
c0103e2e:	e8 8b dc ff ff       	call   c0101abe <send>
		receive(TTY, &m);
c0103e33:	a1 c4 b6 1d c0       	mov    0xc01db6c4,%eax
c0103e38:	8d 55 d8             	lea    -0x28(%ebp),%edx
c0103e3b:	89 54 24 04          	mov    %edx,0x4(%esp)
c0103e3f:	89 04 24             	mov    %eax,(%esp)
c0103e42:	e8 91 dd ff ff       	call   c0101bd8 <receive>
	}
c0103e47:	e9 11 ff ff ff       	jmp    c0103d5d <test_tty+0x9>

c0103e4c <idle_cpu>:
	uint_32 page_directory_base : 20;
};

/* put the CPU into idle, waiting for next interrupt */
static inline void
idle_cpu() {
c0103e4c:	55                   	push   %ebp
c0103e4d:	89 e5                	mov    %esp,%ebp
	asm volatile("hlt");
c0103e4f:	f4                   	hlt    
}
c0103e50:	5d                   	pop    %ebp
c0103e51:	c3                   	ret    

c0103e52 <test_ide>:
#include "kernel.h"

uint_32 hack;

void test_ide(void) {
c0103e52:	55                   	push   %ebp
c0103e53:	89 e5                	mov    %esp,%ebp
c0103e55:	83 ec 18             	sub    $0x18,%esp

	static struct Message m;

	m.type = PM_LOAD_PROC;
c0103e58:	c7 05 20 73 11 c0 aa 	movl   $0xaa,0xc0117320
c0103e5f:	00 00 00 
	m.pm_msg.file_name = 1;
c0103e62:	c7 05 24 73 11 c0 01 	movl   $0x1,0xc0117324
c0103e69:	00 00 00 

	send(PM, &m);
c0103e6c:	a1 00 27 1e c0       	mov    0xc01e2700,%eax
c0103e71:	c7 44 24 04 18 73 11 	movl   $0xc0117318,0x4(%esp)
c0103e78:	c0 
c0103e79:	89 04 24             	mov    %eax,(%esp)
c0103e7c:	e8 3d dc ff ff       	call   c0101abe <send>
	receive(PM, &m);
c0103e81:	a1 00 27 1e c0       	mov    0xc01e2700,%eax
c0103e86:	c7 44 24 04 18 73 11 	movl   $0xc0117318,0x4(%esp)
c0103e8d:	c0 
c0103e8e:	89 04 24             	mov    %eax,(%esp)
c0103e91:	e8 42 dd ff ff       	call   c0101bd8 <receive>
	
	hack = 0;
c0103e96:	c7 05 04 27 1e c0 00 	movl   $0x0,0xc01e2704
c0103e9d:	00 00 00 
	printk("hack address = %x\n", &hack);
c0103ea0:	c7 44 24 04 04 27 1e 	movl   $0xc01e2704,0x4(%esp)
c0103ea7:	c0 
c0103ea8:	c7 04 24 8d 43 10 c0 	movl   $0xc010438d,(%esp)
c0103eaf:	e8 38 c5 ff ff       	call   c01003ec <printk>
	while (1)
	{
		printk("%d", hack);
c0103eb4:	a1 04 27 1e c0       	mov    0xc01e2704,%eax
c0103eb9:	89 44 24 04          	mov    %eax,0x4(%esp)
c0103ebd:	c7 04 24 a0 43 10 c0 	movl   $0xc01043a0,(%esp)
c0103ec4:	e8 23 c5 ff ff       	call   c01003ec <printk>
		idle_cpu();
c0103ec9:	e8 7e ff ff ff       	call   c0103e4c <idle_cpu>
	}
c0103ece:	eb e4                	jmp    c0103eb4 <test_ide+0x62>
